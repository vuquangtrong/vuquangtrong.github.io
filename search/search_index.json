{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Welcome to Code Inside Out \u2693\ufe0e Interesting stuff in Embedded Systems and IoT Applications. From hardwares to cloud applications. Step by step. (\uff89 \u25d5 \u30ee \u25d5)\uff89*:\u30fb\uff9f \u2727 There is a huge amount of information on the internet and it will take time to search and find out which is usable. This blog comes to host what I\u2019ve read and marked as useful to faster look them up again. I also discovered that I learn better when I write about the things that I am learning, and of course, sharing is always better than holding. I hope you can find something interesting here, and feel free to leave a comment or feedback to help me improve this blog. Happy coding!","title":"Home"},{"location":"#code-inside-out","text":"Interesting stuff in Embedded Systems and IoT Applications. From hardwares to cloud applications. Step by step. (\uff89 \u25d5 \u30ee \u25d5)\uff89*:\u30fb\uff9f \u2727 There is a huge amount of information on the internet and it will take time to search and find out which is usable. This blog comes to host what I\u2019ve read and marked as useful to faster look them up again. I also discovered that I learn better when I write about the things that I am learning, and of course, sharing is always better than holding. I hope you can find something interesting here, and feel free to leave a comment or feedback to help me improve this blog. Happy coding!","title":"Code Inside Out"},{"location":"archives/","text":"","title":"Archives"},{"location":"archives/wonavct/","text":"Archived Project 1. Overview \u2693\ufe0e This product consists of 3 components: A rover : which will be mounted on a vehicle and capture images with location information. A base station : which has a main role of providing location correcting information to the rover to archive higher accuracy A software : which has ability to recognize objects in captured images, calculate their coordination and export the geographical information to Map, or any GIS application. Block diagram: WonavCT System Overview 2. Hardware \u2693\ufe0e Raspberry Pi B+ Broadcom BCM2835 (700 MHz) 512 MB RAM 5 MP Camera Navio RAW U-blox NEO-6T GPS, 5Hz NMEA, RTCM3 message GPS/SBAS (WAAS, EGNOS, MSAS) L1 Band 3-axises IMU at 100 Hz GNSS Antenna LNA: 40 dB Wi-Fi W725N Access Point for Mobile Control EDGE/3G SIM Modem Internet access for communication between Rover and Base Station 3. Software \u2693\ufe0e Real-time Kernel from Navio Based on Raspbian (Debian), repo: https://github.com/emlid/linux-rt-rpi Overclock (optional) sudo nano /boot/config.txt # add below lines force_turbo = 1 arm_freq = 1000 gpu_freq = 300 sdram_freq = 600 Increase GPU memory for camera work sudo nano /boot/config.txt # add below lines gpu_mem = 256 Increase USB current sudo nano /boot/config.txt # add below lines max_usb_current = 1 Open SPI and I2C port sudo nano /etc/modprobe.d/raspi-blacklist.conf # add `#` before below lines blacklist spi-bcm2708 blacklist i2c-bcm2708 sudo nano /etc/modules # add below lines i2c-bcm2708 spi-dev i2c-dev RTKLib Repo from Emlid: https://github.com/emlid/RTKLIB Base repo: https://github.com/tomojitakasu/RTKLIB Wi-Fi Driver TPLink WN725N diver version 2 is used. Refer to https://wikidevi.com/wiki/TP-LINK_TL-WN725N_v2 and http://elinux.org/RPi_USB_Wi-Fi_Adapters#Working_USB_Wi-Fi_Adapters . 3G Modem Driver GPRS/EDGE/3G modem driver is built from https://github.com/sk-vpohybe/stopa-monitor/wiki/3G-modem-Huawei-E169-E620-E800 , refer more in http://elinux.org/RPi_VerifiedPeripherals . This option only work when 2 modems have the same 3G provider for their SIM, and the IP addresses are publicly accessible. Only RTK mode need internet communication Setup on Rover and Base Station sudo nano /etc/wvdial.conf # add profile [ mobi ] Init1 = AT Init2 = AT+CPIN = \"0000\" Init3 = AT+CGDCONT = 1 , \"IP\" , \"internet\" Init4 = ATQ0 V1 E1 S0 = 0 & C1 & D2 +FCLASS = 0 Phone = *99***1# ISDN = 1 Username = mms Password = mms Modem = /dev/ttyUSB0 Baud = 460800 Stupid Mode = on Dial to connect to the Internet: sudo wvdial mobi & # check the IP address --> WvDial: Internet dialer version 1 .61 --> Initializing modem. --> Sending: AT AT OK --> Sending: AT+CGDCONT = 1 , \"IP\" , \"internet\" AT+CGDCONT = 1 , \"IP\" , \"internet\" OK --> Sending: ATQ0 V1 E1 S0 = 0 & C1 & D2 +FCLASS = 0 ATQ0 V1 E1 S0 = 0 & C1 & D2 +FCLASS = 0 OK --> Modem initialized. --> Sending: ATDT*99***1# --> Waiting for carrier. ATDT*99***1# CONNECT 7200000 --> Carrier detected. Starting PPP immediately. --> Starting pppd at Tue Apr 30 19 :15:34 2013 --> Pid of pppd: 2475 --> Using interface ppp0 --> Authentication ( CHAP ) started --> Authentication ( CHAP ) successful --> local IP address 10 .144.158.201 --> remote IP address 10 .64.64.64 --> primary DNS address 213 .151.200.31 --> secondary DNS address 85 .237.225.250 4. Operation \u2693\ufe0e Get a precious accurate location of the Base Station Turn on Base Station, setup to send RTCM3 messages on a tcpsvr through 3G IP address Turn on Rover, and setup to receive RTCM2 message from Base Station on a tcpcli through 3G internet","title":"WonavCT"},{"location":"archives/wonavct/#1-overview","text":"This product consists of 3 components: A rover : which will be mounted on a vehicle and capture images with location information. A base station : which has a main role of providing location correcting information to the rover to archive higher accuracy A software : which has ability to recognize objects in captured images, calculate their coordination and export the geographical information to Map, or any GIS application. Block diagram: WonavCT System Overview","title":"1. Overview"},{"location":"archives/wonavct/#2-hardware","text":"Raspberry Pi B+ Broadcom BCM2835 (700 MHz) 512 MB RAM 5 MP Camera Navio RAW U-blox NEO-6T GPS, 5Hz NMEA, RTCM3 message GPS/SBAS (WAAS, EGNOS, MSAS) L1 Band 3-axises IMU at 100 Hz GNSS Antenna LNA: 40 dB Wi-Fi W725N Access Point for Mobile Control EDGE/3G SIM Modem Internet access for communication between Rover and Base Station","title":"2. Hardware"},{"location":"archives/wonavct/#3-software","text":"Real-time Kernel from Navio Based on Raspbian (Debian), repo: https://github.com/emlid/linux-rt-rpi Overclock (optional) sudo nano /boot/config.txt # add below lines force_turbo = 1 arm_freq = 1000 gpu_freq = 300 sdram_freq = 600 Increase GPU memory for camera work sudo nano /boot/config.txt # add below lines gpu_mem = 256 Increase USB current sudo nano /boot/config.txt # add below lines max_usb_current = 1 Open SPI and I2C port sudo nano /etc/modprobe.d/raspi-blacklist.conf # add `#` before below lines blacklist spi-bcm2708 blacklist i2c-bcm2708 sudo nano /etc/modules # add below lines i2c-bcm2708 spi-dev i2c-dev RTKLib Repo from Emlid: https://github.com/emlid/RTKLIB Base repo: https://github.com/tomojitakasu/RTKLIB Wi-Fi Driver TPLink WN725N diver version 2 is used. Refer to https://wikidevi.com/wiki/TP-LINK_TL-WN725N_v2 and http://elinux.org/RPi_USB_Wi-Fi_Adapters#Working_USB_Wi-Fi_Adapters . 3G Modem Driver GPRS/EDGE/3G modem driver is built from https://github.com/sk-vpohybe/stopa-monitor/wiki/3G-modem-Huawei-E169-E620-E800 , refer more in http://elinux.org/RPi_VerifiedPeripherals . This option only work when 2 modems have the same 3G provider for their SIM, and the IP addresses are publicly accessible. Only RTK mode need internet communication Setup on Rover and Base Station sudo nano /etc/wvdial.conf # add profile [ mobi ] Init1 = AT Init2 = AT+CPIN = \"0000\" Init3 = AT+CGDCONT = 1 , \"IP\" , \"internet\" Init4 = ATQ0 V1 E1 S0 = 0 & C1 & D2 +FCLASS = 0 Phone = *99***1# ISDN = 1 Username = mms Password = mms Modem = /dev/ttyUSB0 Baud = 460800 Stupid Mode = on Dial to connect to the Internet: sudo wvdial mobi & # check the IP address --> WvDial: Internet dialer version 1 .61 --> Initializing modem. --> Sending: AT AT OK --> Sending: AT+CGDCONT = 1 , \"IP\" , \"internet\" AT+CGDCONT = 1 , \"IP\" , \"internet\" OK --> Sending: ATQ0 V1 E1 S0 = 0 & C1 & D2 +FCLASS = 0 ATQ0 V1 E1 S0 = 0 & C1 & D2 +FCLASS = 0 OK --> Modem initialized. --> Sending: ATDT*99***1# --> Waiting for carrier. ATDT*99***1# CONNECT 7200000 --> Carrier detected. Starting PPP immediately. --> Starting pppd at Tue Apr 30 19 :15:34 2013 --> Pid of pppd: 2475 --> Using interface ppp0 --> Authentication ( CHAP ) started --> Authentication ( CHAP ) successful --> local IP address 10 .144.158.201 --> remote IP address 10 .64.64.64 --> primary DNS address 213 .151.200.31 --> secondary DNS address 85 .237.225.250","title":"3. Software"},{"location":"archives/wonavct/#4-operation","text":"Get a precious accurate location of the Base Station Turn on Base Station, setup to send RTCM3 messages on a tcpsvr through 3G IP address Turn on Rover, and setup to receive RTCM2 message from Base Station on a tcpcli through 3G internet","title":"4. Operation"},{"location":"blog/","text":"Blog \u2693\ufe0e","title":"Blog"},{"location":"blog/#blog","text":"","title":"Blog"},{"location":"blog/c-cpp/","text":"","title":"C/C++"},{"location":"blog/c-cpp/notes/","text":".md-typeset h2, .md-typeset h3 { font-size: 0; /* hide header but still scroll to its anchor */ } .md-typeset .content { margin-left: 3em; } Size of a datatype \u2693\ufe0e Size of a datatype The size of a type is determined by the compiler, which doesn\u2019t have anything to do with the actual hardware. The returned value of sizeof(char) is always 1 by definition, and sizeof(int) always returns 4. Starting at C99, bool is present as an 1-byte datatype. Note that, size of a pointer should be 4 bytes on any 32-bit C/C++ compiler, and be 8 bytes on any 64-bit C/C++ compiler. Use int instead of char or uint8_t ? It depends on the target machine: if it is incapable to access unaligned memory (e.g. Cortex-M0 processors), then using int is much faster. Do not use sizeof for array parameters \u2693\ufe0e Do not use sizeof for array parameters The function fun() below receives an array parameter arr[] and tries to find out the number of elements in the array arr[] using the sizeof operator. In main, there is also a statement calculating the number of elements in the array arr[] . But 2 methods return different results. int fun ( int arr []) { return sizeof ( arr ) / sizeof ( arr [ 0 ]); // WRONG } void main () { int arr [ 4 ] = { 0 , 0 , 0 , 0 }; int arr_size = sizeof ( arr ) / sizeof ( arr [ 0 ]); // RIGHT if ( arr_size == fun ( arr )) {} // ??? } In C, array parameters are treated as pointers. So the expression: sizeof ( arr ) / sizeof ( arr [ 0 ]) becomes sizeof ( int * ) / sizeof ( int ) which finally is evaluated as sizeof(arr) = sizeof(int *) which is 4 or 8 depending on the compiler. Use goto if it can reduce the complexity \u2693\ufe0e Use goto if it can reduce the complexity Using goto is considered as bad and harmful, but if it is used with care, it can be helpful to reduce the complexity. For example: void func (...) { byte * buf1 = malloc (...); byte * buf2 = malloc (...); FILE * f = fopen (...); if ( f == NULL ) goto func_cleanup_and_exit ; ... if ( something_goes_wrong_1 ) goto func_close_file_cleanup_and_exit ; ... func_close_file_cleanup_and_exit : fclose ( f ); func_cleanup_and_exit : free ( buf1 ); free ( buf2 ); func_exit : return ; }; Array[index] is actually pointer accessing \u2693\ufe0e Array[index] is actually pointer accessing The expression a[i] is translated to *(a+i) . That\u2019s why this weird code printf ( \"%c\" , 3 [ \"abcdef\" ]); still runs. C/C++ does not check the index range, therefore it is easy to access a memory block which is out of range of the array: int a [] = { 1 , 2 }; int b [] = { 3 , 4 , 5 }; // if a and b are allocated next to each other, b[-1] will be a[1] printf ( \"%d\" , b [ -1 ]); There are Buffer overflow exploiting techniques based on this problem of accessing memory block outsides of the array. Short-circuit evaluation \u2693\ufe0e Short-circuit evaluation At runtime, in the expression with AND operator if ( a && b && c ) , the part (b) will be calculated only if (a) is true, and (c) will be calculated only if (a) and (b) are both true. The same story about OR operator: in the expression if ( a || b || c ) , if the sub-expression (a) is true, others will not be computed. This helps in case the next condition depends on the previous condition, such as accessing to pointer: if ( pointer != NULL && pointer -> member == 3 ) {} or, checking for a higher priority condition first: if ( flag_a || flag_b ) {} However, as the consequence, do not expect the 2 nd or later conditions are executed in all cases. Cached data \u2693\ufe0e Cached data Modern CPUs have L1, L2, and L3 caches. When fetching data from memory, it usually read a whole line of L1 cache. For example, L1 cache has 64-bytes lines, it will fetch 64 bytes from memory at once when it accesses to a memory. So if a data structure is larger than 64 bytes, it is very important to divide it by 2 parts: the most demanded fields and the less ones. It is desirable to place the most demanded fields in the first 64 bytes. C++ classes are also concerned. Compiler warnings \u2693\ufe0e Compiler warnings Is it worth to turn on -Wall to see all possible problems which usually are small error and hard to get noticed. In GCC, it is also possible to turn all warnings to errors with -Werror . If enabled, any problem marked as error will halt the compiler, and it must be fixed. Example 1: int f1 ( int a , int b , int c ) { int ret = a + b + c ; printf ( \"%d\" , ret ); } int main () { printf ( \"%d\" , f1 ( 1 , 2 , 3 )); } The main() function still runs but prints out wrong value due to non-returned function. A random value will be seen because compiler still use the return register which is not set the desired value. Example 2: bool f1 () { return condition ? true : false ; } bool is 1-byte datatype Compiler will generate a code to set the low byte of the AL register to 0x01 or 0x00 , because the return size of 1 byte. Other higher bytes of the AL register won\u2019t change. However, in a different file, f1() is assumed to return int , not bool , therefore compiler generates code to compare 4 bytes of an int which is only updated its lowest byte after f1() returns. There maybe some random value in higher bytes of that int memory block, and it will cause a wrong comparison: void main () { if ( f1 ()) } Buffered stdout but non-buffered stderr \u2693\ufe0e Buffered stdout but non-buffered stderr The stdout or cout is a buffered output , so a user, usually not aware of this, sees the output by portions. Sometimes, the program outputs something and then crashes, and if buffer did not have time to flush into the console, a user will not see anything. This is sometimes inconvenient. Thus, for dumping more important information, including debugging, it is better to use the un-buffered stderr or cerr . Negative error code \u2693\ufe0e Negative error code The simplest way to indicate to caller about its children\u2019s success is to return a boolean value: false \u2014 in case of error, and true in case of success. However, to indicate more status than just 2 states, a number can be returned. And it can be extended more to indicate different status of failure or success using signed numbers: /** * func() - A function that does something * input: * none * output: * -2: error on buffer * -1: error on transmission * 0: success but no response * 1: success with a response = NACK * 2: success with a response = ACK */ Bit fields \u2693\ufe0e Bit fields A very popular thing in C, and also in programming generally is working with bits. For flags specifying, in order to not make a typo and mess, they can be defined using bit shifting: #define FLAG1 (1<<0) #define FLAG2 (1<<1) #define FLAG3 (1<<2) #define FLAG4 (1<<3) #define FLAG5 (1<<4) and some macros can be use to work on bits: #define IS_SET(flag, bit) (((flag) & (bit)) ? true : false) #define SET_BIT(var, bit) ((var) |= (bit)) #define REMOVE_BIT(var, bit) ((var) &= ~(bit)) For better performance, use bool for each bit, but it will cost memory.","title":"Notes"},{"location":"blog/c-cpp/notes/#size-of-a-datatype","text":"Size of a datatype The size of a type is determined by the compiler, which doesn\u2019t have anything to do with the actual hardware. The returned value of sizeof(char) is always 1 by definition, and sizeof(int) always returns 4. Starting at C99, bool is present as an 1-byte datatype. Note that, size of a pointer should be 4 bytes on any 32-bit C/C++ compiler, and be 8 bytes on any 64-bit C/C++ compiler. Use int instead of char or uint8_t ? It depends on the target machine: if it is incapable to access unaligned memory (e.g. Cortex-M0 processors), then using int is much faster.","title":"Size of a datatype"},{"location":"blog/c-cpp/notes/#do-not-use-sizeof-for-array-parameters","text":"Do not use sizeof for array parameters The function fun() below receives an array parameter arr[] and tries to find out the number of elements in the array arr[] using the sizeof operator. In main, there is also a statement calculating the number of elements in the array arr[] . But 2 methods return different results. int fun ( int arr []) { return sizeof ( arr ) / sizeof ( arr [ 0 ]); // WRONG } void main () { int arr [ 4 ] = { 0 , 0 , 0 , 0 }; int arr_size = sizeof ( arr ) / sizeof ( arr [ 0 ]); // RIGHT if ( arr_size == fun ( arr )) {} // ??? } In C, array parameters are treated as pointers. So the expression: sizeof ( arr ) / sizeof ( arr [ 0 ]) becomes sizeof ( int * ) / sizeof ( int ) which finally is evaluated as sizeof(arr) = sizeof(int *) which is 4 or 8 depending on the compiler.","title":"Do not use sizeof for array parameters"},{"location":"blog/c-cpp/notes/#use-goto-if-it-can-reduce-the-complexity","text":"Use goto if it can reduce the complexity Using goto is considered as bad and harmful, but if it is used with care, it can be helpful to reduce the complexity. For example: void func (...) { byte * buf1 = malloc (...); byte * buf2 = malloc (...); FILE * f = fopen (...); if ( f == NULL ) goto func_cleanup_and_exit ; ... if ( something_goes_wrong_1 ) goto func_close_file_cleanup_and_exit ; ... func_close_file_cleanup_and_exit : fclose ( f ); func_cleanup_and_exit : free ( buf1 ); free ( buf2 ); func_exit : return ; };","title":"Use goto if it can reduce the complexity"},{"location":"blog/c-cpp/notes/#arrayindex-is-actually-pointer-accessing","text":"Array[index] is actually pointer accessing The expression a[i] is translated to *(a+i) . That\u2019s why this weird code printf ( \"%c\" , 3 [ \"abcdef\" ]); still runs. C/C++ does not check the index range, therefore it is easy to access a memory block which is out of range of the array: int a [] = { 1 , 2 }; int b [] = { 3 , 4 , 5 }; // if a and b are allocated next to each other, b[-1] will be a[1] printf ( \"%d\" , b [ -1 ]); There are Buffer overflow exploiting techniques based on this problem of accessing memory block outsides of the array.","title":"Array[index] is actually pointer accessing"},{"location":"blog/c-cpp/notes/#short-circuit-evaluation","text":"Short-circuit evaluation At runtime, in the expression with AND operator if ( a && b && c ) , the part (b) will be calculated only if (a) is true, and (c) will be calculated only if (a) and (b) are both true. The same story about OR operator: in the expression if ( a || b || c ) , if the sub-expression (a) is true, others will not be computed. This helps in case the next condition depends on the previous condition, such as accessing to pointer: if ( pointer != NULL && pointer -> member == 3 ) {} or, checking for a higher priority condition first: if ( flag_a || flag_b ) {} However, as the consequence, do not expect the 2 nd or later conditions are executed in all cases.","title":"Short-circuit evaluation"},{"location":"blog/c-cpp/notes/#cached-data","text":"Cached data Modern CPUs have L1, L2, and L3 caches. When fetching data from memory, it usually read a whole line of L1 cache. For example, L1 cache has 64-bytes lines, it will fetch 64 bytes from memory at once when it accesses to a memory. So if a data structure is larger than 64 bytes, it is very important to divide it by 2 parts: the most demanded fields and the less ones. It is desirable to place the most demanded fields in the first 64 bytes. C++ classes are also concerned.","title":"Cached data"},{"location":"blog/c-cpp/notes/#compiler-warnings","text":"Compiler warnings Is it worth to turn on -Wall to see all possible problems which usually are small error and hard to get noticed. In GCC, it is also possible to turn all warnings to errors with -Werror . If enabled, any problem marked as error will halt the compiler, and it must be fixed. Example 1: int f1 ( int a , int b , int c ) { int ret = a + b + c ; printf ( \"%d\" , ret ); } int main () { printf ( \"%d\" , f1 ( 1 , 2 , 3 )); } The main() function still runs but prints out wrong value due to non-returned function. A random value will be seen because compiler still use the return register which is not set the desired value. Example 2: bool f1 () { return condition ? true : false ; } bool is 1-byte datatype Compiler will generate a code to set the low byte of the AL register to 0x01 or 0x00 , because the return size of 1 byte. Other higher bytes of the AL register won\u2019t change. However, in a different file, f1() is assumed to return int , not bool , therefore compiler generates code to compare 4 bytes of an int which is only updated its lowest byte after f1() returns. There maybe some random value in higher bytes of that int memory block, and it will cause a wrong comparison: void main () { if ( f1 ()) }","title":"Compiler warnings"},{"location":"blog/c-cpp/notes/#buffered-stdout-but-non-buffered-stderr","text":"Buffered stdout but non-buffered stderr The stdout or cout is a buffered output , so a user, usually not aware of this, sees the output by portions. Sometimes, the program outputs something and then crashes, and if buffer did not have time to flush into the console, a user will not see anything. This is sometimes inconvenient. Thus, for dumping more important information, including debugging, it is better to use the un-buffered stderr or cerr .","title":"Buffered stdout but non-buffered stderr"},{"location":"blog/c-cpp/notes/#negative-error-code","text":"Negative error code The simplest way to indicate to caller about its children\u2019s success is to return a boolean value: false \u2014 in case of error, and true in case of success. However, to indicate more status than just 2 states, a number can be returned. And it can be extended more to indicate different status of failure or success using signed numbers: /** * func() - A function that does something * input: * none * output: * -2: error on buffer * -1: error on transmission * 0: success but no response * 1: success with a response = NACK * 2: success with a response = ACK */","title":"Negative error code"},{"location":"blog/c-cpp/notes/#bit-fields","text":"Bit fields A very popular thing in C, and also in programming generally is working with bits. For flags specifying, in order to not make a typo and mess, they can be defined using bit shifting: #define FLAG1 (1<<0) #define FLAG2 (1<<1) #define FLAG3 (1<<2) #define FLAG4 (1<<3) #define FLAG5 (1<<4) and some macros can be use to work on bits: #define IS_SET(flag, bit) (((flag) & (bit)) ? true : false) #define SET_BIT(var, bit) ((var) |= (bit)) #define REMOVE_BIT(var, bit) ((var) &= ~(bit)) For better performance, use bool for each bit, but it will cost memory.","title":"Bit fields"},{"location":"blog/lidar/","text":"","title":"Lidar"},{"location":"blog/lidar/livox-sdk/","text":"1. Prerequisites \u2693\ufe0e Ubuntu 14.04/ 16.04/ 18.04, support x64 x86 and ARM (Nvidia TX2) Windows 7/ 10, Visual Studio 2015 Update3/ 2017/ 2019 C++11 compiler Livox SDK needs to be built in the host machine, therefore, some tool-chain and build tools have to be installed. sudo apt-get update && \\ sudo apt-get install -y build-essential && \\ sudo apt-get install -y curl && \\ sudo apt-get install -y git && \\ sudo apt-get install -y cmake 2. Dependencies \u2693\ufe0e 2.1. Point Cloud Library \u2693\ufe0e The Point Cloud Library (PCL) is a large scale, open project[1] for point cloud processing. The PCL framework contains numerous state-of-the art algorithms including filtering, feature estimation, surface reconstruction, registration, model fitting and segmentation. sudo apt install -y libpcl-dev 2.2. Eigen \u2693\ufe0e Eigen is a C++ template library for linear algebra: matrices, vectors, numerical solvers, and related algorithms. sudo apt install -y libeigen3-dev 2.3. OpenCV \u2693\ufe0e OpenCV (Open Source Computer Vision Library) is an open-source computer vision library and has bindings for C++, Python, and Java. It is used for a very wide range of applications, including medical image analysis, stitching street view images, surveillance video, detecting and recognizing faces, tracking moving objects, extracting 3D models, and much more. OpenCV can take advantage of multi-core processing and features GPU acceleration for real-time operation. sudo apt install -y python-opencv python3-opencv 2.4. Re-link libraries \u2693\ufe0e On Desktop: sudo ln -s /usr/bin/vtk6 /usr/bin/vtk sudo ln -s /usr/lib/python2.7/dist-packages/vtk/libvtkRenderingPythonTkWidgets.x86_64-linux-gnu.so /usr/lib/x86_64-linux-gnu/libvtkRenderingPythonTkWidgets.so On Raspberry Pi: sudo ln -s /usr/bin/vtk6 /usr/bin/vtk sudo ln -s /usr/lib/python2.7/dist-packages/vtk/libvtkRenderingPythonTkWidgets.arm-linux-gnueabihf.so /usr/lib/arm-linux-gnueabihf/libvtkRenderingPythonTkWidgets.so 3. Install Livox SDK \u2693\ufe0e The official guide is at https://github.com/Livox-SDK/Livox-SDK . Livox SDK is the software development kit designed for all Livox products. It is developed based on C/C++ following Livox SDK Communication Protocol, and provides easy-to-use C style API. With Livox SDK, users can quickly connect to Livox products and receive point cloud data. Livox SDK provides the implementation of control commands and point cloud data transmission. Please refer to the Livox SDK Communication Protocol for detailed information. In general, the SDK will connect to the Lidar sensor, through UDP packages in a network, the sequence flow is shown as below: Livox sequence data flow Installation git clone https://github.com/Livox-SDK/Livox-SDK.git && \\ cd Livox-SDK && \\ cd build && \\ cmake .. && \\ make && \\ sudo make install ARM-Linux Cross Compile The following commands will install C and C++ cross compiler tool-chains for 32bit and 64bit ARM board. You need to install the correct tool-chain for your ARM board. For 64bit SoC ARM board, only install 64bit tool-chain, and for 32bit SoC ARM board, only install 32bit tool-chain. Install ARM 32 bits cross compile tool-chain\uff1a sudo apt-get install gcc-arm-linux-gnueabi g++-arm-linux-gnueabi Install ARM 64 bits cross compile tool-chain\uff1a sudo apt-get install gcc-aarch64-linux-gnu g++-aarch64-linux-gnu Cross Compile Livox-SDK for ARM 32 bits tool-chain\uff0cIn the Livox SDK directory\uff0crun the following commands to cross compile the project: cd Livox-SDK && \\ cd build && \\ cmake .. -DCMAKE_SYSTEM_NAME = Linux && \\ -DCMAKE_C_COMPILER = arm-linux-gnueabi-gcc && \\ -DCMAKE_CXX_COMPILER = arm-linux-gnueabi-g++ && \\ make && \\ sudo make install For ARM 64 bits tool-chain\uff0cin the Livox SDK directory\uff0crun the following commands to cross compile the project: cd Livox-SDK && \\ cd build && \\ cmake .. -DCMAKE_SYSTEM_NAME = Linux && \\ -DCMAKE_C_COMPILER = aarch64-linux-gnu-gcc && \\ -DCMAKE_CXX_COMPILER = aarch64-linux-gnu-g++ && \\ make && \\ sudo make install Note that gcc / g++ cross compiler need to support C ++11 standard. 4. Install Livox ROS Driver \u2693\ufe0e ROS driver can be run under Ubuntu 14.04/ 16.04/ 18.04 operating system with ROS environment (indigo, kinetic, melodic) installed. 4.1. Install ROS \u2693\ufe0e ROS (Robot Operating System) provides libraries and tools to help software developers create robot applications. It provides hardware abstraction, device drivers, libraries, visualizers, message-passing, package management, and more. Be sure to install the full version of ROS (ros-<distro>-desktop-full). Refer to Install ROS guide to complete the installation. Main steps include: Setup source list to get ROS packages: sudo sh -c 'echo \"deb http://packages.ros.org/ros/ubuntu $(lsb_release -sc) main\" > /etc/apt/sources.list.d/ros-latest.list' Add keys: sudo apt install -y curl && \\ curl -s https://raw.githubusercontent.com/ros/rosdistro/master/ros.asc | sudo apt-key add - Then pull the package list: sudo apt update Finally, install a desktop-full package as recommended to start learning: sudo apt install -y ros-melodic-desktop-full 4.2. Install Livox ROS driver \u2693\ufe0e Get livox_ros_driver from GitHub git clone https://github.com/Livox-SDK/livox_ros_driver.git ws_livox/src Be sure to use the above command to clone the code to the local, otherwise it will compile error due to the file path problem. Then build it: cd ws_livox && \\ catkin_make If running catkin_make gives error of command not found, it\u2019s probably that the ROS setup.bash is not executed and included in ~/.bashrc . See above section to source it. Read more in https://github.com/Livox-SDK/livox_ros_driver . This driver supports both 2 modes: HUB *_hub_* or LIDAR Direct *_lidar_* . 4.2.1. ROS Node \u2693\ufe0e This driver will create a new node named livox_lidar_publisher , which publishes 2 new types of messages: Livox Point Cloud message # Livox publish pointcloud msg format. Header header # ROS standard message header uint64 timebase # The time of first point uint32 point_num # Total number of pointclouds uint8 lidar_id # Lidar device id number uint8 [ 3 ] rsvd # Reserved use CustomPoint [] points # Pointcloud data Livox Point # Livox custom pointcloud format. uint32 offset_time # offset time relative to the base time float32 x # X axis, unit:m float32 y # Y axis, unit:m float32 z # Z axis, unit:m uint8 reflectivity # reflectivity, 0~255 uint8 tag # livox tag uint8 line # laser number in lidar 4.2.2. Configurations \u2693\ufe0e The configuration file is in ws_livox/src/livox_ros_driver/config . LiDAR\u2019s configuration parameter Parameter Type Description Default broadcast_code String LiDAR broadcast code x enable_connect Boolean false return_mode Int Return mode: 0 \u2013 First single return mode 1 \u2013 The strongest single return mode 2 \u2013 Dual return mode 0 coordinate Int Coordinate: 0 \u2013 Cartesian 1 \u2013 Spherical 0 imu_rate Int Push frequency of IMU sensor data: 0 \u2013 stop push 1 \u2013 200 Hz Currently only Horizon supports this, MID serials do not support it 0 extrinsic_parameter_source Int Whether to enable extrinsic parameter automatic compensation of LiDAR external reference 0 \u2013 Disabled 1 \u2013 Enabled 0 Timestamp synchronization Parameter Type Description Default enable_timesync Boolean false device_name String Name of the serial device which outputs GPRMC/GNRMC messages every second /dev/ttyUSB0 comm_device_type Int Type of device sending timestamp information 0 \u2013 Serial port or USB virtual serial port device other \u2013 not support 0 baudrate_index Int Baud rate of serial device: 0 \u2013 2400 1 \u2013 4800 2 \u2013 9600 3 \u2013 19200 4 \u2013 38400 5 \u2013 57600 6 \u2013 115200 7 \u2013 230400 8 \u2013 460800 9 \u2013 500000 10 \u2013 576000 11 \u2013 921600 2 (9600) parity_index Int parity type 0 \u2013 8 bits data without parity 1 \u2013 7 bits data 1bit even parity 2 \u2013 7 bits data 1bit odd parity 3 \u2013 7 bits data 1bit 0, without parity 0 livox_lidar_config.json { \"lidar_config\" : [ { \"broadcast_code\" : \"1PQDH5B00100041\" , \"enable_connect\" : false , \"return_mode\" : 0 , \"coordinate\" : 0 , \"imu_rate\" : 0 , \"extrinsic_parameter_source\" : 0 , \"enable_high_sensitivity\" : false } ], \"timesync_config\" : { \"enable_timesync\" : false , \"device_name\" : \"/dev/ttyUSB0\" , \"comm_device_type\" : 0 , \"baudrate_index\" : 2 , \"parity_index\" : 0 } } 4.2.3. Timestamp \u2693\ufe0e Prepare a GPS device to ensure that the GPS can output UTC time information in GPRMC/GNRMC format through the serial port or USB virtual serial port, and support PPS signal output. Connect the GPS serial port to the host running livox_ros_driver , set the corresponding device name in the config file Connect the GPS PPS signal line to LiDAR Be sure to set the output frequency of GPRMC/GNRMC time information of GPS to 1Hz 4.2.4. Launches \u2693\ufe0e Different launch files have different configuration parameter values and are used in different scenarios: Launch file name Description livox_lidar.launch Connect to Livox LiDAR device Publish pointcloud2 format data livox_lidar_msg.launch Connect to Livox LiDAR device Publish livox customized pointcloud data livox_lidar_rviz.launch Connect to Livox LiDAR device Publish pointcloud2 format data Autoload rviz Launch parameters Parameter Description Default publish_freq Set the frequency of point cloud publish 10.0 multi_topic 0 \u2013 All LiDAR devices use the same topic to publish point cloud data 1 \u2013 Each LiDAR device has its own topic to publish point cloud data 0 xfer_format 0 \u2013 Livox pointcloud2 ( PointXYZRTL ) point cloud format 1 \u2013 Livox customized point cloud format 2 \u2013 Standard pointcloud2 ( PointXYZI ) point cloud format in the PCL library 0 4.2.5. Missing features \u2693\ufe0e Even the build is completed, there are still some warning during the compilation due to missing definitions. -- Could NOT find ensenso (missing: ENSENSO_LIBRARY ENSENSO_INCLUDE_DIR) ** WARNING ** io features related to ensenso will be disabled -- Could NOT find DAVIDSDK (missing: DAVIDSDK_LIBRARY DAVIDSDK_INCLUDE_DIR) ** WARNING ** io features related to davidSDK will be disabled -- Could NOT find DSSDK (missing: _DSSDK_LIBRARIES) ** WARNING ** io features related to dssdk will be disabled ** WARNING ** io features related to pcap will be disabled ** WARNING ** io features related to png will be disabled -- Found libusb-1.0: /usr/include ** WARNING ** io features related to libusb-1.0 will be disabled -- Checking for module 'flann' -- Found flann, version 1.9.1 -- Found Flann: /usr/lib/x86_64-linux-gnu/libflann_cpp_s.a -- Could NOT find ensenso (missing: ENSENSO_LIBRARY ENSENSO_INCLUDE_DIR) ** WARNING ** visualization features related to ensenso will be disabled -- Could NOT find DAVIDSDK (missing: DAVIDSDK_LIBRARY DAVIDSDK_INCLUDE_DIR) ** WARNING ** visualization features related to davidSDK will be disabled -- Could NOT find DSSDK (missing: _DSSDK_LIBRARIES) ** WARNING ** visualization features related to dssdk will be disabled -- Could NOT find RSSDK (missing: _RSSDK_LIBRARIES) ** WARNING ** visualization features related to rssdk will be disabled At this time, they do not harm, then these warning may be solved later.","title":"Livox SDK"},{"location":"blog/lidar/livox-sdk/#1-prerequisites","text":"Ubuntu 14.04/ 16.04/ 18.04, support x64 x86 and ARM (Nvidia TX2) Windows 7/ 10, Visual Studio 2015 Update3/ 2017/ 2019 C++11 compiler Livox SDK needs to be built in the host machine, therefore, some tool-chain and build tools have to be installed. sudo apt-get update && \\ sudo apt-get install -y build-essential && \\ sudo apt-get install -y curl && \\ sudo apt-get install -y git && \\ sudo apt-get install -y cmake","title":"1. Prerequisites"},{"location":"blog/lidar/livox-sdk/#2-dependencies","text":"","title":"2. Dependencies"},{"location":"blog/lidar/livox-sdk/#21-point-cloud-library","text":"The Point Cloud Library (PCL) is a large scale, open project[1] for point cloud processing. The PCL framework contains numerous state-of-the art algorithms including filtering, feature estimation, surface reconstruction, registration, model fitting and segmentation. sudo apt install -y libpcl-dev","title":"2.1. Point Cloud Library"},{"location":"blog/lidar/livox-sdk/#22-eigen","text":"Eigen is a C++ template library for linear algebra: matrices, vectors, numerical solvers, and related algorithms. sudo apt install -y libeigen3-dev","title":"2.2. Eigen"},{"location":"blog/lidar/livox-sdk/#23-opencv","text":"OpenCV (Open Source Computer Vision Library) is an open-source computer vision library and has bindings for C++, Python, and Java. It is used for a very wide range of applications, including medical image analysis, stitching street view images, surveillance video, detecting and recognizing faces, tracking moving objects, extracting 3D models, and much more. OpenCV can take advantage of multi-core processing and features GPU acceleration for real-time operation. sudo apt install -y python-opencv python3-opencv","title":"2.3. OpenCV"},{"location":"blog/lidar/livox-sdk/#24-re-link-libraries","text":"On Desktop: sudo ln -s /usr/bin/vtk6 /usr/bin/vtk sudo ln -s /usr/lib/python2.7/dist-packages/vtk/libvtkRenderingPythonTkWidgets.x86_64-linux-gnu.so /usr/lib/x86_64-linux-gnu/libvtkRenderingPythonTkWidgets.so On Raspberry Pi: sudo ln -s /usr/bin/vtk6 /usr/bin/vtk sudo ln -s /usr/lib/python2.7/dist-packages/vtk/libvtkRenderingPythonTkWidgets.arm-linux-gnueabihf.so /usr/lib/arm-linux-gnueabihf/libvtkRenderingPythonTkWidgets.so","title":"2.4. Re-link libraries"},{"location":"blog/lidar/livox-sdk/#3-install-livox-sdk","text":"The official guide is at https://github.com/Livox-SDK/Livox-SDK . Livox SDK is the software development kit designed for all Livox products. It is developed based on C/C++ following Livox SDK Communication Protocol, and provides easy-to-use C style API. With Livox SDK, users can quickly connect to Livox products and receive point cloud data. Livox SDK provides the implementation of control commands and point cloud data transmission. Please refer to the Livox SDK Communication Protocol for detailed information. In general, the SDK will connect to the Lidar sensor, through UDP packages in a network, the sequence flow is shown as below: Livox sequence data flow Installation git clone https://github.com/Livox-SDK/Livox-SDK.git && \\ cd Livox-SDK && \\ cd build && \\ cmake .. && \\ make && \\ sudo make install ARM-Linux Cross Compile The following commands will install C and C++ cross compiler tool-chains for 32bit and 64bit ARM board. You need to install the correct tool-chain for your ARM board. For 64bit SoC ARM board, only install 64bit tool-chain, and for 32bit SoC ARM board, only install 32bit tool-chain. Install ARM 32 bits cross compile tool-chain\uff1a sudo apt-get install gcc-arm-linux-gnueabi g++-arm-linux-gnueabi Install ARM 64 bits cross compile tool-chain\uff1a sudo apt-get install gcc-aarch64-linux-gnu g++-aarch64-linux-gnu Cross Compile Livox-SDK for ARM 32 bits tool-chain\uff0cIn the Livox SDK directory\uff0crun the following commands to cross compile the project: cd Livox-SDK && \\ cd build && \\ cmake .. -DCMAKE_SYSTEM_NAME = Linux && \\ -DCMAKE_C_COMPILER = arm-linux-gnueabi-gcc && \\ -DCMAKE_CXX_COMPILER = arm-linux-gnueabi-g++ && \\ make && \\ sudo make install For ARM 64 bits tool-chain\uff0cin the Livox SDK directory\uff0crun the following commands to cross compile the project: cd Livox-SDK && \\ cd build && \\ cmake .. -DCMAKE_SYSTEM_NAME = Linux && \\ -DCMAKE_C_COMPILER = aarch64-linux-gnu-gcc && \\ -DCMAKE_CXX_COMPILER = aarch64-linux-gnu-g++ && \\ make && \\ sudo make install Note that gcc / g++ cross compiler need to support C ++11 standard.","title":"3. Install Livox SDK"},{"location":"blog/lidar/livox-sdk/#4-install-livox-ros-driver","text":"ROS driver can be run under Ubuntu 14.04/ 16.04/ 18.04 operating system with ROS environment (indigo, kinetic, melodic) installed.","title":"4. Install Livox ROS Driver"},{"location":"blog/lidar/livox-sdk/#41-install-ros","text":"ROS (Robot Operating System) provides libraries and tools to help software developers create robot applications. It provides hardware abstraction, device drivers, libraries, visualizers, message-passing, package management, and more. Be sure to install the full version of ROS (ros-<distro>-desktop-full). Refer to Install ROS guide to complete the installation. Main steps include: Setup source list to get ROS packages: sudo sh -c 'echo \"deb http://packages.ros.org/ros/ubuntu $(lsb_release -sc) main\" > /etc/apt/sources.list.d/ros-latest.list' Add keys: sudo apt install -y curl && \\ curl -s https://raw.githubusercontent.com/ros/rosdistro/master/ros.asc | sudo apt-key add - Then pull the package list: sudo apt update Finally, install a desktop-full package as recommended to start learning: sudo apt install -y ros-melodic-desktop-full","title":"4.1. Install ROS"},{"location":"blog/lidar/livox-sdk/#42-install-livox-ros-driver","text":"Get livox_ros_driver from GitHub git clone https://github.com/Livox-SDK/livox_ros_driver.git ws_livox/src Be sure to use the above command to clone the code to the local, otherwise it will compile error due to the file path problem. Then build it: cd ws_livox && \\ catkin_make If running catkin_make gives error of command not found, it\u2019s probably that the ROS setup.bash is not executed and included in ~/.bashrc . See above section to source it. Read more in https://github.com/Livox-SDK/livox_ros_driver . This driver supports both 2 modes: HUB *_hub_* or LIDAR Direct *_lidar_* .","title":"4.2. Install Livox ROS driver"},{"location":"blog/lidar/livox-sdk/#421-ros-node","text":"This driver will create a new node named livox_lidar_publisher , which publishes 2 new types of messages: Livox Point Cloud message # Livox publish pointcloud msg format. Header header # ROS standard message header uint64 timebase # The time of first point uint32 point_num # Total number of pointclouds uint8 lidar_id # Lidar device id number uint8 [ 3 ] rsvd # Reserved use CustomPoint [] points # Pointcloud data Livox Point # Livox custom pointcloud format. uint32 offset_time # offset time relative to the base time float32 x # X axis, unit:m float32 y # Y axis, unit:m float32 z # Z axis, unit:m uint8 reflectivity # reflectivity, 0~255 uint8 tag # livox tag uint8 line # laser number in lidar","title":"4.2.1. ROS Node"},{"location":"blog/lidar/livox-sdk/#422-configurations","text":"The configuration file is in ws_livox/src/livox_ros_driver/config . LiDAR\u2019s configuration parameter Parameter Type Description Default broadcast_code String LiDAR broadcast code x enable_connect Boolean false return_mode Int Return mode: 0 \u2013 First single return mode 1 \u2013 The strongest single return mode 2 \u2013 Dual return mode 0 coordinate Int Coordinate: 0 \u2013 Cartesian 1 \u2013 Spherical 0 imu_rate Int Push frequency of IMU sensor data: 0 \u2013 stop push 1 \u2013 200 Hz Currently only Horizon supports this, MID serials do not support it 0 extrinsic_parameter_source Int Whether to enable extrinsic parameter automatic compensation of LiDAR external reference 0 \u2013 Disabled 1 \u2013 Enabled 0 Timestamp synchronization Parameter Type Description Default enable_timesync Boolean false device_name String Name of the serial device which outputs GPRMC/GNRMC messages every second /dev/ttyUSB0 comm_device_type Int Type of device sending timestamp information 0 \u2013 Serial port or USB virtual serial port device other \u2013 not support 0 baudrate_index Int Baud rate of serial device: 0 \u2013 2400 1 \u2013 4800 2 \u2013 9600 3 \u2013 19200 4 \u2013 38400 5 \u2013 57600 6 \u2013 115200 7 \u2013 230400 8 \u2013 460800 9 \u2013 500000 10 \u2013 576000 11 \u2013 921600 2 (9600) parity_index Int parity type 0 \u2013 8 bits data without parity 1 \u2013 7 bits data 1bit even parity 2 \u2013 7 bits data 1bit odd parity 3 \u2013 7 bits data 1bit 0, without parity 0 livox_lidar_config.json { \"lidar_config\" : [ { \"broadcast_code\" : \"1PQDH5B00100041\" , \"enable_connect\" : false , \"return_mode\" : 0 , \"coordinate\" : 0 , \"imu_rate\" : 0 , \"extrinsic_parameter_source\" : 0 , \"enable_high_sensitivity\" : false } ], \"timesync_config\" : { \"enable_timesync\" : false , \"device_name\" : \"/dev/ttyUSB0\" , \"comm_device_type\" : 0 , \"baudrate_index\" : 2 , \"parity_index\" : 0 } }","title":"4.2.2. Configurations"},{"location":"blog/lidar/livox-sdk/#423-timestamp","text":"Prepare a GPS device to ensure that the GPS can output UTC time information in GPRMC/GNRMC format through the serial port or USB virtual serial port, and support PPS signal output. Connect the GPS serial port to the host running livox_ros_driver , set the corresponding device name in the config file Connect the GPS PPS signal line to LiDAR Be sure to set the output frequency of GPRMC/GNRMC time information of GPS to 1Hz","title":"4.2.3. Timestamp"},{"location":"blog/lidar/livox-sdk/#424-launches","text":"Different launch files have different configuration parameter values and are used in different scenarios: Launch file name Description livox_lidar.launch Connect to Livox LiDAR device Publish pointcloud2 format data livox_lidar_msg.launch Connect to Livox LiDAR device Publish livox customized pointcloud data livox_lidar_rviz.launch Connect to Livox LiDAR device Publish pointcloud2 format data Autoload rviz Launch parameters Parameter Description Default publish_freq Set the frequency of point cloud publish 10.0 multi_topic 0 \u2013 All LiDAR devices use the same topic to publish point cloud data 1 \u2013 Each LiDAR device has its own topic to publish point cloud data 0 xfer_format 0 \u2013 Livox pointcloud2 ( PointXYZRTL ) point cloud format 1 \u2013 Livox customized point cloud format 2 \u2013 Standard pointcloud2 ( PointXYZI ) point cloud format in the PCL library 0","title":"4.2.4. Launches"},{"location":"blog/lidar/livox-sdk/#425-missing-features","text":"Even the build is completed, there are still some warning during the compilation due to missing definitions. -- Could NOT find ensenso (missing: ENSENSO_LIBRARY ENSENSO_INCLUDE_DIR) ** WARNING ** io features related to ensenso will be disabled -- Could NOT find DAVIDSDK (missing: DAVIDSDK_LIBRARY DAVIDSDK_INCLUDE_DIR) ** WARNING ** io features related to davidSDK will be disabled -- Could NOT find DSSDK (missing: _DSSDK_LIBRARIES) ** WARNING ** io features related to dssdk will be disabled ** WARNING ** io features related to pcap will be disabled ** WARNING ** io features related to png will be disabled -- Found libusb-1.0: /usr/include ** WARNING ** io features related to libusb-1.0 will be disabled -- Checking for module 'flann' -- Found flann, version 1.9.1 -- Found Flann: /usr/lib/x86_64-linux-gnu/libflann_cpp_s.a -- Could NOT find ensenso (missing: ENSENSO_LIBRARY ENSENSO_INCLUDE_DIR) ** WARNING ** visualization features related to ensenso will be disabled -- Could NOT find DAVIDSDK (missing: DAVIDSDK_LIBRARY DAVIDSDK_INCLUDE_DIR) ** WARNING ** visualization features related to davidSDK will be disabled -- Could NOT find DSSDK (missing: _DSSDK_LIBRARIES) ** WARNING ** visualization features related to dssdk will be disabled -- Could NOT find RSSDK (missing: _RSSDK_LIBRARIES) ** WARNING ** visualization features related to rssdk will be disabled At this time, they do not harm, then these warning may be solved later.","title":"4.2.5. Missing features"},{"location":"blog/linux/","text":"","title":"Linux"},{"location":"blog/linux/byobu/","text":"1. Install \u2693\ufe0e Byobu is an easy-to-use wrapper around the tmux (or screen ) terminal multiplexer. Byobu\u2019s primary features include multiple console windows, split panes within each window, notifications and status badges to display the status of the host, and persistent sessions across multiple connections. Byobu Byobu\u2019s primary features include multiple console windows, split panes within each window, notifications and status badges to display the status of the host, and persistent sessions across multiple connections. Ubuntu should come with Byobu installed by default. To check that Byobu is installed, try running this command to output its version. byobu --version If it is not installed, install it with a simple command: sudo apt install byobu Byobu can be configured to run by default at every text login (SSH or TTY). That behavior can be toggled with the byobu-enable and byobu-disable commands. Insert below line to the end of ~/.bashrc will run Byobu whenever a local terminal is run: _byobu_sourced = 1 . /usr/bin/byobu-launch 2 >/dev/null || true When running Byobu for the first time, it will start with just in a single window. The bottom of the screen has the status bar, which displays OS and version, a list of open windows, and various system metrics like pending updates, RAM usage and time and date. A session is simply a running instance of Byobu. A session consists of a collection of windows, which are basically shell sessions, and panes, which are windows split into multiple sections. Press Ctrl-F6 or type exit to end a session. 2. Key Bindings \u2693\ufe0e Byobu is a configuration layer on top of GNU Screen. As such, all of GNU Screen\u2019s keybindings work in Byobu exactly as in Screen. Moreover, Byobu provides a comprehensive, advanced set of commands bound to the F-keys on most keyboards. Windows Management Key Description F2 Create a new window Shift - F2 Split the screen horizontally Ctrl - F2 Split the screen vertically F3 Move to the previous window Shift - F3 Move focus to the next split F4 Move to the next window Shift - F4 Move focus to the previous split Shift - Arrows Move focus Session management Key Description Ctrl - D Exit the session F6 Detach from the session and logout Shift - F6 Detach from the session, but do not log out Ctrl - F5 Reconnect any SSH/GPG sockets or agents Misc. Key Description F5 Refresh all status notifications F7 Enter scroll back/search mode F8 Rename the current window F9 Launch the Byobu Configuration Menu F12 GNU Screen\u2019s Escape Key Alt - Page Up Scroll back through this window\u2019s history Alt - Page Down Scroll forward through this window\u2019s history Shift - F5 Collapse all splits Shift - F12 Toggle all of Byobu\u2019s keybindings on or off 3. Scroll back, Copy & Paste, Search \u2693\ufe0e Each window in Byobu has up to 10000 lines of scroll back history, so a user can enter and navigate using the Alt-PageUp and Alt-PageDown keys. Exit this scroll back mode by hitting Enter . Copy and paste text from scroll back mode: Press the Space bar to start highlighting text Use up / down / left / right / page up / page down to select the text Press Enter to copy the text Paste the text using alt-insert or ctrl-a-] Search up and down in scroll back mode: Press / to search down Press ? to search up Actually, in scroll back mode, Byobu support vi -like commands: h - # Move the cursor left by one character j - # Move the cursor down by one line k - # Move the cursor up by one line l - # Move the cursor right by one character 0 - # Move to the beginning of the current line $ - # Move to the end of the current line G - # Moves to the specified line (defaults to the end of the buffer) ctrl + b - # Page up ctrl + f - # Page down / - # Search forward ? - # Search backward n - # Moves to the next match, either forward or backward 4. Mouse mode \u2693\ufe0e Type F12 , then : (to enable the internal terminal), then enter the command set mouse on for other commands, run list-commands Or press Alt-F12 to toggle mouse. Actions in the mouse mode: Switch between active panes and windows. Click on a window name or pane to switch. Scroll, with the mouse wheel or trackpad Resize panes by dragging and dropping To enable mouse support by default for all these operations, add these lines to ~/.byobu/profile.tmux : set -g mouse on set -g mouse-select-pane on set -g mouse-select-window on set -g mouse-resize-pane on set -g mouse-utf8 on 5. The Backend Multiplexer \u2693\ufe0e By default, Byobu will use tmux as the backend multiplexer. However, if a user prefers to use screen, they can easily change the enabled backend. byobu-select-backend Select the byobu backend: 1. tmux 2. screen 6. Tweaks \u2693\ufe0e Byobu uses default border characters from tmux which shows bold borderlines. Those borderlines are made up of rows and columns in the console, and they are indivisible. In a text-based terminal there is no structural element smaller than one character \u201ccell\u201d (which is about the size of that block cursor). The only way to reduce the size of the borders is to reduce the size of all rows/columns. Fortunately, we can manipulate the colors to give the appearance of a thinner border: set the foreground to the desired color and set the background to the background color of panes. For the latter default value is often sufficient. For example, change the borderline to orange, add these lines to ~/.byobu/profile.tmux : set -g pane-active-border-style fg = colour208,bg = default","title":"Byobu"},{"location":"blog/linux/byobu/#1-install","text":"Byobu is an easy-to-use wrapper around the tmux (or screen ) terminal multiplexer. Byobu\u2019s primary features include multiple console windows, split panes within each window, notifications and status badges to display the status of the host, and persistent sessions across multiple connections. Byobu Byobu\u2019s primary features include multiple console windows, split panes within each window, notifications and status badges to display the status of the host, and persistent sessions across multiple connections. Ubuntu should come with Byobu installed by default. To check that Byobu is installed, try running this command to output its version. byobu --version If it is not installed, install it with a simple command: sudo apt install byobu Byobu can be configured to run by default at every text login (SSH or TTY). That behavior can be toggled with the byobu-enable and byobu-disable commands. Insert below line to the end of ~/.bashrc will run Byobu whenever a local terminal is run: _byobu_sourced = 1 . /usr/bin/byobu-launch 2 >/dev/null || true When running Byobu for the first time, it will start with just in a single window. The bottom of the screen has the status bar, which displays OS and version, a list of open windows, and various system metrics like pending updates, RAM usage and time and date. A session is simply a running instance of Byobu. A session consists of a collection of windows, which are basically shell sessions, and panes, which are windows split into multiple sections. Press Ctrl-F6 or type exit to end a session.","title":"1. Install"},{"location":"blog/linux/byobu/#2-key-bindings","text":"Byobu is a configuration layer on top of GNU Screen. As such, all of GNU Screen\u2019s keybindings work in Byobu exactly as in Screen. Moreover, Byobu provides a comprehensive, advanced set of commands bound to the F-keys on most keyboards. Windows Management Key Description F2 Create a new window Shift - F2 Split the screen horizontally Ctrl - F2 Split the screen vertically F3 Move to the previous window Shift - F3 Move focus to the next split F4 Move to the next window Shift - F4 Move focus to the previous split Shift - Arrows Move focus Session management Key Description Ctrl - D Exit the session F6 Detach from the session and logout Shift - F6 Detach from the session, but do not log out Ctrl - F5 Reconnect any SSH/GPG sockets or agents Misc. Key Description F5 Refresh all status notifications F7 Enter scroll back/search mode F8 Rename the current window F9 Launch the Byobu Configuration Menu F12 GNU Screen\u2019s Escape Key Alt - Page Up Scroll back through this window\u2019s history Alt - Page Down Scroll forward through this window\u2019s history Shift - F5 Collapse all splits Shift - F12 Toggle all of Byobu\u2019s keybindings on or off","title":"2. Key Bindings"},{"location":"blog/linux/byobu/#3-scroll-back-copy--paste-search","text":"Each window in Byobu has up to 10000 lines of scroll back history, so a user can enter and navigate using the Alt-PageUp and Alt-PageDown keys. Exit this scroll back mode by hitting Enter . Copy and paste text from scroll back mode: Press the Space bar to start highlighting text Use up / down / left / right / page up / page down to select the text Press Enter to copy the text Paste the text using alt-insert or ctrl-a-] Search up and down in scroll back mode: Press / to search down Press ? to search up Actually, in scroll back mode, Byobu support vi -like commands: h - # Move the cursor left by one character j - # Move the cursor down by one line k - # Move the cursor up by one line l - # Move the cursor right by one character 0 - # Move to the beginning of the current line $ - # Move to the end of the current line G - # Moves to the specified line (defaults to the end of the buffer) ctrl + b - # Page up ctrl + f - # Page down / - # Search forward ? - # Search backward n - # Moves to the next match, either forward or backward","title":"3. Scroll back, Copy &amp; Paste, Search"},{"location":"blog/linux/byobu/#4-mouse-mode","text":"Type F12 , then : (to enable the internal terminal), then enter the command set mouse on for other commands, run list-commands Or press Alt-F12 to toggle mouse. Actions in the mouse mode: Switch between active panes and windows. Click on a window name or pane to switch. Scroll, with the mouse wheel or trackpad Resize panes by dragging and dropping To enable mouse support by default for all these operations, add these lines to ~/.byobu/profile.tmux : set -g mouse on set -g mouse-select-pane on set -g mouse-select-window on set -g mouse-resize-pane on set -g mouse-utf8 on","title":"4. Mouse mode"},{"location":"blog/linux/byobu/#5-the-backend-multiplexer","text":"By default, Byobu will use tmux as the backend multiplexer. However, if a user prefers to use screen, they can easily change the enabled backend. byobu-select-backend Select the byobu backend: 1. tmux 2. screen","title":"5. The Backend Multiplexer"},{"location":"blog/linux/byobu/#6-tweaks","text":"Byobu uses default border characters from tmux which shows bold borderlines. Those borderlines are made up of rows and columns in the console, and they are indivisible. In a text-based terminal there is no structural element smaller than one character \u201ccell\u201d (which is about the size of that block cursor). The only way to reduce the size of the borders is to reduce the size of all rows/columns. Fortunately, we can manipulate the colors to give the appearance of a thinner border: set the foreground to the desired color and set the background to the background color of panes. For the latter default value is often sufficient. For example, change the borderline to orange, add these lines to ~/.byobu/profile.tmux : set -g pane-active-border-style fg = colour208,bg = default","title":"6. Tweaks"},{"location":"blog/linux/dual-boot/","text":"1. Installation \u2693\ufe0e 1.1. Download an ISO image \u2693\ufe0e Download the latest Ubuntu Desktop version from https://ubuntu.com/download/desktop , or visit https://old-releases.ubuntu.com/releases/ see the list of prebuilt images for older versions. 1.2. Create bootable USB \u2693\ufe0e USB boot is created using Rufus . Create a bootable USB 1.3. Boot from live Ubuntu USB \u2693\ufe0e Press F2 or F12 or any special key mentioned in BIOS guide to change the boot device. 1.4. Start installing Ubuntu \u2693\ufe0e The first few steps are simple as it guides to choose the language and keyboard layout. Installation Mode There are two installation modes: Normal mode All pre-built and packed things will be installed. This mode has smallest installation time Minimal mode All pre-built and packed things will be installed, but many extra packages (office, tools, etc.) will be uninstalled (using apt) to create a lightweight version. Due the un-installation, this mode takes long time to complete No need to download updates or install third-party software just yet. 1.5. Select destination partition \u2693\ufe0e Most of the time, Ubuntu will automatically detect the pre-installed Windows and offer an option Install Ubuntu alongside Windows Boot Manager . Using this mode, Ubuntu will do everything automatically, for example, it will create one partition then have /root with /home and a swap file of 2 GB in size under /root itself. One other option which is more advanced is Something else . In this mode, user has to create and assign mount points manually. 2. Change default boot order \u2693\ufe0e When booting up, Ubuntu will show a Grub boot menu for user to select the target OS. By default, Ubuntu will be listed on the top with index = 0 . Windows boot entry is located at the index = 2 : Grub boot menu Edit the grub by running: sudo nano /etc/default/grub Then change the default OS entry at GRUB_DEFAULT=2 to select Windows. To reduce the waiting time to 2 seconds, edit GRUB_TIMEOUT=2 . Update grub to apply the configuration changes: sudo update-grub Grub Customizer This GUI tool is an easy-to-use application which can be installed by: sudo apt-get install grub-customizer Grub Customizer 3. Settings \u2693\ufe0e 3.1. Fix Date time settings \u2693\ufe0e When using dual boot, after switching from and to an OS, the system time will not be the same. Sometimes, Linux shows correct time, but Windows does not. This strange behavior is because of using internet with auto-update date time function. A computer has two main clocks: a system clock and a hardware clock: A hardware clock which is also called RTC or CMOS/BIOS clock. This clock is outside the operating system, on your computer\u2019s motherboard. It keeps on running even after your system is powered off. The system clock is what is shown inside your operating system. When a computer is powered on, the hardware clock is read and used to set the system clock. Afterwards, the system clock is used for tracking time. If the operating system makes any changes to system clock, like changing time zone etc., it tries to sync this information to the hardware clock. By default, Linux assumes that the time stored in the hardware clock is in UTC, not the local time. On the other hand, Windows thinks that the time stored on the hardware clock is local time . That\u2019s where the trouble starts. There are two ways you can go about handling this issue: Make Windows use UTC time for the hardware clock Make Linux use local time for the hardware clock It is easier to make the changes in Linux: timedatectl set-local-rtc 1 That\u2019s simple as it is.","title":"Dual Boot"},{"location":"blog/linux/dual-boot/#1-installation","text":"","title":"1. Installation"},{"location":"blog/linux/dual-boot/#11-download-an-iso-image","text":"Download the latest Ubuntu Desktop version from https://ubuntu.com/download/desktop , or visit https://old-releases.ubuntu.com/releases/ see the list of prebuilt images for older versions.","title":"1.1. Download an ISO image"},{"location":"blog/linux/dual-boot/#12-create-bootable-usb","text":"USB boot is created using Rufus . Create a bootable USB","title":"1.2. Create bootable USB"},{"location":"blog/linux/dual-boot/#13-boot-from-live-ubuntu-usb","text":"Press F2 or F12 or any special key mentioned in BIOS guide to change the boot device.","title":"1.3. Boot from live Ubuntu USB"},{"location":"blog/linux/dual-boot/#14-start-installing-ubuntu","text":"The first few steps are simple as it guides to choose the language and keyboard layout. Installation Mode There are two installation modes: Normal mode All pre-built and packed things will be installed. This mode has smallest installation time Minimal mode All pre-built and packed things will be installed, but many extra packages (office, tools, etc.) will be uninstalled (using apt) to create a lightweight version. Due the un-installation, this mode takes long time to complete No need to download updates or install third-party software just yet.","title":"1.4. Start installing Ubuntu"},{"location":"blog/linux/dual-boot/#15-select-destination-partition","text":"Most of the time, Ubuntu will automatically detect the pre-installed Windows and offer an option Install Ubuntu alongside Windows Boot Manager . Using this mode, Ubuntu will do everything automatically, for example, it will create one partition then have /root with /home and a swap file of 2 GB in size under /root itself. One other option which is more advanced is Something else . In this mode, user has to create and assign mount points manually.","title":"1.5. Select destination partition"},{"location":"blog/linux/dual-boot/#2-change-default-boot-order","text":"When booting up, Ubuntu will show a Grub boot menu for user to select the target OS. By default, Ubuntu will be listed on the top with index = 0 . Windows boot entry is located at the index = 2 : Grub boot menu Edit the grub by running: sudo nano /etc/default/grub Then change the default OS entry at GRUB_DEFAULT=2 to select Windows. To reduce the waiting time to 2 seconds, edit GRUB_TIMEOUT=2 . Update grub to apply the configuration changes: sudo update-grub Grub Customizer This GUI tool is an easy-to-use application which can be installed by: sudo apt-get install grub-customizer Grub Customizer","title":"2. Change default boot order"},{"location":"blog/linux/dual-boot/#3-settings","text":"","title":"3. Settings"},{"location":"blog/linux/dual-boot/#31-fix-date-time-settings","text":"When using dual boot, after switching from and to an OS, the system time will not be the same. Sometimes, Linux shows correct time, but Windows does not. This strange behavior is because of using internet with auto-update date time function. A computer has two main clocks: a system clock and a hardware clock: A hardware clock which is also called RTC or CMOS/BIOS clock. This clock is outside the operating system, on your computer\u2019s motherboard. It keeps on running even after your system is powered off. The system clock is what is shown inside your operating system. When a computer is powered on, the hardware clock is read and used to set the system clock. Afterwards, the system clock is used for tracking time. If the operating system makes any changes to system clock, like changing time zone etc., it tries to sync this information to the hardware clock. By default, Linux assumes that the time stored in the hardware clock is in UTC, not the local time. On the other hand, Windows thinks that the time stored on the hardware clock is local time . That\u2019s where the trouble starts. There are two ways you can go about handling this issue: Make Windows use UTC time for the hardware clock Make Linux use local time for the hardware clock It is easier to make the changes in Linux: timedatectl set-local-rtc 1 That\u2019s simple as it is.","title":"3.1. Fix Date time settings"},{"location":"blog/linux/samba/","text":"1. Installation \u2693\ufe0e Samba is available from the official Ubuntu repositories. To install it on Ubuntu system follow the steps below: Start by updating the apt packages index: sudo apt update Install the Samba package with the following command: sudo apt install -y samba Once the installation is completed, the Samba service will start automatically. To check whether the Samba server is running, type: sudo systemctl status smbd ```sh smbd.service - Samba SMB Daemon Loaded: loaded (/lib/systemd/system/smbd.service; enabled; vendor preset: enabled) Active: active (running) since Mon 2021-07-12 15:30:57 +07; 1min 41s ago Docs: man:smbd(8) man:samba(7) man:smb.conf(5) Main PID: 4059 (smbd) Status: \"smbd: ready to serve connections...\" Tasks: 4 (limit: 2329) CGroup: /system.slice/smbd.service \u251c\u25004059 /usr/sbin/smbd --foreground --no-process-group \u251c\u25004061 /usr/sbin/smbd --foreground --no-process-group \u251c\u25004062 /usr/sbin/smbd --foreground --no-process-group \u2514\u25004064 /usr/sbin/smbd --foreground --no-process-group Jul 12 15:30:57 ubuntu18 systemd[1]: Starting Samba SMB Daemon... Jul 12 15:30:57 ubuntu18 systemd[1]: Started Samba SMB Daemon. ``` 2. Add a user \u2693\ufe0e Samba has its own user management system. However, any user existing on the samba user list must also exist within /etc/passwd file. Use the smbpasswd command to add a user to Samba user list: sudo smbpasswd -a vqtrong 3. Configuration \u2693\ufe0e Before making changes to the Samba configuration file, create a backup for future reference purposes: sudo cp /etc/samba/smb.conf { ,.backup } Edit the Samba configuration file sudo nano /etc/samba/smb.conf The default configuration file that ships with the Samba package is configured for standalone Samba server. Open the file and make sure server role is set to standalone server . ... # Most people will want \"standalone sever\" or \"member server\". # Running as \"active directory domain controller\" will require first # running \"samba-tool domain provision\" to wipe databases and create a # new domain. server role = standalone server ... Uncomment the [home] section, then edit its options as below: [homes] comment = Home Directories browseable = yes read only = no create mask = 0700 directory mask = 0700 valid users = %S Use mask 0775 to enable execution permission. Save the file, then test the parameters by running the utility testparm to see the configs: testparm testparm Load smb config files from /etc/samba/smb.conf rlimit_max: increasing rlimit_max (1024) to minimum Windows limit (16384) WARNING: The \"syslog\" option is deprecated Processing section \"[homes]\" Processing section \"[printers]\" Processing section \"[print$]\" Loaded services file OK. Server role: ROLE_STANDALONE Press enter to see a dump of your service definitions # Global parameters [global] dns proxy = No log file = /var/log/samba/log.%m map to guest = Bad User max log size = 1000 obey pam restrictions = Yes pam password change = Yes panic action = /usr/share/samba/panic-action %d passwd chat = *Enter\\snew\\s*\\spassword:* %n\\n *Retype\\snew\\s*\\spassword:* %n\\n *password\\supdated\\ssuccessfully* . passwd program = /usr/bin/passwd %u server role = standalone server server string = %h server (Samba, Ubuntu) syslog = 0 unix password sync = Yes usershare allow guests = Yes idmap config * : backend = tdb [homes] comment = Home Directories create mask = 0700 directory mask = 0700 read only = No valid users = %S [printers] browseable = No comment = All Printers create mask = 0700 path = /var/spool/samba printable = Yes [print$] comment = Printer Drivers path = /var/lib/samba/printers Then restart the service: sudo service smbd restart Finally, connect to the Samba Server from another computer with username and password set in above steps. The path to the Samba server can be located by IP Address, e.g. \\\\192.168.100.12\\<username> or by a computer name, e.g. \\\\ubuntu\\<username> .","title":"Samba"},{"location":"blog/linux/samba/#1-installation","text":"Samba is available from the official Ubuntu repositories. To install it on Ubuntu system follow the steps below: Start by updating the apt packages index: sudo apt update Install the Samba package with the following command: sudo apt install -y samba Once the installation is completed, the Samba service will start automatically. To check whether the Samba server is running, type: sudo systemctl status smbd ```sh smbd.service - Samba SMB Daemon Loaded: loaded (/lib/systemd/system/smbd.service; enabled; vendor preset: enabled) Active: active (running) since Mon 2021-07-12 15:30:57 +07; 1min 41s ago Docs: man:smbd(8) man:samba(7) man:smb.conf(5) Main PID: 4059 (smbd) Status: \"smbd: ready to serve connections...\" Tasks: 4 (limit: 2329) CGroup: /system.slice/smbd.service \u251c\u25004059 /usr/sbin/smbd --foreground --no-process-group \u251c\u25004061 /usr/sbin/smbd --foreground --no-process-group \u251c\u25004062 /usr/sbin/smbd --foreground --no-process-group \u2514\u25004064 /usr/sbin/smbd --foreground --no-process-group Jul 12 15:30:57 ubuntu18 systemd[1]: Starting Samba SMB Daemon... Jul 12 15:30:57 ubuntu18 systemd[1]: Started Samba SMB Daemon. ```","title":"1. Installation"},{"location":"blog/linux/samba/#2-add-a-user","text":"Samba has its own user management system. However, any user existing on the samba user list must also exist within /etc/passwd file. Use the smbpasswd command to add a user to Samba user list: sudo smbpasswd -a vqtrong","title":"2. Add a user"},{"location":"blog/linux/samba/#3-configuration","text":"Before making changes to the Samba configuration file, create a backup for future reference purposes: sudo cp /etc/samba/smb.conf { ,.backup } Edit the Samba configuration file sudo nano /etc/samba/smb.conf The default configuration file that ships with the Samba package is configured for standalone Samba server. Open the file and make sure server role is set to standalone server . ... # Most people will want \"standalone sever\" or \"member server\". # Running as \"active directory domain controller\" will require first # running \"samba-tool domain provision\" to wipe databases and create a # new domain. server role = standalone server ... Uncomment the [home] section, then edit its options as below: [homes] comment = Home Directories browseable = yes read only = no create mask = 0700 directory mask = 0700 valid users = %S Use mask 0775 to enable execution permission. Save the file, then test the parameters by running the utility testparm to see the configs: testparm testparm Load smb config files from /etc/samba/smb.conf rlimit_max: increasing rlimit_max (1024) to minimum Windows limit (16384) WARNING: The \"syslog\" option is deprecated Processing section \"[homes]\" Processing section \"[printers]\" Processing section \"[print$]\" Loaded services file OK. Server role: ROLE_STANDALONE Press enter to see a dump of your service definitions # Global parameters [global] dns proxy = No log file = /var/log/samba/log.%m map to guest = Bad User max log size = 1000 obey pam restrictions = Yes pam password change = Yes panic action = /usr/share/samba/panic-action %d passwd chat = *Enter\\snew\\s*\\spassword:* %n\\n *Retype\\snew\\s*\\spassword:* %n\\n *password\\supdated\\ssuccessfully* . passwd program = /usr/bin/passwd %u server role = standalone server server string = %h server (Samba, Ubuntu) syslog = 0 unix password sync = Yes usershare allow guests = Yes idmap config * : backend = tdb [homes] comment = Home Directories create mask = 0700 directory mask = 0700 read only = No valid users = %S [printers] browseable = No comment = All Printers create mask = 0700 path = /var/spool/samba printable = Yes [print$] comment = Printer Drivers path = /var/lib/samba/printers Then restart the service: sudo service smbd restart Finally, connect to the Samba Server from another computer with username and password set in above steps. The path to the Samba server can be located by IP Address, e.g. \\\\192.168.100.12\\<username> or by a computer name, e.g. \\\\ubuntu\\<username> .","title":"3. Configuration"},{"location":"blog/linux/tweaks/","text":"1. Animation \u2693\ufe0e Ubuntu comes with cool effects, but it consumes system resource. Turn it off is a good way to increase system performance. Command line Open a terminal and enter this command: gsettings set org.gnome.desktop.interface enable-animations false GUI tools Either use dconf-editor by installing: sudo apt install dconf-editor Then navigate to /org/gnome/desktop/interface/ and toggle the Enable-Animations option to OFF. Or use gnome-tweak-tool : sudo apt install gnome-tweak-tool Then on the first tab Appearance, toggle the switch Animations . 2. Grub load time \u2693\ufe0e The grub gives you 10 seconds to change between dual boot OS or to go in recovery. This time can be reduced, by entering below command to open grub configuration: sudo gedit /etc/default/grub & Then change GRUB_TIMEOUT=10 to GRUB_TIMEOUT=1 . And update the settings: sudo update-grub 3. Startup applications \u2693\ufe0e Look for Startup Applications and run it. There is a list of startup applications: Remove if you don\u2019t need to run a startup, or Delay the execution by editing the application start command: Add sleep x; to delay x seconds 4. Package installation \u2693\ufe0e 4.1. Mirror server \u2693\ufe0e Ubuntu contacts to many repos to download, update its packages. Choose the best mirror server is a good way to speed up system update or application installation. In Software & Updates \u00bb Ubuntu Software \u00bb Download From and choose Select Best Server . 4.2. apt-fast \u2693\ufe0e apt-fast is a shell script wrapper for apt-get that improves updated and package download speed by downloading packages from multiple connections simultaneously. Install apt-fast via official PPA using the following commands: sudo add-apt-repository ppa:apt-fast/stable sudo apt-get update sudo apt-get install apt-fast 4.3. Remove language translation \u2693\ufe0e Suppressing the language translation while updating will slightly increase the apt-get update speed. To do that, open the following file: sudo gedit /etc/apt/apt.conf.d/00aptitude And add the following line at the end of this file: Acquire::Languages \"none\" ; 5. Unattended Update \u2693\ufe0e Ubuntu has a feature named Unattended Upgrades, which installs the latest security (and others) updates automatically whenever they are available. It comes pre-installed and enabled by default in the recent Ubuntu versions. While this feature helps to keep the Ubuntu system up-to-date, it is also quite annoying sometimes. To disable unattended upgrades on Ubuntu and its derivatives, run: sudo dpkg-reconfigure unattended-upgrades Then choose No and hit ENTER to disable unattended upgrades. 6. Change network connection priority \u2693\ufe0e If machine is connected to Wi-Fi and Ethernet simultaneously, here is a method to set priority connection. Install ifmetric tool: sudo apt-get install ifmetric This command can be used to change the metric of any interface. The interface with lower metric is preferred for Internet . To use this, first see the metrics using route command: route -n Kernel IP routing table Destination Gateway Genmask Flags Metric Ref Use Iface 0 .0.0.0 10 .42.0.1 0 .0.0.0 UG 100 0 0 eth0 0 .0.0.0 10 .42.0.2 0 .0.0.0 UG 600 0 0 wlan0 Here, eth0 has lower metric, so it will be preferred over wlan0 . If you want to prefer wlan0 , then lower its metric: sudo ifmetric wlan0 50 Now, the routing table would look like: route -n Kernel IP routing table Destination Gateway Genmask Flags Metric Ref Use Iface 0 .0.0.0 10 .42.0.2 0 .0.0.0 UG 50 0 0 wlan0 0 .0.0.0 10 .42.0.1 0 .0.0.0 UG 100 0 0 eth0 Now Linux will be using wlan0 for Internet. The change will be reflected immediately. 7. Further improvement \u2693\ufe0e Look at https://easylinuxtipsproject.blogspot.com/p/speed-ubuntu.html .","title":"Tweaks"},{"location":"blog/linux/tweaks/#1-animation","text":"Ubuntu comes with cool effects, but it consumes system resource. Turn it off is a good way to increase system performance. Command line Open a terminal and enter this command: gsettings set org.gnome.desktop.interface enable-animations false GUI tools Either use dconf-editor by installing: sudo apt install dconf-editor Then navigate to /org/gnome/desktop/interface/ and toggle the Enable-Animations option to OFF. Or use gnome-tweak-tool : sudo apt install gnome-tweak-tool Then on the first tab Appearance, toggle the switch Animations .","title":"1. Animation"},{"location":"blog/linux/tweaks/#2-grub-load-time","text":"The grub gives you 10 seconds to change between dual boot OS or to go in recovery. This time can be reduced, by entering below command to open grub configuration: sudo gedit /etc/default/grub & Then change GRUB_TIMEOUT=10 to GRUB_TIMEOUT=1 . And update the settings: sudo update-grub","title":"2. Grub load time"},{"location":"blog/linux/tweaks/#3-startup-applications","text":"Look for Startup Applications and run it. There is a list of startup applications: Remove if you don\u2019t need to run a startup, or Delay the execution by editing the application start command: Add sleep x; to delay x seconds","title":"3. Startup applications"},{"location":"blog/linux/tweaks/#4-package-installation","text":"","title":"4. Package installation"},{"location":"blog/linux/tweaks/#41-mirror-server","text":"Ubuntu contacts to many repos to download, update its packages. Choose the best mirror server is a good way to speed up system update or application installation. In Software & Updates \u00bb Ubuntu Software \u00bb Download From and choose Select Best Server .","title":"4.1. Mirror server"},{"location":"blog/linux/tweaks/#42-apt-fast","text":"apt-fast is a shell script wrapper for apt-get that improves updated and package download speed by downloading packages from multiple connections simultaneously. Install apt-fast via official PPA using the following commands: sudo add-apt-repository ppa:apt-fast/stable sudo apt-get update sudo apt-get install apt-fast","title":"4.2. apt-fast"},{"location":"blog/linux/tweaks/#43-remove-language-translation","text":"Suppressing the language translation while updating will slightly increase the apt-get update speed. To do that, open the following file: sudo gedit /etc/apt/apt.conf.d/00aptitude And add the following line at the end of this file: Acquire::Languages \"none\" ;","title":"4.3. Remove language translation"},{"location":"blog/linux/tweaks/#5-unattended-update","text":"Ubuntu has a feature named Unattended Upgrades, which installs the latest security (and others) updates automatically whenever they are available. It comes pre-installed and enabled by default in the recent Ubuntu versions. While this feature helps to keep the Ubuntu system up-to-date, it is also quite annoying sometimes. To disable unattended upgrades on Ubuntu and its derivatives, run: sudo dpkg-reconfigure unattended-upgrades Then choose No and hit ENTER to disable unattended upgrades.","title":"5. Unattended Update"},{"location":"blog/linux/tweaks/#6-change-network-connection-priority","text":"If machine is connected to Wi-Fi and Ethernet simultaneously, here is a method to set priority connection. Install ifmetric tool: sudo apt-get install ifmetric This command can be used to change the metric of any interface. The interface with lower metric is preferred for Internet . To use this, first see the metrics using route command: route -n Kernel IP routing table Destination Gateway Genmask Flags Metric Ref Use Iface 0 .0.0.0 10 .42.0.1 0 .0.0.0 UG 100 0 0 eth0 0 .0.0.0 10 .42.0.2 0 .0.0.0 UG 600 0 0 wlan0 Here, eth0 has lower metric, so it will be preferred over wlan0 . If you want to prefer wlan0 , then lower its metric: sudo ifmetric wlan0 50 Now, the routing table would look like: route -n Kernel IP routing table Destination Gateway Genmask Flags Metric Ref Use Iface 0 .0.0.0 10 .42.0.2 0 .0.0.0 UG 50 0 0 wlan0 0 .0.0.0 10 .42.0.1 0 .0.0.0 UG 100 0 0 eth0 Now Linux will be using wlan0 for Internet. The change will be reflected immediately.","title":"6. Change network connection priority"},{"location":"blog/linux/tweaks/#7-further-improvement","text":"Look at https://easylinuxtipsproject.blogspot.com/p/speed-ubuntu.html .","title":"7. Further improvement"},{"location":"blog/pi/","text":"A Raspberry Pi 4 model B Topics \u2693\ufe0e There are thousands of topics on the internet discussing Raspberry Pi. In here, I post some short-and-consistent posts written as guides and notes for a quick reference when learning and doing projects on Raspberry Pi boards. Because Raspberry Pi OS (previously called Raspbian ) is based on the Debian Linux-based OS, a lot of technical knowledge in Linux-OS can be applied to. Communities \u2693\ufe0e Official Homepage: https://www.raspberrypi.org News: https://magpi.raspberrypi.org Sharing: https://projects.raspberrypi.org/en https://www.hackster.io/raspberry-pi/projects https://www.instructables.com/Raspberry-Pi-Projects https://pimylifeup.com/category/projects Forums: https://www.raspberrypi.org/forums","title":"Raspberry Pi"},{"location":"blog/pi/#topics","text":"There are thousands of topics on the internet discussing Raspberry Pi. In here, I post some short-and-consistent posts written as guides and notes for a quick reference when learning and doing projects on Raspberry Pi boards. Because Raspberry Pi OS (previously called Raspbian ) is based on the Debian Linux-based OS, a lot of technical knowledge in Linux-OS can be applied to.","title":"Topics"},{"location":"blog/pi/#communities","text":"Official Homepage: https://www.raspberrypi.org News: https://magpi.raspberrypi.org Sharing: https://projects.raspberrypi.org/en https://www.hackster.io/raspberry-pi/projects https://www.instructables.com/Raspberry-Pi-Projects https://pimylifeup.com/category/projects Forums: https://www.raspberrypi.org/forums","title":"Communities"},{"location":"blog/pi/backup-sdcard/","text":"1. Win32 Disk Imager \u2693\ufe0e Win32 Disk Images is a popular and famous application on Windows to write a raw disk image to a removable device or backup a removable device to a raw image file. Raw image mode Raw image mode means all bits of the device are copied to the image file. It means the size of the backup file is equal to the device\u2019s total size. This method will take a long time to complete, depending on the size of the storage device. Download it from win32diskimager and run it as administrative right. 1.1. Backup \u2693\ufe0e Select the Image File to save the SD Card content Select the source Device Click on Read Win32 Disk Imager: save device to image 1.2. Restore \u2693\ufe0e Select the Image File of the SD Card content Select the target Device Click on Write Win32 Disk Imager: restore from image to device 2. Acronis True Image \u2693\ufe0e Acronis True Image is an application that provides data protection for personal users including, backup, archive, access and recovery for Windows, macOS, iOS, and Android operating systems. This application is a commercial product, try it for free before purchasing a copy. 2.1. Backup and Restore \u2693\ufe0e Acronis will not back up empty space on the SD Card, it only saves the useful data, therefore the backup progress is much faster than dumping all bits and the file size is smaller. It also has incremental backup mode which only writes modified data, compared to the previous backup, therefore it can save a lot of disk space. The restore process is as simple as the backup. There are buttons and guide to help to do those actions: Acronis True Image: backup/restore disk","title":"Backup SDCard"},{"location":"blog/pi/backup-sdcard/#1-win32-disk-imager","text":"Win32 Disk Images is a popular and famous application on Windows to write a raw disk image to a removable device or backup a removable device to a raw image file. Raw image mode Raw image mode means all bits of the device are copied to the image file. It means the size of the backup file is equal to the device\u2019s total size. This method will take a long time to complete, depending on the size of the storage device. Download it from win32diskimager and run it as administrative right.","title":"1. Win32 Disk Imager"},{"location":"blog/pi/backup-sdcard/#11-backup","text":"Select the Image File to save the SD Card content Select the source Device Click on Read Win32 Disk Imager: save device to image","title":"1.1. Backup"},{"location":"blog/pi/backup-sdcard/#12-restore","text":"Select the Image File of the SD Card content Select the target Device Click on Write Win32 Disk Imager: restore from image to device","title":"1.2. Restore"},{"location":"blog/pi/backup-sdcard/#2-acronis-true-image","text":"Acronis True Image is an application that provides data protection for personal users including, backup, archive, access and recovery for Windows, macOS, iOS, and Android operating systems. This application is a commercial product, try it for free before purchasing a copy.","title":"2. Acronis True Image"},{"location":"blog/pi/backup-sdcard/#21-backup-and-restore","text":"Acronis will not back up empty space on the SD Card, it only saves the useful data, therefore the backup progress is much faster than dumping all bits and the file size is smaller. It also has incremental backup mode which only writes modified data, compared to the previous backup, therefore it can save a lot of disk space. The restore process is as simple as the backup. There are buttons and guide to help to do those actions: Acronis True Image: backup/restore disk","title":"2.1. Backup and Restore"},{"location":"blog/pi/check-camera-i2c/","text":"Camera I2C Address responses Scan on the I2C Bus 0, the camera module will response on two addresses 0x10 (camera sensor) and 0x64 (camera board). Missing one of two above addresses means that there is an hardware issue happened. 1. Hardware check \u2693\ufe0e Run the command: vcgencmd get_camera Which should print out supported=1 detected=1 with a normal working camera. If the output shows detected=0 , check the ribbon cable first. If other camera module still works after swapping with the problem one, then do a hardware check from software interface as described below. 2. Software check \u2693\ufe0e An interesting topic: Camera not detected despite being plugged in on the official Raspberry forum shows a method to check the connection of the camera board and the camera sensor on an I2C interface. 2.1. Install I2C tools \u2693\ufe0e Install i2c-tools : sudo apt install -y i2c-tools This package contains a set of I2C tools for Linux: a bus probing tool, a chip dumper, register-level access helpers, EEPROM decoding scripts, and more. i2cdetect # detect I2C chips i2cdump # examine I2C registers i2cget # read from I2C/SMBus chip registers i2cset # set I2C registers i2ctransfer # send user-defined I2C messages in one transfer 2.2. Load I2C driver \u2693\ufe0e It is able to permanently enable the I2C interface by running sudo raspi-config and enable I2C setting, or by adding i2c-dev declaration in the file /etc/modules . Enable I2C Interface via raspi-config However, for a quick check, just need to load driver temporarily: sudo modprobe i2c-dev 2.3. Configure GPIO \u2693\ufe0e GPIO Pinout number Please look at PI GPIO document for more information about setting GPIOs. Note that GPIO number is defined in BCM2835 ARM processor, not the number printed on the Pi boards. Read more at BCM2835 Peripherals . Use raspi-gpio get to get the current status of GPIOs. Change GPIO0 and GPIO1 to input by default they are set to SDA0 and SCL0 raspi-gpio set 0 ip raspi-gpio set 1 ip Change the function of GPIO28 , GPIO29 to I2C pins out SDA0 and SCL0 by setting Alternate Function 0 (A0) on those pins. raspi-gpio set 28 a0 raspi-gpio set 29 a0 Power on Camera by setting High on output pin GPIO44 and GPIO45 raspi-gpio set 44 dh raspi-gpio set 40 dh 2.4. Scan I2C bus \u2693\ufe0e Run i2cdetect on I2C BUS 0 at /dev/i2c-0 : i2cdetect 0 press Y to continue, and it should print out some numbers, for example: 0 1 2 3 4 5 6 7 8 9 a b c d e f 00: -- -- -- -- -- -- -- -- -- -- -- -- -- 10: 10 -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- 20: -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- 30: -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- 40: -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- 50: -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- 60: -- -- -- -- 64 -- -- -- -- -- -- -- -- -- -- -- 70: -- -- -- -- -- -- -- -- Consider that i2cdetect tries to ping every address on a bus and reports whether an address responds. If any number shows up in report, it means there is a working device at that address. Camera\u2019s I2C addresses If having 0x64 , the camera board is connected properly, there is no problem with cable and main connectors on Pi board and camera board. If having 0x10 , it means the camera sensor has responded. there is no problem with sensor and sensor connection (a small cable between camera board and camera sensor).","title":"Diagnostic Camera"},{"location":"blog/pi/check-camera-i2c/#1-hardware-check","text":"Run the command: vcgencmd get_camera Which should print out supported=1 detected=1 with a normal working camera. If the output shows detected=0 , check the ribbon cable first. If other camera module still works after swapping with the problem one, then do a hardware check from software interface as described below.","title":"1. Hardware check"},{"location":"blog/pi/check-camera-i2c/#2-software-check","text":"An interesting topic: Camera not detected despite being plugged in on the official Raspberry forum shows a method to check the connection of the camera board and the camera sensor on an I2C interface.","title":"2. Software check"},{"location":"blog/pi/check-camera-i2c/#21-install-i2c-tools","text":"Install i2c-tools : sudo apt install -y i2c-tools This package contains a set of I2C tools for Linux: a bus probing tool, a chip dumper, register-level access helpers, EEPROM decoding scripts, and more. i2cdetect # detect I2C chips i2cdump # examine I2C registers i2cget # read from I2C/SMBus chip registers i2cset # set I2C registers i2ctransfer # send user-defined I2C messages in one transfer","title":"2.1. Install I2C tools"},{"location":"blog/pi/check-camera-i2c/#22-load-i2c-driver","text":"It is able to permanently enable the I2C interface by running sudo raspi-config and enable I2C setting, or by adding i2c-dev declaration in the file /etc/modules . Enable I2C Interface via raspi-config However, for a quick check, just need to load driver temporarily: sudo modprobe i2c-dev","title":"2.2. Load I2C driver"},{"location":"blog/pi/check-camera-i2c/#23-configure-gpio","text":"GPIO Pinout number Please look at PI GPIO document for more information about setting GPIOs. Note that GPIO number is defined in BCM2835 ARM processor, not the number printed on the Pi boards. Read more at BCM2835 Peripherals . Use raspi-gpio get to get the current status of GPIOs. Change GPIO0 and GPIO1 to input by default they are set to SDA0 and SCL0 raspi-gpio set 0 ip raspi-gpio set 1 ip Change the function of GPIO28 , GPIO29 to I2C pins out SDA0 and SCL0 by setting Alternate Function 0 (A0) on those pins. raspi-gpio set 28 a0 raspi-gpio set 29 a0 Power on Camera by setting High on output pin GPIO44 and GPIO45 raspi-gpio set 44 dh raspi-gpio set 40 dh","title":"2.3. Configure GPIO"},{"location":"blog/pi/check-camera-i2c/#24-scan-i2c-bus","text":"Run i2cdetect on I2C BUS 0 at /dev/i2c-0 : i2cdetect 0 press Y to continue, and it should print out some numbers, for example: 0 1 2 3 4 5 6 7 8 9 a b c d e f 00: -- -- -- -- -- -- -- -- -- -- -- -- -- 10: 10 -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- 20: -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- 30: -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- 40: -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- 50: -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- 60: -- -- -- -- 64 -- -- -- -- -- -- -- -- -- -- -- 70: -- -- -- -- -- -- -- -- Consider that i2cdetect tries to ping every address on a bus and reports whether an address responds. If any number shows up in report, it means there is a working device at that address. Camera\u2019s I2C addresses If having 0x64 , the camera board is connected properly, there is no problem with cable and main connectors on Pi board and camera board. If having 0x10 , it means the camera sensor has responded. there is no problem with sensor and sensor connection (a small cable between camera board and camera sensor).","title":"2.4. Scan I2C bus"},{"location":"blog/pi/compile-ffmpeg/","text":"Pre-built FFmpeg in Raspberry Pi OS The FFmpeg package in Raspberry Pi OS is built with H264 Hardware Acceleration already, just need to download it from the package manager: sudo apt install ffmpeg -y The below guide helps to compile FFmpeg from the latest source code to get new features or bug fixes. 1. Manual compilation \u2693\ufe0e Auto-build script There is a simpler method to compile FFmpeg with an auto-build script . This manual build section is to understand what are needed to be able to compile FFmpeg. It is recommended to use script. 1.1. Update the system \u2693\ufe0e Before starting to build, update system packages to the latest version may help to solve some issues which could happen due to the requirements from the latest source code of FFmpeg. sudo apt update && \\ sudo apt upgrade -y 1.2. Install build package \u2693\ufe0e To compile a source code, system needs to install build tools, including config parsers, compilers, dependent libraries. Here is the command to install necessary packages: sudo apt -y install autoconf automake build-essential cmake doxygen git graphviz imagemagick libasound2-dev libass-dev libavcodec-dev libavdevice-dev libavfilter-dev libavformat-dev libavutil-dev libfreetype6-dev libgmp-dev libmp3lame-dev libopencore-amrnb-dev libopencore-amrwb-dev libopus-dev librtmp-dev libsdl2-dev libsdl2-image-dev libsdl2-mixer-dev libsdl2-net-dev libsdl2-ttf-dev libsnappy-dev libsoxr-dev libssh-dev libssl-dev libtool libv4l-dev libva-dev libvdpau-dev libvo-amrwbenc-dev libvorbis-dev libwebp-dev libx264-dev libx265-dev libxcb-shape0-dev libxcb-shm0-dev libxcb-xfixes0-dev libxcb1-dev libxml2-dev lzma-dev meson nasm pkg-config python3-dev python3-pip texinfo wget yasm zlib1g-dev libdrm-dev 1.3. Compile additional libraries \u2693\ufe0e There are some additional libraries required by FFmpeg, which are not pre-built and distributed in OS package manager. Create a folder to get started: mkdir ~/ffmpeg-libraries AAC sound format (fdk-aac) git clone --depth 1 https://github.com/mstorsjo/fdk-aac.git ~/ffmpeg-libraries/fdk-aac \\ && cd ~/ffmpeg-libraries/fdk-aac \\ && autoreconf -fiv \\ && ./configure \\ && make -j $( nproc ) \\ && sudo make install AV1 video format (dav1d) git clone --depth 1 https://code.videolan.org/videolan/dav1d.git ~/ffmpeg-libraries/dav1d \\ && mkdir ~/ffmpeg-libraries/dav1d/build \\ && cd ~/ffmpeg-libraries/dav1d/build \\ && meson .. \\ && ninja \\ && sudo ninja install HEVC encoder (kvazaar) git clone --depth 1 https://github.com/ultravideo/kvazaar.git ~/ffmpeg-libraries/kvazaar \\ && cd ~/ffmpeg-libraries/kvazaar \\ && ./autogen.sh \\ && ./configure \\ && make -j $( nproc ) \\ && sudo make install VP8 and VP9 video codecs (LibVPX) git clone --depth 1 https://chromium.googlesource.com/webm/libvpx ~/ffmpeg-libraries/libvpx \\ && cd ~/ffmpeg-libraries/libvpx \\ && ./configure --disable-examples --disable-tools --disable-unit_tests --disable-docs \\ && make -j $( nproc ) \\ && sudo make install AP1 video codec (aom) git clone --depth 1 https://aomedia.googlesource.com/aom ~/ffmpeg-libraries/aom \\ && mkdir ~/ffmpeg-libraries/aom/aom_build \\ && cd ~/ffmpeg-libraries/aom/aom_build \\ && cmake -G \"Unix Makefiles\" AOM_SRC -DENABLE_NASM = on -DPYTHON_EXECUTABLE = \" $( which python3 ) \" -DCMAKE_C_FLAGS = \"-mfpu=vfp -mfloat-abi=hard\" .. \\ && sed -i 's/ENABLE_NEON:BOOL=ON/ENABLE_NEON:BOOL=OFF/' CMakeCache.txt \\ && make -j $( nproc ) \\ && sudo make install Image processing (zimg) git clone -b release-2.9.3 https://github.com/sekrit-twc/zimg.git ~/ffmpeg-libraries/zimg \\ && cd ~/ffmpeg-libraries/zimg \\ && sh autogen.sh \\ && ./configure \\ && make \\ && sudo make install 1.4. Link compiled libraries \u2693\ufe0e After installing new libraries, system needs to refresh link cache for new packages. This command ensures system won\u2019t run into linking issues because the compiler can\u2019t find a library. sudo ldconfig 1.5. Compile FFmpeg \u2693\ufe0e Finally, FFmpeg can be compiled with settings to include additional libraries, and the feature omx-rpi . The command is quite large as it has a lot of options: git clone --depth 1 https://github.com/FFmpeg/FFmpeg.git ~/FFmpeg \\ && cd ~/FFmpeg \\ && ./configure \\ --extra-cflags = \"-I/usr/local/include\" \\ --extra-ldflags = \"-L/usr/local/lib\" \\ --extra-libs = \"-lpthread -lm -latomic\" \\ --arch = armel \\ --enable-gmp \\ --enable-gpl \\ --enable-libaom \\ --enable-libass \\ --enable-libdav1d \\ --enable-libdrm \\ --enable-libfdk-aac \\ --enable-libfreetype \\ --enable-libkvazaar \\ --enable-libmp3lame \\ --enable-libopencore-amrnb \\ --enable-libopencore-amrwb \\ --enable-libopus \\ --enable-librtmp \\ --enable-libsnappy \\ --enable-libsoxr \\ --enable-libssh \\ --enable-libvorbis \\ --enable-libvpx \\ --enable-libzimg \\ --enable-libwebp \\ --enable-libx264 \\ --enable-libx265 \\ --enable-libxml2 \\ --enable-mmal \\ --enable-nonfree \\ --enable-omx \\ --enable-omx-rpi \\ --enable-version3 \\ --target-os = linux \\ --enable-pthreads \\ --enable-openssl \\ --enable-hardcoded-tables \\ && make -j $( nproc ) \\ && sudo make install The compilation time is quite long, usually 5 hours on Raspberry Pi Wi-Fi Zero, so be patient. Restart the system when the compilation ends, and check for the supported Hardware Acceleration codec: ffmpeg -hide_banner -encoders | grep -E \"h264|mjpeg\" V..... libx264 libx264 H.264 / AVC / MPEG-4 AVC / MPEG-4 part 10 (codec h264) V..... libx264rgb libx264 H.264 / AVC / MPEG-4 AVC / MPEG-4 part 10 RGB (codec h264) V..... h264_omx OpenMAX IL H.264 video encoder (codec h264) V..... h264_v4l2m2m V4L2 mem2mem H.264 encoder wrapper (codec h264) VFS... mjpeg MJPEG (Motion JPEG) 2. Auto-build script \u2693\ufe0e Thank cdgriffith for the below awesome pi_streaming_setup script. 2.1. The pi_streaming_setup script \u2693\ufe0e There are many guides published on the internet but pi_streaming_setup is a very easy script to follow. This script is designed to help automate turning a Raspberry Pi with a compatible camera into an MPEG-DASH / HLS streaming server . The steps it will attempt to do: Install FFmpeg (or compile it before install) with H264 hardware acceleration and free libraries Install NGINX for DASH / HLS or install RTSP server if desired (DASH/HLS) Update rc.local to run required setup script on reboot (DASH/HLS) Create index.html file to view video stream Create a systemd service and enable it to start streaming This script requires Python 3.6+ The usage of this script is simple and clear, but to compile FFmpeg, just need 2 options: --compile-ffmpeg --compile-only 2.2. Compile FFmpeg \u2693\ufe0e Install git if not installed: sudo apt-get install git Clone the pi_streaming_setup repo from GitHub: cd ~ git clone https://github.com/cdgriffith/pi_streaming_setup.git Go into the script\u2019s folder: cd pi_streaming_setup and finally, run the script with sudo and python3 as user pi : sudo python3 streaming_setup.py --compile-ffmpeg --compile-only --run-as pi This will take about 4~5 hours on an old and slow Raspberry Pi, such as a Pi Zero. 2.3. Test compiled FFmpeg \u2693\ufe0e After the compilation finishes, reboot the Pi, and when it\u2019s booted up, run below command to check the compiled tool: ffmpeg -hide_banner -encoders | grep -E \"h264|mjpeg\" and check the supported codecs: V..... libx264 libx264 H.264 / AVC / MPEG-4 AVC / MPEG-4 part 10 (codec h264) V..... libx264rgb libx264 H.264 / AVC / MPEG-4 AVC / MPEG-4 part 10 RGB (codec h264) V..... h264_omx OpenMAX IL H.264 video encoder (codec h264) V..... h264_v4l2m2m V4L2 mem2mem H.264 encoder wrapper (codec h264) VFS... mjpeg MJPEG (Motion JPEG)","title":"Compile FFmpeg"},{"location":"blog/pi/compile-ffmpeg/#1-manual-compilation","text":"Auto-build script There is a simpler method to compile FFmpeg with an auto-build script . This manual build section is to understand what are needed to be able to compile FFmpeg. It is recommended to use script.","title":"1. Manual compilation"},{"location":"blog/pi/compile-ffmpeg/#11-update-the-system","text":"Before starting to build, update system packages to the latest version may help to solve some issues which could happen due to the requirements from the latest source code of FFmpeg. sudo apt update && \\ sudo apt upgrade -y","title":"1.1. Update the system"},{"location":"blog/pi/compile-ffmpeg/#12-install-build-package","text":"To compile a source code, system needs to install build tools, including config parsers, compilers, dependent libraries. Here is the command to install necessary packages: sudo apt -y install autoconf automake build-essential cmake doxygen git graphviz imagemagick libasound2-dev libass-dev libavcodec-dev libavdevice-dev libavfilter-dev libavformat-dev libavutil-dev libfreetype6-dev libgmp-dev libmp3lame-dev libopencore-amrnb-dev libopencore-amrwb-dev libopus-dev librtmp-dev libsdl2-dev libsdl2-image-dev libsdl2-mixer-dev libsdl2-net-dev libsdl2-ttf-dev libsnappy-dev libsoxr-dev libssh-dev libssl-dev libtool libv4l-dev libva-dev libvdpau-dev libvo-amrwbenc-dev libvorbis-dev libwebp-dev libx264-dev libx265-dev libxcb-shape0-dev libxcb-shm0-dev libxcb-xfixes0-dev libxcb1-dev libxml2-dev lzma-dev meson nasm pkg-config python3-dev python3-pip texinfo wget yasm zlib1g-dev libdrm-dev","title":"1.2. Install build package"},{"location":"blog/pi/compile-ffmpeg/#13-compile-additional-libraries","text":"There are some additional libraries required by FFmpeg, which are not pre-built and distributed in OS package manager. Create a folder to get started: mkdir ~/ffmpeg-libraries AAC sound format (fdk-aac) git clone --depth 1 https://github.com/mstorsjo/fdk-aac.git ~/ffmpeg-libraries/fdk-aac \\ && cd ~/ffmpeg-libraries/fdk-aac \\ && autoreconf -fiv \\ && ./configure \\ && make -j $( nproc ) \\ && sudo make install AV1 video format (dav1d) git clone --depth 1 https://code.videolan.org/videolan/dav1d.git ~/ffmpeg-libraries/dav1d \\ && mkdir ~/ffmpeg-libraries/dav1d/build \\ && cd ~/ffmpeg-libraries/dav1d/build \\ && meson .. \\ && ninja \\ && sudo ninja install HEVC encoder (kvazaar) git clone --depth 1 https://github.com/ultravideo/kvazaar.git ~/ffmpeg-libraries/kvazaar \\ && cd ~/ffmpeg-libraries/kvazaar \\ && ./autogen.sh \\ && ./configure \\ && make -j $( nproc ) \\ && sudo make install VP8 and VP9 video codecs (LibVPX) git clone --depth 1 https://chromium.googlesource.com/webm/libvpx ~/ffmpeg-libraries/libvpx \\ && cd ~/ffmpeg-libraries/libvpx \\ && ./configure --disable-examples --disable-tools --disable-unit_tests --disable-docs \\ && make -j $( nproc ) \\ && sudo make install AP1 video codec (aom) git clone --depth 1 https://aomedia.googlesource.com/aom ~/ffmpeg-libraries/aom \\ && mkdir ~/ffmpeg-libraries/aom/aom_build \\ && cd ~/ffmpeg-libraries/aom/aom_build \\ && cmake -G \"Unix Makefiles\" AOM_SRC -DENABLE_NASM = on -DPYTHON_EXECUTABLE = \" $( which python3 ) \" -DCMAKE_C_FLAGS = \"-mfpu=vfp -mfloat-abi=hard\" .. \\ && sed -i 's/ENABLE_NEON:BOOL=ON/ENABLE_NEON:BOOL=OFF/' CMakeCache.txt \\ && make -j $( nproc ) \\ && sudo make install Image processing (zimg) git clone -b release-2.9.3 https://github.com/sekrit-twc/zimg.git ~/ffmpeg-libraries/zimg \\ && cd ~/ffmpeg-libraries/zimg \\ && sh autogen.sh \\ && ./configure \\ && make \\ && sudo make install","title":"1.3. Compile additional libraries"},{"location":"blog/pi/compile-ffmpeg/#14-link-compiled-libraries","text":"After installing new libraries, system needs to refresh link cache for new packages. This command ensures system won\u2019t run into linking issues because the compiler can\u2019t find a library. sudo ldconfig","title":"1.4. Link compiled libraries"},{"location":"blog/pi/compile-ffmpeg/#15-compile-ffmpeg","text":"Finally, FFmpeg can be compiled with settings to include additional libraries, and the feature omx-rpi . The command is quite large as it has a lot of options: git clone --depth 1 https://github.com/FFmpeg/FFmpeg.git ~/FFmpeg \\ && cd ~/FFmpeg \\ && ./configure \\ --extra-cflags = \"-I/usr/local/include\" \\ --extra-ldflags = \"-L/usr/local/lib\" \\ --extra-libs = \"-lpthread -lm -latomic\" \\ --arch = armel \\ --enable-gmp \\ --enable-gpl \\ --enable-libaom \\ --enable-libass \\ --enable-libdav1d \\ --enable-libdrm \\ --enable-libfdk-aac \\ --enable-libfreetype \\ --enable-libkvazaar \\ --enable-libmp3lame \\ --enable-libopencore-amrnb \\ --enable-libopencore-amrwb \\ --enable-libopus \\ --enable-librtmp \\ --enable-libsnappy \\ --enable-libsoxr \\ --enable-libssh \\ --enable-libvorbis \\ --enable-libvpx \\ --enable-libzimg \\ --enable-libwebp \\ --enable-libx264 \\ --enable-libx265 \\ --enable-libxml2 \\ --enable-mmal \\ --enable-nonfree \\ --enable-omx \\ --enable-omx-rpi \\ --enable-version3 \\ --target-os = linux \\ --enable-pthreads \\ --enable-openssl \\ --enable-hardcoded-tables \\ && make -j $( nproc ) \\ && sudo make install The compilation time is quite long, usually 5 hours on Raspberry Pi Wi-Fi Zero, so be patient. Restart the system when the compilation ends, and check for the supported Hardware Acceleration codec: ffmpeg -hide_banner -encoders | grep -E \"h264|mjpeg\" V..... libx264 libx264 H.264 / AVC / MPEG-4 AVC / MPEG-4 part 10 (codec h264) V..... libx264rgb libx264 H.264 / AVC / MPEG-4 AVC / MPEG-4 part 10 RGB (codec h264) V..... h264_omx OpenMAX IL H.264 video encoder (codec h264) V..... h264_v4l2m2m V4L2 mem2mem H.264 encoder wrapper (codec h264) VFS... mjpeg MJPEG (Motion JPEG)","title":"1.5. Compile FFmpeg"},{"location":"blog/pi/compile-ffmpeg/#2-auto-build-script","text":"Thank cdgriffith for the below awesome pi_streaming_setup script.","title":"2. Auto-build script"},{"location":"blog/pi/compile-ffmpeg/#21-the-pi_streaming_setup-script","text":"There are many guides published on the internet but pi_streaming_setup is a very easy script to follow. This script is designed to help automate turning a Raspberry Pi with a compatible camera into an MPEG-DASH / HLS streaming server . The steps it will attempt to do: Install FFmpeg (or compile it before install) with H264 hardware acceleration and free libraries Install NGINX for DASH / HLS or install RTSP server if desired (DASH/HLS) Update rc.local to run required setup script on reboot (DASH/HLS) Create index.html file to view video stream Create a systemd service and enable it to start streaming This script requires Python 3.6+ The usage of this script is simple and clear, but to compile FFmpeg, just need 2 options: --compile-ffmpeg --compile-only","title":"2.1. The pi_streaming_setup script"},{"location":"blog/pi/compile-ffmpeg/#22-compile-ffmpeg","text":"Install git if not installed: sudo apt-get install git Clone the pi_streaming_setup repo from GitHub: cd ~ git clone https://github.com/cdgriffith/pi_streaming_setup.git Go into the script\u2019s folder: cd pi_streaming_setup and finally, run the script with sudo and python3 as user pi : sudo python3 streaming_setup.py --compile-ffmpeg --compile-only --run-as pi This will take about 4~5 hours on an old and slow Raspberry Pi, such as a Pi Zero.","title":"2.2. Compile FFmpeg"},{"location":"blog/pi/compile-ffmpeg/#23-test-compiled-ffmpeg","text":"After the compilation finishes, reboot the Pi, and when it\u2019s booted up, run below command to check the compiled tool: ffmpeg -hide_banner -encoders | grep -E \"h264|mjpeg\" and check the supported codecs: V..... libx264 libx264 H.264 / AVC / MPEG-4 AVC / MPEG-4 part 10 (codec h264) V..... libx264rgb libx264 H.264 / AVC / MPEG-4 AVC / MPEG-4 part 10 RGB (codec h264) V..... h264_omx OpenMAX IL H.264 video encoder (codec h264) V..... h264_v4l2m2m V4L2 mem2mem H.264 encoder wrapper (codec h264) VFS... mjpeg MJPEG (Motion JPEG)","title":"2.3. Test compiled FFmpeg"},{"location":"blog/pi/headless-mode/","text":"1. Download Lite OS Image \u2693\ufe0e Official images for recommended operating systems are available to download from the Raspberry Pi website download page . Headless Mode is available in the Raspberry Pi OS Lite version, please download the OS zip file in preparation. The release notes of Lite OS is listed here . 2. Burn Image to an SD Card \u2693\ufe0e Raspberry Pi Imager is the official Image Writer from Raspberry Pi. The application balenaEtcher is a very good image writer that will write the OS image to an SD Card. Download and install it, then run it. Just follow the guided steps: Select image \u2014 browse to the zip file downloaded above Select drive \u2014 it may find the SD Card drive automatically Click Flash Etcher is writing the OS image After copying the image to the target SD Card, File Explorer may have trouble seeing the content of that SD Card. A simple fix is to pull the SD Card out then plug it back. It should appear with a partition named boot . 3. Enable SSH \u2693\ufe0e For security reasons, Secure Socket Shell ( ssh ) is no longer enabled by default. To enable it, place a blank text file called ssh no file extension in the root of the boot partition on the SD Card. 4. Add Wi-Fi Network \u2693\ufe0e To add a wireless network which Pi will automatically connect to, create a text file called wpa_supplicant.conf and place that file in the root of the boot partition on SD Card too. In below config file, the ssid field is the Wi-Fi Access Point name, and the psk field is the password of that Wi-Fi. wpa_supplicant.conf country = US ctrl_interface = DIR=/var/run/wpa_supplicant GROUP=netdev update_config = 1 network = { ssid = \"NETWORK-NAME\" psk = \"NETWORK-PASSWORD\" } See ISO 3166-1 country codes to fill into country field. If the target network is a hidden one, an extra option in the wpa_supplicant.conf file, scan_ssid=1 , may help connection. Adding multiple wireless network configurations is allowed, with some extra fields to set the name and the priority (higher number gets connected first): network = { ssid = \"HomeOneSSID\" psk = \"passwordOne\" priority = 1 id_str = \"homeOne\" } network = { ssid = \"HomeTwoSSID\" psk = \"passwordTwo\" priority = 2 id_str = \"homeTwo\" } Added ssh and wpa_supplicant.conf in the boot partition Direct USB connection (Pi Zero / Zero W Only) See the below section to skip setting a Wi-Fi network, as it will setup a virtual network over the USB connection. 5. Direct USB connection (Pi Zero / Zero W Only) \u2693\ufe0e On Pi Zero / Zero W only, it\u2019s able to turn on USB OTG mode and the Pi will act as a USB slave with different modes: Serial, Ethernet, Mass storage device, etc. The research was published here and here . This step will set up Pi in USB OTG Ethernet mode, so that when plugging Pi into computer by the Peripheral USB port labelled USB, not PWR , there is virtual network will be created and Pi can be accessed over that network, and no need of an external Wi-Fi network is required. This method also helps to power Pi over the USB port. Add dtoverlay=dwc2 on a new line in the config.txt file. Open up the cmdline.txt file. Insert modules-load=dwc2,g_ether after rootwait with only one space between the text rootwait and the new text!!! 6. Login to Pi \u2693\ufe0e Power Pi up and wait for the power led gets stable. Use any Network Scanner to detect the IP of the Pi. A plugin on MobaXterm can be used too. For the official Raspberry Pi OS, the default username is pi , with password raspberry , on the host raspberrypi . Bonjour is a service from Apple to discovery devices in a network using hostname. Install it and then Pi can be connected using its default hostname raspberrypi.local . Scan for Pi\u2019s IP Review Network Settings This command should list the network connection in the first line for wlan0 : iwconfig This command should show info for wlan0 : ifconfig This command should list the wlan0 network with details: iwlist wlan0 scan Connect to another Wi-Fi network Open the wpa-supplicant configuration file in nano editor: sudo nano /etc/wpa_supplicant/wpa_supplicant.conf Go to the bottom of the file and add the following: network={ ssid=\"NETWORK-NAME\" psk=\"NETWORK-PASSWORD\" } Reconfigure the interface with: wpa_cli -i wlan0 reconfigure Verify whether it has successfully connected using ifconfig wlan0 7. Update system (optional) \u2693\ufe0e To get the latest version of Pi OS and its packages, please update the system by entering below commands: sudo apt-get update && \\ sudo apt-get upgrade -y 8. Expand File system (optional) \u2693\ufe0e To use all of available space on the SD Card, expand the file system by running: sudo raspi-config Select Advanced Options \u2192 Expand File system Then reboot the system. 9. Serial Console \u2693\ufe0e By default, the primary UART is assigned to the Linux console, and the secondary UART is connected to Bluetooth Module (on model having Bluetooth feature \u2014 Pi Zero W, Pi 3, and Pi 4). Use raspi-config to disable the Linux serial console, then enable UART as a peripheral. 10. Others (optional) \u2693\ufe0e Please read the Notes \u2014 Save power post.","title":"Headless mode"},{"location":"blog/pi/headless-mode/#1-download-lite-os-image","text":"Official images for recommended operating systems are available to download from the Raspberry Pi website download page . Headless Mode is available in the Raspberry Pi OS Lite version, please download the OS zip file in preparation. The release notes of Lite OS is listed here .","title":"1. Download Lite OS Image"},{"location":"blog/pi/headless-mode/#2-burn-image-to-an-sd-card","text":"Raspberry Pi Imager is the official Image Writer from Raspberry Pi. The application balenaEtcher is a very good image writer that will write the OS image to an SD Card. Download and install it, then run it. Just follow the guided steps: Select image \u2014 browse to the zip file downloaded above Select drive \u2014 it may find the SD Card drive automatically Click Flash Etcher is writing the OS image After copying the image to the target SD Card, File Explorer may have trouble seeing the content of that SD Card. A simple fix is to pull the SD Card out then plug it back. It should appear with a partition named boot .","title":"2. Burn Image to an SD Card"},{"location":"blog/pi/headless-mode/#3-enable-ssh","text":"For security reasons, Secure Socket Shell ( ssh ) is no longer enabled by default. To enable it, place a blank text file called ssh no file extension in the root of the boot partition on the SD Card.","title":"3. Enable SSH"},{"location":"blog/pi/headless-mode/#4-add-wi-fi-network","text":"To add a wireless network which Pi will automatically connect to, create a text file called wpa_supplicant.conf and place that file in the root of the boot partition on SD Card too. In below config file, the ssid field is the Wi-Fi Access Point name, and the psk field is the password of that Wi-Fi. wpa_supplicant.conf country = US ctrl_interface = DIR=/var/run/wpa_supplicant GROUP=netdev update_config = 1 network = { ssid = \"NETWORK-NAME\" psk = \"NETWORK-PASSWORD\" } See ISO 3166-1 country codes to fill into country field. If the target network is a hidden one, an extra option in the wpa_supplicant.conf file, scan_ssid=1 , may help connection. Adding multiple wireless network configurations is allowed, with some extra fields to set the name and the priority (higher number gets connected first): network = { ssid = \"HomeOneSSID\" psk = \"passwordOne\" priority = 1 id_str = \"homeOne\" } network = { ssid = \"HomeTwoSSID\" psk = \"passwordTwo\" priority = 2 id_str = \"homeTwo\" } Added ssh and wpa_supplicant.conf in the boot partition Direct USB connection (Pi Zero / Zero W Only) See the below section to skip setting a Wi-Fi network, as it will setup a virtual network over the USB connection.","title":"4. Add Wi-Fi Network"},{"location":"blog/pi/headless-mode/#5-direct-usb-connection-pi-zero--zero-w-only","text":"On Pi Zero / Zero W only, it\u2019s able to turn on USB OTG mode and the Pi will act as a USB slave with different modes: Serial, Ethernet, Mass storage device, etc. The research was published here and here . This step will set up Pi in USB OTG Ethernet mode, so that when plugging Pi into computer by the Peripheral USB port labelled USB, not PWR , there is virtual network will be created and Pi can be accessed over that network, and no need of an external Wi-Fi network is required. This method also helps to power Pi over the USB port. Add dtoverlay=dwc2 on a new line in the config.txt file. Open up the cmdline.txt file. Insert modules-load=dwc2,g_ether after rootwait with only one space between the text rootwait and the new text!!!","title":"5. Direct USB connection (Pi Zero / Zero W Only)"},{"location":"blog/pi/headless-mode/#6-login-to-pi","text":"Power Pi up and wait for the power led gets stable. Use any Network Scanner to detect the IP of the Pi. A plugin on MobaXterm can be used too. For the official Raspberry Pi OS, the default username is pi , with password raspberry , on the host raspberrypi . Bonjour is a service from Apple to discovery devices in a network using hostname. Install it and then Pi can be connected using its default hostname raspberrypi.local . Scan for Pi\u2019s IP Review Network Settings This command should list the network connection in the first line for wlan0 : iwconfig This command should show info for wlan0 : ifconfig This command should list the wlan0 network with details: iwlist wlan0 scan Connect to another Wi-Fi network Open the wpa-supplicant configuration file in nano editor: sudo nano /etc/wpa_supplicant/wpa_supplicant.conf Go to the bottom of the file and add the following: network={ ssid=\"NETWORK-NAME\" psk=\"NETWORK-PASSWORD\" } Reconfigure the interface with: wpa_cli -i wlan0 reconfigure Verify whether it has successfully connected using ifconfig wlan0","title":"6. Login to Pi"},{"location":"blog/pi/headless-mode/#7-update-system-optional","text":"To get the latest version of Pi OS and its packages, please update the system by entering below commands: sudo apt-get update && \\ sudo apt-get upgrade -y","title":"7. Update system (optional)"},{"location":"blog/pi/headless-mode/#8-expand-file-system-optional","text":"To use all of available space on the SD Card, expand the file system by running: sudo raspi-config Select Advanced Options \u2192 Expand File system Then reboot the system.","title":"8. Expand File system (optional)"},{"location":"blog/pi/headless-mode/#9-serial-console","text":"By default, the primary UART is assigned to the Linux console, and the secondary UART is connected to Bluetooth Module (on model having Bluetooth feature \u2014 Pi Zero W, Pi 3, and Pi 4). Use raspi-config to disable the Linux serial console, then enable UART as a peripheral.","title":"9. Serial Console"},{"location":"blog/pi/headless-mode/#10-others-optional","text":"Please read the Notes \u2014 Save power post.","title":"10. Others (optional)"},{"location":"blog/pi/notes/","text":".md-typeset h2, .md-typeset h3 { font-size: 0; /* hide header but still scroll to its anchor */ } .md-typeset .content { margin-left: 3em; } Search 1 for a package distributed by Debian: Search 1. Setup Wireless \u2693\ufe0e Setup Wireless Refer to the official guide at Raspberry Pi Configuration . Note that there are two types of access points: Routed wireless access point : Create a new local network, which is not connected any other existing network +- RPi -------+ +---+ 10.10.0.2 | +- Laptop ----+ | | WLAN AP +-))) (((-+ WLAN Client | | | 192.168.4.1 | | 192.168.4.2 | | +-------------+ +-------------+ +- Router ----+ | | Firewall | | +- PC#2 ------+ (Internet)--WAN-+ DHCP server +-LAN-+---+ 10.10.0.3 | | 10.10.0.1 | | +-------------+ +-------------+ | | +- PC#1 ------+ +---+ 10.10.0.4 | +-------------+ Bridged wireless access point : Extend an existing Ethernet network to wireless computers and devices +- RPi -------+ +---+ 10.10.0.2 | +- Laptop ----+ | | WLAN AP +-))) (((-+ WLAN Client | | | Bridge | | 10.10.0.5 | | +-------------+ +-------------+ +- Router ----+ | | Firewall | | +- PC#2 ------+ (Internet)--WAN-+ DHCP server +-LAN-+---+ 10.10.0.3 | | 10.10.0.1 | | +-------------+ +-------------+ | | +- PC#1 ------+ +---+ 10.10.0.4 | +-------------+ 2. Python packages \u2693\ufe0e Python packages Most packages can be installed using sudo apt-get install followed by python-<packagename> for Python2 or python3-<packagename> . In some cases, a package is not available on the OS package manager, so install that packages via pip from python package manager. Install pip first: sudo apt install -y python-pip python3-pip Then install the target package. For example: sudo apt install -y python-ws4py python3-ws4py is equivalent to: pip install ws4py # python2 package and pip3 install ws4py # python3 package 3. Who is logged on? \u2693\ufe0e Who is logged on? Use w command from procps package. 08 :53:52 up 2 :21, 2 users, load average: 0 .02, 0 .06, 0 .07 USER TTY FROM LOGIN@ IDLE JCPU PCPU WHAT pi pts/0 fe80::1936:b4d4: 06 :34 0 .00s 1 .54s 0 .05s w 4. Save power \u2693\ufe0e Save power Save power when running on battery by turning off unused peripherals, or features. 4.1. Turn off USB \u2693\ufe0e Turn OFF the USB chip : echo '1-1' | sudo tee /sys/bus/usb/drivers/usb/unbind Turn ON the USB chip: echo '1-1' | sudo tee /sys/bus/usb/drivers/usb/bind 4.2. Turn off HDMI \u2693\ufe0e Turn OFF the HDMI output : sudo /opt/vc/bin/tvservice -o Turn ON the HDMI output: sudo /opt/vc/bin/tvservice -p 4.3. Throttle CPU \u2693\ufe0e Reduce the clock of the core by changing some parameters in the /boot/config.txt file: /boot/config.txt arm_freq_min = 250 core_freq_min = 100 sdram_freq_min = 150 over_voltage_min = 0 4.4. Disable Wi-Fi & Bluetooth \u2693\ufe0e Disable Wi-Fi & Bluetooth Starting from Raspberry Pi 3, WiFi and Bluetooth are added on hardware, so Raspbian has its method to control these signals in /boot/config.txt file: /boot/config.txt dtoverlay = pi3-disable-wifi dtoverlay = pi3-disable-bt It\u2019s correct to use the word pi3 in the params\u2019s value, for other version of Raspberry Pi. The rfkill command can be used to soft-block the wireless connections: rfkill list # displays the state of the modules rfkill block wifi rfkill block bluetooth but this does not completely turn off the hardware of the WiFi and the Bluetooth module. They will still draw a little power in the background. 4.5. Disable on-board LEDs \u2693\ufe0e Disable on-board LEDs Add below params to the /boot/config.txt file: /boot/config.txt dtparam = act_led_trigger=none dtparam = act_led_activelow=on Add a form in Markdown: < form role = \"search\" target = \"_blank\" action = \"https://packages.debian.org/search\" > < div > < input type = \"search\" id = \"mySearch\" name = \"keywords\" placeholder = \"Enter package name...\" aria-label = \"Search for a package name\" style = \"border:1px solid gray; padding: .25em .5em;\" /> < button type = \"submit\" class = \"md-button\" > Search </ button > </ div > </ form > \u21a9","title":"Notes"},{"location":"blog/pi/notes/#1-setup-wireless","text":"Setup Wireless Refer to the official guide at Raspberry Pi Configuration . Note that there are two types of access points: Routed wireless access point : Create a new local network, which is not connected any other existing network +- RPi -------+ +---+ 10.10.0.2 | +- Laptop ----+ | | WLAN AP +-))) (((-+ WLAN Client | | | 192.168.4.1 | | 192.168.4.2 | | +-------------+ +-------------+ +- Router ----+ | | Firewall | | +- PC#2 ------+ (Internet)--WAN-+ DHCP server +-LAN-+---+ 10.10.0.3 | | 10.10.0.1 | | +-------------+ +-------------+ | | +- PC#1 ------+ +---+ 10.10.0.4 | +-------------+ Bridged wireless access point : Extend an existing Ethernet network to wireless computers and devices +- RPi -------+ +---+ 10.10.0.2 | +- Laptop ----+ | | WLAN AP +-))) (((-+ WLAN Client | | | Bridge | | 10.10.0.5 | | +-------------+ +-------------+ +- Router ----+ | | Firewall | | +- PC#2 ------+ (Internet)--WAN-+ DHCP server +-LAN-+---+ 10.10.0.3 | | 10.10.0.1 | | +-------------+ +-------------+ | | +- PC#1 ------+ +---+ 10.10.0.4 | +-------------+","title":"1. Setup Wireless"},{"location":"blog/pi/notes/#2-python-packages","text":"Python packages Most packages can be installed using sudo apt-get install followed by python-<packagename> for Python2 or python3-<packagename> . In some cases, a package is not available on the OS package manager, so install that packages via pip from python package manager. Install pip first: sudo apt install -y python-pip python3-pip Then install the target package. For example: sudo apt install -y python-ws4py python3-ws4py is equivalent to: pip install ws4py # python2 package and pip3 install ws4py # python3 package","title":"2. Python packages"},{"location":"blog/pi/notes/#3-who-is-logged-on","text":"Who is logged on? Use w command from procps package. 08 :53:52 up 2 :21, 2 users, load average: 0 .02, 0 .06, 0 .07 USER TTY FROM LOGIN@ IDLE JCPU PCPU WHAT pi pts/0 fe80::1936:b4d4: 06 :34 0 .00s 1 .54s 0 .05s w","title":"3. Who is logged on?"},{"location":"blog/pi/notes/#4-save-power","text":"Save power Save power when running on battery by turning off unused peripherals, or features.","title":"4. Save power"},{"location":"blog/pi/notes/#41-turn-off-usb","text":"Turn OFF the USB chip : echo '1-1' | sudo tee /sys/bus/usb/drivers/usb/unbind Turn ON the USB chip: echo '1-1' | sudo tee /sys/bus/usb/drivers/usb/bind","title":"4.1. Turn off USB"},{"location":"blog/pi/notes/#42-turn-off-hdmi","text":"Turn OFF the HDMI output : sudo /opt/vc/bin/tvservice -o Turn ON the HDMI output: sudo /opt/vc/bin/tvservice -p","title":"4.2. Turn off HDMI"},{"location":"blog/pi/notes/#43-throttle-cpu","text":"Reduce the clock of the core by changing some parameters in the /boot/config.txt file: /boot/config.txt arm_freq_min = 250 core_freq_min = 100 sdram_freq_min = 150 over_voltage_min = 0","title":"4.3. Throttle CPU"},{"location":"blog/pi/notes/#44-disable-wi-fi--bluetooth","text":"Disable Wi-Fi & Bluetooth Starting from Raspberry Pi 3, WiFi and Bluetooth are added on hardware, so Raspbian has its method to control these signals in /boot/config.txt file: /boot/config.txt dtoverlay = pi3-disable-wifi dtoverlay = pi3-disable-bt It\u2019s correct to use the word pi3 in the params\u2019s value, for other version of Raspberry Pi. The rfkill command can be used to soft-block the wireless connections: rfkill list # displays the state of the modules rfkill block wifi rfkill block bluetooth but this does not completely turn off the hardware of the WiFi and the Bluetooth module. They will still draw a little power in the background.","title":"4.4. Disable Wi-Fi &amp; Bluetooth"},{"location":"blog/pi/notes/#45-disable-on-board-leds","text":"Disable on-board LEDs Add below params to the /boot/config.txt file: /boot/config.txt dtparam = act_led_trigger=none dtparam = act_led_activelow=on Add a form in Markdown: < form role = \"search\" target = \"_blank\" action = \"https://packages.debian.org/search\" > < div > < input type = \"search\" id = \"mySearch\" name = \"keywords\" placeholder = \"Enter package name...\" aria-label = \"Search for a package name\" style = \"border:1px solid gray; padding: .25em .5em;\" /> < button type = \"submit\" class = \"md-button\" > Search </ button > </ div > </ form > \u21a9","title":"4.5. Disable on-board LEDs"},{"location":"blog/pi/resource-usage/","text":"The final script Download monitor.sh then save to ~/monitor.sh . Add below line to ~/.bashrc : source monitor.sh Usage: monitor \"title\" program parameters This post is written as a walk through guide, step by step, to help to understand how the script was made. 1. Export a function in bash \u2693\ufe0e In a bash file, a function with a name and its body can be defined and then exported with export -f command: myfunc.sh #!/bin/bash myfunc () { echo \"parameters: $@ \" } export -f myfunc To make function available outside the script, run source command before calling the function: source myfunc.sh myfunc abc All parameters are implicit saved into local macros. Refer to Advanced Bash-Scripting Guide : Macro Description $BASHPID Process ID of the current instance of Bash. This is not the same as the $$ variable, but it often gives the same result. $PPID Process ID of the parent process $$ Process ID of the script itself $! Process ID of last job run in background $PWD The current directory that process is in at the time $SECONDS The number of seconds the script has been running $1 , $2 , $n The first, the second and the n-th parameter $# The number of command-line arguments $* All the positional parameters, seen as a single word, must be quoted $@ Same as $* , but each parameter is a quoted string, that is, the parameters are passed on intact, without interpretation or expansion. This means, among other things, that each parameter in the argument list is seen as a separate word $? Exit status of a command, function, or the script itself 2. Command-Grouping \u2693\ufe0e Refer to Bash Manual \u2014 Command Grouping . Bash provides two ways to group a list of commands to be executed as a unit. When commands are grouped, re-directions may be applied to the entire command list. ( list ) Placing a list of commands between parentheses causes a sub-shell environment to be created (see Command Execution Environment ), and each of the commands in list to be executed in that sub-shell. Since the list is executed in a sub-shell, variable assignments do not remain in effect after the sub-shell completes. { list; } Placing a list of commands between curly braces causes the list to be executed in the current shell context. No sub-shell is created. The semicolon (or newline) following list is required. In addition to the creation of a sub-shell, there is a subtle difference between these two constructs due to historical reasons: The braces are reserved words, so they must be separated from the list by blanks or other shell meta-characters The parentheses are operators, and are recognized as separate tokens by the shell even if they are not separated from the list by whitespace 3. Run a process \u2693\ufe0e The basic idea is to run a process in background and while it\u2019s running, report its resource usage: monitor.sh #!/bin/bash monitor () ( # run process in background echo \"Executing $* \" $* & # get PID of last job in background pid = $! echo \"Executed in PID: $pid \" ps --no-headers -p $pid echo 'CPU MEM' # check if a process is running while [ -e /proc/ $pid ] do # use ps to get cpu and memory usage ps --no-headers -o '%cpu,%mem' -p $pid sleep 1 done ) export -f monitor 4. ps or top \u2693\ufe0e Both ps and top report CPU Usage, but the returned values are different. Let\u2019s check the manual of each command: ps CPU usage is currently expressed as the percentage of time spent running during the entire lifetime of a process. This is not ideal, and it does not conform to the standards that ps otherwise conforms to. CPU usage is unlikely to add up to exactly 100%. It means ps does not show the instant CPU usage, it shows an average CPU usage over the lifetime of the process. top %CPU \u2013 CPU Usage, The task\u2019s share of the elapsed CPU time since the last screen update, expressed as a percentage of total CPU time. It means if interval is 1 second, top will report CPU usage for the last 1 second. That can be considered as instant report. Let\u2019s check top \u2018s options -b : Batch-mode operation Starts top in Batch mode, which could be useful for sending output from top to other programs or to a file. In this mode, top will not accept input and runs until the iterations limit set with the `-n\u2019 command-line option or until killed. -d : Delay-time interval as: -d ss.t (secs.tenths) Specifies the delay between screen updates, and overrides the corresponding value in one\u2019s personal configuration file or the startup default. Later this can be changed with the d or s interactive commands. -p : Monitor-PIDs mode as: -pN1 -pN2 ... or -pN1,N2,N3 ... Monitor only processes with specified process IDs. Switch to use top get the process information: monitor.sh #!/bin/bash monitor () ( # run process in background $* & # get PID of last job in background pid = $! # use top to monitor the process top -b -d 1 -p $pid & # save top PID to control it toppid = $! echo 'CPU MEM' # check if a process is running while [ -e /proc/ $pid ] do sleep 1 done # kill top sleep 1 kill -9 $toppid ) export -f monitor Run a test: monitor ffmpeg -y -hide_banner -i /dev/video0 -c:v h264_omx -t 10 test.mp4 and the result: PID USER PR NI VIRT RES SHR S %CPU % MEM TIME + COMMAND 2286 pi 20 0 336612 129848 121960 R 34.5 52.5 0 : 03.36 ffmpeg 5. grep and awk \u2693\ufe0e Refer to grep manual Use grep to extract process information lines using pid number as the keyword: top -b -d 1 -p $pid | grep $pid & Refer to awk manual Use awk to cut out 2 columns: %CPU and %MEM (at the 9 th and 10 th column) from the filtered lines: top -b -d 1 -p $pid | grep $pid | awk '{print $9, $10}' & So, this is a modified version: monitor.sh #!/bin/bash monitor () ( # run process in background $* & # get PID of last job in background pid = $! # use top to monitor the process # use grep to catch useful lines # use awk to extract data columns top -b -d 1 -p $pid | grep $pid | awk '{print $9, $10}' & # save top PID to control it toppid = $! echo 'CPU MEM' # check if a process is running while [ -e /proc/ $pid ] do sleep 1 done # kill top sleep 1 kill -9 $toppid ) export -f monitor Run a test command: monitor ffmpeg -y -hide_banner -i /dev/video0 -c:v h264_omx -t 10 test.mp4 and the result: CPU MEM Bug: No output value Surprisingly, there is no output for CPU and MEM usage reported in the output. Search on google, there is a glue of missing data when using grep in a pipeline. 6. Line buffered mode \u2693\ufe0e When using pipeline of commands, there is pipeline buffer between them. The output from grep is no longer line buffered, but block buffered, usually the block is 4 KB, leading to the problem that the next awk command cannot see new data immediately on its input. Notes from manuals: man grep --line-buffered Use line buffering on output. This can cause a performance penalty. man awk -W interactive Set non-buffered writes to stdout and line buffered reads from stdin. Records from stdin are lines regardless of the value of RS. Combining them together and testing again: monitor.sh #!/bin/bash monitor () ( # run process in background $* & # get PID of last job in background pid = $! # use top to monitor the process # use grep to catch useful lines, use line buffered mode # use awk to extract data column, read input in line buffered mode top -b -d 1 -p $pid | grep --line-buffered $pid | awk -W interactive '{print $9, $10}' & # save top PID to control it toppid = $! echo 'CPU MEM' # check if a process is running while [ -e /proc/ $pid ] do sleep 1 done # kill top sleep 1 kill -9 $toppid ) export -f monitor Run a test: monitor ffmpeg -y -hide_banner -i /dev/video0 -c:v h264_omx -t 10 test.mp4 and the result comes with expected values: CPU MEM 20.0 0.8 21.0 3.5 67.3 5.1 89.1 6.0 77.2 9.4 7. Save log with tee \u2693\ufe0e Use tee to read from the standard input and write to the standard output and a file. That is simple enough to clone the output to a log file: $* | tee log.txt & top -b -d 1 -p $pid | grep --line-buffered $pid | awk -W interactive '{print $9, $10}' | tee usage.txt & Then modify the script: monitor.sh #!/bin/bash monitor () ( # run process in background $* | tee log.txt & # get PID of last job in background pid = $! # use top to monitor the process # use grep to catch useful lines, use line buffered mode # use awk to extract data columns, read input in line buffered mode top -b -d 1 -p $pid | grep --line-buffered $pid | awk -W interactive '{print $9, $10}' | tee usage.txt & # save top PID to control it toppid = $! echo 'CPU MEM' # check if a process is running while [ -e /proc/ $pid ] do sleep 1 done # kill top sleep 1 kill -9 $toppid ) export -f monitor Run a test: monitor ffmpeg -y -hide_banner -i /dev/video0 -c:v h264_omx -t 10 test.mp4 Bug: Empty log and invalid output After using tee , there are twp issues happened: an empty log.txt file the usage.txt content is invalid 7.1. Fix empty log \u2693\ufe0e When making pipeline to tee , only the STDOUT (1) is forwarded, while ffmpeg prints output on the STDERR (2) not on the STDOUT (1). Fix it by redirect ffmpeg STDERR to STDOUT: $* 2 > & 1 | tee log.txt & 7.2. Fix wrong data \u2693\ufe0e Add some debug lines ps -p $pid to check the process ID after creating the processes: monitor.sh #!/bin/bash monitor () ( # run process in background $* | tee log.txt & # get PID of last job in background pid = $! ps -p $pid # use top to monitor the process # use grep to catch useful lines, use line buffered mode # use awk to extract data columns, read input in line buffered mode top -b -d 1 -p $pid | grep --line-buffered $pid | awk -W interactive '{print $9, $10}' | tee > usage.txt & # save top PID to control it toppid = $! ps -p $toppid echo 'CPU MEM' # check if a process is running while [ -e /proc/ $pid ] do sleep 1 done # kill top sleep 1 kill -9 $toppid ) export -f monitor Then, it prints out the PID of tee , not the PID of ffmpeg or top . PID TTY TIME CMD 647 pts/0 00:00:00 tee PID TTY TIME CMD 652 pts/0 00:00:00 tee Get PID of a process in pipeline In bash, pipeline cause commands to run in a sub-shell! For example, $* | tee > log.txt & will run $* in a sub-shell, and tee > log.txt will run in current shell, therefore tee\u2019s PID will be saved in the macro $! . The solution is to save the PID in the newly created sub-shell in which $! returns correct PID, then load that PID later: # save to pid.txt ( $* 2 > & 1 & echo $! > pid.txt ) | tee > log.txt & # load from pid.txt pid = $( <pid.txt ) Then modify the script: monitor.sh #!/bin/bash monitor () ( # run process in background ( $* 2 > & 1 & echo $! > pid.txt ) | tee log.txt & # get PID of last job in background pid = $( <pid.txt ) ps -p $pid # use top to monitor the process # use grep to catch useful lines, use line buffered mode # use awk to extract data columns, read input in line buffered mode ( top -b -d 1 -p $pid & echo $! > pid.txt ) | grep --line-buffered $pid | awk -W interactive '{print $9, $10}' | tee usage.txt & # save top PID to control it toppid = $( <pid.txt ) ps -p $toppid echo 'CPU MEM' # check if a process is running while [ -e /proc/ $pid ] do sleep 1 done # kill top sleep 1 kill -9 $toppid # clean up rm pid.txt ) export -f monitor Run a test: monitor ffmpeg -y -hide_banner -i /dev/video0 -c:v h264_omx -t 10 test.mp4 and got correct PIDs for ffmpeg and top : PID TTY TIME CMD 2352 pts/0 00:00:00 ffmpeg PID TTY TIME CMD 2360 pts/0 00:00:00 top 8. Graph with gnuplot \u2693\ufe0e Gnuplot is a portable command-line graph utility for Linux, OS/2, MS Windows, OSX, VMS, and many other platforms. It can produce many types of output, including terminal and file. Terminal output gnuplot -e \" \\ set term dumb; \\ plot \\ 'usage.txt' using 1 title '%CPU' with lines, \\ '' using 2 title 'MEM' with lines \\ \" PNG Image output gnuplot -e \" \\ set term png size 640, 480; \\ set output 'usage.png'; \\ set grid xtics lc rgb '#bbbbbb' lw 1 lt 1; \\ set grid ytics lc rgb '#bbbbbb' lw 1 lt 1; \\ plot \\ 'usage.txt' using 1 title '%CPU' with lines, \\ '' using 2 title 'MEM' with lines \\ \" Run a test: monitor \"test\" \"ffmpeg -y -hide_banner -i /dev/video0 -c:v h264_omx -t 10 test.mp4\" It prints out a good graph in the terminal as well as in a PNG image: .code-fit code { margin: auto !important; width: fit-content; } 100 +--------------------------------------------------------------------+ | *** + + + + + | 90 |-+ * % CPU *******-| | ** MEM ####### | 80 |-+ +-| | * | 70 |-+ * +-| | * | 60 |-+ * +-| | * | 50 |-+ * +-| | * | 40 |-+ * +-| | * | 30 |-+ ######################################################### | | # * | 20 |-+ ## * +-| | # ****** ************************* | 10 |-+ # ********* ******| | ###### + + + + + | 0 +--------------------------------------------------------------------+ 0 2 4 6 8 10 12 Resource Usage 9. Some enhancements \u2693\ufe0e Some small modifications to make script run in multiple sessions: 1. Set title for a new session Let\u2019s modify the script to accept parameters in this format: monitor \"title\" command by extracting those parameters at the beginning of the script: monitor () ( # extract parameters title = $1 command = ${ @: 2 } # get parameters from the 2nd one ... ) The title will be used to name the session, to create a folder to save log files. 2. Save output to a separated folder # create result folder if not existed [ ! -d $title ] && mkdir $title 3. Change output format to CPU= X MEM= Y It needs to change the data column index in gnuplot : # *-usage.txt content: # CPU= X MEM= Y # X is at 2nd column, # Y is at 4th column gnuplot -e \" \\ set term dumb; \\ plot \\ ' ${ title } / ${ title } -usage.txt' using 2 title '%CPU' with lines, \\ '' using 4 title 'MEM' with lines \\ \" 10. The final script \u2693\ufe0e Download the final script in the top of this page.","title":"Resource usage"},{"location":"blog/pi/resource-usage/#1-export-a-function-in-bash","text":"In a bash file, a function with a name and its body can be defined and then exported with export -f command: myfunc.sh #!/bin/bash myfunc () { echo \"parameters: $@ \" } export -f myfunc To make function available outside the script, run source command before calling the function: source myfunc.sh myfunc abc All parameters are implicit saved into local macros. Refer to Advanced Bash-Scripting Guide : Macro Description $BASHPID Process ID of the current instance of Bash. This is not the same as the $$ variable, but it often gives the same result. $PPID Process ID of the parent process $$ Process ID of the script itself $! Process ID of last job run in background $PWD The current directory that process is in at the time $SECONDS The number of seconds the script has been running $1 , $2 , $n The first, the second and the n-th parameter $# The number of command-line arguments $* All the positional parameters, seen as a single word, must be quoted $@ Same as $* , but each parameter is a quoted string, that is, the parameters are passed on intact, without interpretation or expansion. This means, among other things, that each parameter in the argument list is seen as a separate word $? Exit status of a command, function, or the script itself","title":"1. Export a function in bash"},{"location":"blog/pi/resource-usage/#2-command-grouping","text":"Refer to Bash Manual \u2014 Command Grouping . Bash provides two ways to group a list of commands to be executed as a unit. When commands are grouped, re-directions may be applied to the entire command list. ( list ) Placing a list of commands between parentheses causes a sub-shell environment to be created (see Command Execution Environment ), and each of the commands in list to be executed in that sub-shell. Since the list is executed in a sub-shell, variable assignments do not remain in effect after the sub-shell completes. { list; } Placing a list of commands between curly braces causes the list to be executed in the current shell context. No sub-shell is created. The semicolon (or newline) following list is required. In addition to the creation of a sub-shell, there is a subtle difference between these two constructs due to historical reasons: The braces are reserved words, so they must be separated from the list by blanks or other shell meta-characters The parentheses are operators, and are recognized as separate tokens by the shell even if they are not separated from the list by whitespace","title":"2. Command-Grouping"},{"location":"blog/pi/resource-usage/#3-run-a-process","text":"The basic idea is to run a process in background and while it\u2019s running, report its resource usage: monitor.sh #!/bin/bash monitor () ( # run process in background echo \"Executing $* \" $* & # get PID of last job in background pid = $! echo \"Executed in PID: $pid \" ps --no-headers -p $pid echo 'CPU MEM' # check if a process is running while [ -e /proc/ $pid ] do # use ps to get cpu and memory usage ps --no-headers -o '%cpu,%mem' -p $pid sleep 1 done ) export -f monitor","title":"3. Run a process"},{"location":"blog/pi/resource-usage/#4-ps-or-top","text":"Both ps and top report CPU Usage, but the returned values are different. Let\u2019s check the manual of each command: ps CPU usage is currently expressed as the percentage of time spent running during the entire lifetime of a process. This is not ideal, and it does not conform to the standards that ps otherwise conforms to. CPU usage is unlikely to add up to exactly 100%. It means ps does not show the instant CPU usage, it shows an average CPU usage over the lifetime of the process. top %CPU \u2013 CPU Usage, The task\u2019s share of the elapsed CPU time since the last screen update, expressed as a percentage of total CPU time. It means if interval is 1 second, top will report CPU usage for the last 1 second. That can be considered as instant report. Let\u2019s check top \u2018s options -b : Batch-mode operation Starts top in Batch mode, which could be useful for sending output from top to other programs or to a file. In this mode, top will not accept input and runs until the iterations limit set with the `-n\u2019 command-line option or until killed. -d : Delay-time interval as: -d ss.t (secs.tenths) Specifies the delay between screen updates, and overrides the corresponding value in one\u2019s personal configuration file or the startup default. Later this can be changed with the d or s interactive commands. -p : Monitor-PIDs mode as: -pN1 -pN2 ... or -pN1,N2,N3 ... Monitor only processes with specified process IDs. Switch to use top get the process information: monitor.sh #!/bin/bash monitor () ( # run process in background $* & # get PID of last job in background pid = $! # use top to monitor the process top -b -d 1 -p $pid & # save top PID to control it toppid = $! echo 'CPU MEM' # check if a process is running while [ -e /proc/ $pid ] do sleep 1 done # kill top sleep 1 kill -9 $toppid ) export -f monitor Run a test: monitor ffmpeg -y -hide_banner -i /dev/video0 -c:v h264_omx -t 10 test.mp4 and the result: PID USER PR NI VIRT RES SHR S %CPU % MEM TIME + COMMAND 2286 pi 20 0 336612 129848 121960 R 34.5 52.5 0 : 03.36 ffmpeg","title":"4. ps or top"},{"location":"blog/pi/resource-usage/#5-grep-and-awk","text":"Refer to grep manual Use grep to extract process information lines using pid number as the keyword: top -b -d 1 -p $pid | grep $pid & Refer to awk manual Use awk to cut out 2 columns: %CPU and %MEM (at the 9 th and 10 th column) from the filtered lines: top -b -d 1 -p $pid | grep $pid | awk '{print $9, $10}' & So, this is a modified version: monitor.sh #!/bin/bash monitor () ( # run process in background $* & # get PID of last job in background pid = $! # use top to monitor the process # use grep to catch useful lines # use awk to extract data columns top -b -d 1 -p $pid | grep $pid | awk '{print $9, $10}' & # save top PID to control it toppid = $! echo 'CPU MEM' # check if a process is running while [ -e /proc/ $pid ] do sleep 1 done # kill top sleep 1 kill -9 $toppid ) export -f monitor Run a test command: monitor ffmpeg -y -hide_banner -i /dev/video0 -c:v h264_omx -t 10 test.mp4 and the result: CPU MEM Bug: No output value Surprisingly, there is no output for CPU and MEM usage reported in the output. Search on google, there is a glue of missing data when using grep in a pipeline.","title":"5. grep and awk"},{"location":"blog/pi/resource-usage/#6-line-buffered-mode","text":"When using pipeline of commands, there is pipeline buffer between them. The output from grep is no longer line buffered, but block buffered, usually the block is 4 KB, leading to the problem that the next awk command cannot see new data immediately on its input. Notes from manuals: man grep --line-buffered Use line buffering on output. This can cause a performance penalty. man awk -W interactive Set non-buffered writes to stdout and line buffered reads from stdin. Records from stdin are lines regardless of the value of RS. Combining them together and testing again: monitor.sh #!/bin/bash monitor () ( # run process in background $* & # get PID of last job in background pid = $! # use top to monitor the process # use grep to catch useful lines, use line buffered mode # use awk to extract data column, read input in line buffered mode top -b -d 1 -p $pid | grep --line-buffered $pid | awk -W interactive '{print $9, $10}' & # save top PID to control it toppid = $! echo 'CPU MEM' # check if a process is running while [ -e /proc/ $pid ] do sleep 1 done # kill top sleep 1 kill -9 $toppid ) export -f monitor Run a test: monitor ffmpeg -y -hide_banner -i /dev/video0 -c:v h264_omx -t 10 test.mp4 and the result comes with expected values: CPU MEM 20.0 0.8 21.0 3.5 67.3 5.1 89.1 6.0 77.2 9.4","title":"6. Line buffered mode"},{"location":"blog/pi/resource-usage/#7-save-log-with-tee","text":"Use tee to read from the standard input and write to the standard output and a file. That is simple enough to clone the output to a log file: $* | tee log.txt & top -b -d 1 -p $pid | grep --line-buffered $pid | awk -W interactive '{print $9, $10}' | tee usage.txt & Then modify the script: monitor.sh #!/bin/bash monitor () ( # run process in background $* | tee log.txt & # get PID of last job in background pid = $! # use top to monitor the process # use grep to catch useful lines, use line buffered mode # use awk to extract data columns, read input in line buffered mode top -b -d 1 -p $pid | grep --line-buffered $pid | awk -W interactive '{print $9, $10}' | tee usage.txt & # save top PID to control it toppid = $! echo 'CPU MEM' # check if a process is running while [ -e /proc/ $pid ] do sleep 1 done # kill top sleep 1 kill -9 $toppid ) export -f monitor Run a test: monitor ffmpeg -y -hide_banner -i /dev/video0 -c:v h264_omx -t 10 test.mp4 Bug: Empty log and invalid output After using tee , there are twp issues happened: an empty log.txt file the usage.txt content is invalid","title":"7. Save log with tee"},{"location":"blog/pi/resource-usage/#71-fix-empty-log","text":"When making pipeline to tee , only the STDOUT (1) is forwarded, while ffmpeg prints output on the STDERR (2) not on the STDOUT (1). Fix it by redirect ffmpeg STDERR to STDOUT: $* 2 > & 1 | tee log.txt &","title":"7.1. Fix empty log"},{"location":"blog/pi/resource-usage/#72-fix-wrong-data","text":"Add some debug lines ps -p $pid to check the process ID after creating the processes: monitor.sh #!/bin/bash monitor () ( # run process in background $* | tee log.txt & # get PID of last job in background pid = $! ps -p $pid # use top to monitor the process # use grep to catch useful lines, use line buffered mode # use awk to extract data columns, read input in line buffered mode top -b -d 1 -p $pid | grep --line-buffered $pid | awk -W interactive '{print $9, $10}' | tee > usage.txt & # save top PID to control it toppid = $! ps -p $toppid echo 'CPU MEM' # check if a process is running while [ -e /proc/ $pid ] do sleep 1 done # kill top sleep 1 kill -9 $toppid ) export -f monitor Then, it prints out the PID of tee , not the PID of ffmpeg or top . PID TTY TIME CMD 647 pts/0 00:00:00 tee PID TTY TIME CMD 652 pts/0 00:00:00 tee Get PID of a process in pipeline In bash, pipeline cause commands to run in a sub-shell! For example, $* | tee > log.txt & will run $* in a sub-shell, and tee > log.txt will run in current shell, therefore tee\u2019s PID will be saved in the macro $! . The solution is to save the PID in the newly created sub-shell in which $! returns correct PID, then load that PID later: # save to pid.txt ( $* 2 > & 1 & echo $! > pid.txt ) | tee > log.txt & # load from pid.txt pid = $( <pid.txt ) Then modify the script: monitor.sh #!/bin/bash monitor () ( # run process in background ( $* 2 > & 1 & echo $! > pid.txt ) | tee log.txt & # get PID of last job in background pid = $( <pid.txt ) ps -p $pid # use top to monitor the process # use grep to catch useful lines, use line buffered mode # use awk to extract data columns, read input in line buffered mode ( top -b -d 1 -p $pid & echo $! > pid.txt ) | grep --line-buffered $pid | awk -W interactive '{print $9, $10}' | tee usage.txt & # save top PID to control it toppid = $( <pid.txt ) ps -p $toppid echo 'CPU MEM' # check if a process is running while [ -e /proc/ $pid ] do sleep 1 done # kill top sleep 1 kill -9 $toppid # clean up rm pid.txt ) export -f monitor Run a test: monitor ffmpeg -y -hide_banner -i /dev/video0 -c:v h264_omx -t 10 test.mp4 and got correct PIDs for ffmpeg and top : PID TTY TIME CMD 2352 pts/0 00:00:00 ffmpeg PID TTY TIME CMD 2360 pts/0 00:00:00 top","title":"7.2. Fix wrong data"},{"location":"blog/pi/resource-usage/#8-graph-with-gnuplot","text":"Gnuplot is a portable command-line graph utility for Linux, OS/2, MS Windows, OSX, VMS, and many other platforms. It can produce many types of output, including terminal and file. Terminal output gnuplot -e \" \\ set term dumb; \\ plot \\ 'usage.txt' using 1 title '%CPU' with lines, \\ '' using 2 title 'MEM' with lines \\ \" PNG Image output gnuplot -e \" \\ set term png size 640, 480; \\ set output 'usage.png'; \\ set grid xtics lc rgb '#bbbbbb' lw 1 lt 1; \\ set grid ytics lc rgb '#bbbbbb' lw 1 lt 1; \\ plot \\ 'usage.txt' using 1 title '%CPU' with lines, \\ '' using 2 title 'MEM' with lines \\ \" Run a test: monitor \"test\" \"ffmpeg -y -hide_banner -i /dev/video0 -c:v h264_omx -t 10 test.mp4\" It prints out a good graph in the terminal as well as in a PNG image: .code-fit code { margin: auto !important; width: fit-content; } 100 +--------------------------------------------------------------------+ | *** + + + + + | 90 |-+ * % CPU *******-| | ** MEM ####### | 80 |-+ +-| | * | 70 |-+ * +-| | * | 60 |-+ * +-| | * | 50 |-+ * +-| | * | 40 |-+ * +-| | * | 30 |-+ ######################################################### | | # * | 20 |-+ ## * +-| | # ****** ************************* | 10 |-+ # ********* ******| | ###### + + + + + | 0 +--------------------------------------------------------------------+ 0 2 4 6 8 10 12 Resource Usage","title":"8. Graph with gnuplot"},{"location":"blog/pi/resource-usage/#9-some-enhancements","text":"Some small modifications to make script run in multiple sessions: 1. Set title for a new session Let\u2019s modify the script to accept parameters in this format: monitor \"title\" command by extracting those parameters at the beginning of the script: monitor () ( # extract parameters title = $1 command = ${ @: 2 } # get parameters from the 2nd one ... ) The title will be used to name the session, to create a folder to save log files. 2. Save output to a separated folder # create result folder if not existed [ ! -d $title ] && mkdir $title 3. Change output format to CPU= X MEM= Y It needs to change the data column index in gnuplot : # *-usage.txt content: # CPU= X MEM= Y # X is at 2nd column, # Y is at 4th column gnuplot -e \" \\ set term dumb; \\ plot \\ ' ${ title } / ${ title } -usage.txt' using 2 title '%CPU' with lines, \\ '' using 4 title 'MEM' with lines \\ \"","title":"9. Some enhancements"},{"location":"blog/pi/resource-usage/#10-the-final-script","text":"Download the final script in the top of this page.","title":"10. The final script"},{"location":"blog/pi/setup-camera/","text":"Raspberry Pi Camera Module This tutorial is for setting up the official Raspberry Pi Camera module which is attached with a CSI cable. Other types of USB Camera should work on Pi out-of-the-box. 1. Enable Camera module \u2693\ufe0e Run raspi-config configuration tool: sudo raspi-config Then select Interfacing Options \u2192 Camera \u2192 Yes . This method will automatically set start_x=1 in /boot/config.txt file. raspi-config is a Raspberry Pi configuration command-line tool, to enable or disable some features in Pi OS. This tool requires root permission, therefore, it must be run with the super user right using sudo . User interface of raspi-config 2. Increase GPU memory \u2693\ufe0e Some video encoders need a big buffer to process video encoding or decoding. To increase the memory reserved for video processor, in the raspi-config configuration tool, go to Performance Options \u2192 GPU Memory then fill in 256 and select OK . This method does the same thing with setting up gpu_mem=256 in /boot/config.txt . 3. Test Camera \u2693\ufe0e Detect the camera connection by running the checking tool: vcgencmd get_camera Which should print out supported=1 detected=1 telling that the camera is supported and connected. vcgencmd is a command line utility that can get various pieces of information from the VideoCore GPU on the Raspberry Pi. Check more detail in Raspberry Pi/vcgencmd Raspicam commands has a set of tools to work with the camera module: raspistill , raspivid , and raspiyuv . Capture an image: raspistill -o cam.jpg Record a video: raspivid -o vid.h264 4. Video for Linux 2 \u2014 V4L2 \u2693\ufe0e Under Linux, the standard APIs for cameras (including webcams) is V4L (Video for Linux), and a number of applications have been written that support any camera with a V4L driver. An independent developer has now written a user space V4L driver for the Raspberry Pi camera, but it is closed sourced, and can be a little slow because it runs as a user program rather than a kernel driver. Recognizing that a V4L driver is needed, the Raspberry Pi Foundation reported that they were working with Broadcom to develop an official kernel V4L driver. As a kernel driver, it should be faster than the user space driver. Finally, V4L2 was released under the name bcm2835-v4l2 which is included Raspberry Pi OS by default. Use v4l2-ctl utility tool to capture from the camera. 4.1. List devices \u2693\ufe0e v4l2-ctl --list-devices bcm2835-codec-decode (platform:bcm2835-codec): /dev/video10 /dev/video11 /dev/video12 bcm2835-isp (platform:bcm2835-isp): /dev/video13 /dev/video14 /dev/video15 /dev/video16 mmal service 16.1 (platform:bcm2835-v4l2): /dev/video0 4.2. Driver info \u2693\ufe0e v4l2-ctl -d /dev/video0 --all Driver Info: Driver name : bm2835 mmal Card type : mmal service 16.1 Bus info : platform:bcm2835-v4l2 Driver version : 5.4.79 Capabilities : 0x85200005 Video Capture Video Overlay Read/Write Streaming ... 4.3. Supported formats \u2693\ufe0e v4l2-ctl --list-formats ioctl: VIDIOC_ENUM_FMT Type: Video Capture [0]: 'YU12' (Planar YUV 4:2:0) [1]: 'YUYV' (YUYV 4:2:2) [2]: 'RGB3' (24-bit RGB 8-8-8) [3]: 'JPEG' (JFIF JPEG, compressed) [4]: 'H264' (H.264, compressed) [5]: 'MJPG' (Motion-JPEG, compressed) [6]: 'YVYU' (YVYU 4:2:2) [7]: 'VYUY' (VYUY 4:2:2) [8]: 'UYVY' (UYVY 4:2:2) [9]: 'NV12' (Y/CbCr 4:2:0) [10]: 'BGR3' (24-bit BGR 8-8-8) [11]: 'YV12' (Planar YVU 4:2:0) [12]: 'NV21' (Y/CrCb 4:2:0) [13]: 'RX24' (32-bit XBGR 8-8-8-8) Please take a note for RGB3 , JPEG , H264 , and MJPEG , which can be used in OpenCV, or streaming directly. 4.4. Capture JPEG Image \u2693\ufe0e v4l2-ctl --set-fmt-video = width = 2592 ,height = 1944 ,pixelformat = 3 && \\ v4l2-ctl --stream-mmap = 3 --stream-count = 1 --stream-to = somefile.jpg 4.5. Record H264 Video \u2693\ufe0e Note the value height= 1088 , not 1080. v4l2-ctl --set-fmt-video = width = 1920 ,height = 1088 ,pixelformat = 4 && \\ v4l2-ctl --stream-mmap = 3 --stream-count = 100 --stream-to = somefile.264 5. FFmpeg \u2693\ufe0e The pre-built ffmpeg package of Pi already enables hardware accelerator support, with OpenMAX IL H.264 video encoder ( h264_omx ). sudo apt-get install ffmpeg -y An FFmpeg version with a specific library can be built by following this topic Compile FFmpeg with Hardware Accelerator . 5.1. Encoders \u2693\ufe0e To see all available encoders: ffmpeg -encoders If interested in h264 and mjpeg , use grep to search for the specific encoders: ffmpeg -hide_banner -encoders | grep -E \"h264|mjpeg\" V..... libx264 libx264 H.264 / AVC / MPEG-4 AVC / MPEG-4 part 10 (codec h264) V..... libx264rgb libx264 H.264 / AVC / MPEG-4 AVC / MPEG-4 part 10 RGB (codec h264) V..... h264_omx OpenMAX IL H.264 video encoder (codec h264) V..... h264_v4l2m2m V4L2 mem2mem H.264 encoder wrapper (codec h264) VFS... mjpeg MJPEG (Motion JPEG) Check encoder options Before using an encoder, check its options by help command in ffmpeg . ffmpeg -h encoder = <format> Here is the list of formats supported by OpenMAX IL H.264 video encoder (h264_omx): ffmpeg -h encoder = h264_omx Encoder h264_omx [OpenMAX IL H.264 video encoder]: General capabilities: delay Threading capabilities: none Supported pixel formats: yuv420p h264_omx AVOptions: -omx_libname <string> ED.V...... OpenMAX library name -omx_libprefix <string> ED.V...... OpenMAX library prefix -zerocopy <int> E..V...... Try to avoid copying input frames if possible (from 0 to 1) (default 1) -profile <int> E..V...... Set the encoding profile (from -99 to 100) (default -99) baseline 66 E..V...... main 77 E..V...... high 100 E..V...... 5.2. Performance \u2693\ufe0e Next, try to record some short video (60 seconds) with H264 format using different encoders. To measure the performance, use a small tool to check CPU and Memory Usage in monitor \u2014 Script to check performance . Note that ffmpeg will use v4l2 driver if user does not specify the driver!\u201d Video settings Video side: 1024x768 Frame rate: 30 fps Input Length: 60 seconds 5.2.1. Raw to MJPEG (.avi) \u2693\ufe0e ffmpeg -y -hide_banner \\ -use_wallclock_as_timestamps 1 \\ -t 60 \\ -i /dev/video0 \\ -c:v mjpeg \\ raw_mjpeg.avi Performance: Total time: 63 seconds Average %CPU: 93 (too high) Average %MEM: 31 Input FPS: 4.8 (dropped input) Output FPS: 30 Quality: Format: JPEG Codec ID: MJPG Bit rate: 839 kb/s Raw to MJPEG 5.2.2. Raw to H264_OMX @8Mbps (.mp4) \u2693\ufe0e ffmpeg -y -hide_banner \\ -use_wallclock_as_timestamps 1 \\ -t 60 \\ -i /dev/video0 \\ -c:v h264_omx \\ -b:v 8M \\ raw_h264omx.mp4 Performance: Total time: 63 seconds Average %CPU: 16 (OK) Average %MEM: 27 Input FPS: 30 Output FPS: 30 Quality: Format: AVC (GOP: M=1, N=12) Codec ID: avc1 Bit rate: 2 877 kb/s Raw to H264_OMX @8Mbps 5.2.3. Raw to H264_V4L2M2M @8Mbps (.mp4) \u2693\ufe0e ffmpeg -y -hide_banner \\ -use_wallclock_as_timestamps 1 \\ -t 60 \\ -i /dev/video0 \\ -c:v h264_v4l2m2m \\ -b:v 8M \\ raw_h264v4l2m2m.mp4 Performance: Total time: 62 seconds Average %CPU: 23 Average %MEM: 27 Input FPS: 30 Output FPS: 30 Quality: Format: AVC (GPO: M=1, N=60) Codec ID: avc1 Bit rate: 1 783 kb/s Raw to H264_V4L2M2M @8Mbps 5.2.4. V4L2 MJPEG direct copy (.avi) \u2693\ufe0e ffmpeg -y -hide_banner \\ -use_wallclock_as_timestamps 1 \\ -t 60 \\ -input_format mjpeg \\ -i /dev/video0 \\ -c:v copy \\ -t 60 \\ mjpeg_avi.avi Performance: Total time: 67 seconds Average %CPU: 10 (Good) Average %MEM: 21 Input FPS: 30 Output FPS: 30 Quality: Format: JPEG Codec ID: MJPG Bit rate: 10.2 Mb/s (very high bandwidth) Save V4L2 MJPEG stream 5.2.5. V4L2 H264 direct copy (.mp4) \u2693\ufe0e ffmpeg -y -hide_banner \\ -use_wallclock_as_timestamps 1 \\ -t 60 \\ -input_format h264 \\ -i /dev/video0 \\ -c:v copy \\ -t 60 \\ h264_mp4.mp4 Performance: Total time: 67 seconds Average %CPU: 10 (Good) Average %MEM: 24 Input FPS: 30 Output FPS: 30 Quality: Format: AVC (GPO: M=1, N=60) Codec ID: avc1 Bit rate: 5 506 kb/s (OK) Save V4L2 H264 stream 5.2.6. Conclusion \u2693\ufe0e After above tests, it can be said that using compressed input format from v4l2 is much more effective than compressing by a software encoder. Let\u2019s add some timestamp to video by using drawtext filter with built-in expandable localtime variable in Text-expansion option . ffmpeg -y -hide_banner \\ -use_wallclock_as_timestamps 1 \\ -t 10 \\ -i /dev/video0 \\ -vf \"drawtext=text='%{localtime}':fontcolor=white:x=100:y=100\" \\ -c:v h264_omx \\ -b:v 8M \\ raw_h264omx_text.mp4 Filter and stream-copy cannot be used together Text needs inserted and each frame needs re-encoded, therefore, stream-copy is unavailable. # this will not work ffmpeg -y -hide_banner \\ -use_wallclock_as_timestamps 1 \\ -t 10 \\ -input_format h264 \\ -i /dev/video0 \\ -vf \"drawtext=text='%{localtime}':fontcolor=white:x=100:y=100\" \\ -c:v copy \\ -t 10 \\ h264_mp4_text.mp4 6. Install picamera \u2693\ufe0e The PiCamera package is a pure Python interface to the Raspberry Pi camera module for Python language. If using the Raspbian distro, probably it has picamera installed by default. Run a test to check it is installed or not: python -c \"import picamera\" python3 -c \"import picamera\" If no module found, install picamera from the system\u2019s package manager: sudo apt-get install python-picamera python3-picamera There are a lot of examples in the official guide . Here are some starting points: Get maximum resolution of the camera import picamera with picamera . PiCamera () as cam : print ( cam . MAX_RESOLUTION ) Take a snapshot from time import sleep from picamera import PiCamera # setup a camera camera = PiCamera () camera . resolution = ( 1024 , 768 ) # camera warm-up time sleep ( 2 ) # capture an image camera . capture ( 'snapshot.jpg' ) Now, for the testing purpose, let\u2019s record a 60-second video from the camera and measure the resource usage with monitor , then use ffmpeg to convert raw h264 to mp4: 6.1. PiCamera H264 (.h264) \u2693\ufe0e Record a raw H264 video file from picamera import PiCamera # setup a camera camera = PiCamera () camera . resolution = ( 1024 , 768 ) camera . framerate = 30 # record a video camera . start_recording ( 'picamera.h264' ) camera . wait_recording ( 60 ) camera . stop_recording () Convert to MP4 video file ffmpeg -i picamera.h264 \\ -c:v copy picamera.mp4 Performance: Total time: 61 seconds Average CPU: 11 (Good) Average MEM: 5 (Good) Input FPS: 30 Output FPS: 25 Quality: Format: AVC (GPO: M=1, N=60) Codec ID: avc1 Bit rate: 3 302 kb/s (Good) PiCamera 6.2. Picamera H264 (.h264) with Text overlay \u2693\ufe0e Now, try to detect how picamera can draw text on output video. Here is the test code: from picamera import PiCamera import datetime TIMEFMT = '%Y-%m- %d %H:%M:%S. %f ' # setup a camera camera = PiCamera () camera . resolution = ( 1024 , 768 ) camera . annotate_text = datetime . datetime . now () . strftime ( TIMEFMT ) # record a video camera . start_recording ( 'picamera_text.h264' ) start = datetime . datetime . now () while ( datetime . datetime . now () - start ) . seconds < 60 : camera . annotate_text = datetime . datetime . now () . strftime ( TIMEFMT ) camera . wait_recording ( 0.04 ) # 25fps # stop it camera . stop_recording () Using picamera shows an impressive %CPU and %MEM usage, comparing to using FFmpeg. The result shows that the %CPU uses twice as much as it does in non-overlay text, while the %MEM keeps the same percentage.","title":"Setup Camera"},{"location":"blog/pi/setup-camera/#1-enable-camera-module","text":"Run raspi-config configuration tool: sudo raspi-config Then select Interfacing Options \u2192 Camera \u2192 Yes . This method will automatically set start_x=1 in /boot/config.txt file. raspi-config is a Raspberry Pi configuration command-line tool, to enable or disable some features in Pi OS. This tool requires root permission, therefore, it must be run with the super user right using sudo . User interface of raspi-config","title":"1. Enable Camera module"},{"location":"blog/pi/setup-camera/#2-increase-gpu-memory","text":"Some video encoders need a big buffer to process video encoding or decoding. To increase the memory reserved for video processor, in the raspi-config configuration tool, go to Performance Options \u2192 GPU Memory then fill in 256 and select OK . This method does the same thing with setting up gpu_mem=256 in /boot/config.txt .","title":"2. Increase GPU memory"},{"location":"blog/pi/setup-camera/#3-test-camera","text":"Detect the camera connection by running the checking tool: vcgencmd get_camera Which should print out supported=1 detected=1 telling that the camera is supported and connected. vcgencmd is a command line utility that can get various pieces of information from the VideoCore GPU on the Raspberry Pi. Check more detail in Raspberry Pi/vcgencmd Raspicam commands has a set of tools to work with the camera module: raspistill , raspivid , and raspiyuv . Capture an image: raspistill -o cam.jpg Record a video: raspivid -o vid.h264","title":"3. Test Camera"},{"location":"blog/pi/setup-camera/#4-video-for-linux-2--v4l2","text":"Under Linux, the standard APIs for cameras (including webcams) is V4L (Video for Linux), and a number of applications have been written that support any camera with a V4L driver. An independent developer has now written a user space V4L driver for the Raspberry Pi camera, but it is closed sourced, and can be a little slow because it runs as a user program rather than a kernel driver. Recognizing that a V4L driver is needed, the Raspberry Pi Foundation reported that they were working with Broadcom to develop an official kernel V4L driver. As a kernel driver, it should be faster than the user space driver. Finally, V4L2 was released under the name bcm2835-v4l2 which is included Raspberry Pi OS by default. Use v4l2-ctl utility tool to capture from the camera.","title":"4. Video for Linux 2 \u2014 V4L2"},{"location":"blog/pi/setup-camera/#41-list-devices","text":"v4l2-ctl --list-devices bcm2835-codec-decode (platform:bcm2835-codec): /dev/video10 /dev/video11 /dev/video12 bcm2835-isp (platform:bcm2835-isp): /dev/video13 /dev/video14 /dev/video15 /dev/video16 mmal service 16.1 (platform:bcm2835-v4l2): /dev/video0","title":"4.1. List devices"},{"location":"blog/pi/setup-camera/#42-driver-info","text":"v4l2-ctl -d /dev/video0 --all Driver Info: Driver name : bm2835 mmal Card type : mmal service 16.1 Bus info : platform:bcm2835-v4l2 Driver version : 5.4.79 Capabilities : 0x85200005 Video Capture Video Overlay Read/Write Streaming ...","title":"4.2. Driver info"},{"location":"blog/pi/setup-camera/#43-supported-formats","text":"v4l2-ctl --list-formats ioctl: VIDIOC_ENUM_FMT Type: Video Capture [0]: 'YU12' (Planar YUV 4:2:0) [1]: 'YUYV' (YUYV 4:2:2) [2]: 'RGB3' (24-bit RGB 8-8-8) [3]: 'JPEG' (JFIF JPEG, compressed) [4]: 'H264' (H.264, compressed) [5]: 'MJPG' (Motion-JPEG, compressed) [6]: 'YVYU' (YVYU 4:2:2) [7]: 'VYUY' (VYUY 4:2:2) [8]: 'UYVY' (UYVY 4:2:2) [9]: 'NV12' (Y/CbCr 4:2:0) [10]: 'BGR3' (24-bit BGR 8-8-8) [11]: 'YV12' (Planar YVU 4:2:0) [12]: 'NV21' (Y/CrCb 4:2:0) [13]: 'RX24' (32-bit XBGR 8-8-8-8) Please take a note for RGB3 , JPEG , H264 , and MJPEG , which can be used in OpenCV, or streaming directly.","title":"4.3. Supported formats"},{"location":"blog/pi/setup-camera/#44-capture-jpeg-image","text":"v4l2-ctl --set-fmt-video = width = 2592 ,height = 1944 ,pixelformat = 3 && \\ v4l2-ctl --stream-mmap = 3 --stream-count = 1 --stream-to = somefile.jpg","title":"4.4. Capture JPEG Image"},{"location":"blog/pi/setup-camera/#45-record-h264-video","text":"Note the value height= 1088 , not 1080. v4l2-ctl --set-fmt-video = width = 1920 ,height = 1088 ,pixelformat = 4 && \\ v4l2-ctl --stream-mmap = 3 --stream-count = 100 --stream-to = somefile.264","title":"4.5. Record H264 Video"},{"location":"blog/pi/setup-camera/#5-ffmpeg","text":"The pre-built ffmpeg package of Pi already enables hardware accelerator support, with OpenMAX IL H.264 video encoder ( h264_omx ). sudo apt-get install ffmpeg -y An FFmpeg version with a specific library can be built by following this topic Compile FFmpeg with Hardware Accelerator .","title":"5. FFmpeg"},{"location":"blog/pi/setup-camera/#51-encoders","text":"To see all available encoders: ffmpeg -encoders If interested in h264 and mjpeg , use grep to search for the specific encoders: ffmpeg -hide_banner -encoders | grep -E \"h264|mjpeg\" V..... libx264 libx264 H.264 / AVC / MPEG-4 AVC / MPEG-4 part 10 (codec h264) V..... libx264rgb libx264 H.264 / AVC / MPEG-4 AVC / MPEG-4 part 10 RGB (codec h264) V..... h264_omx OpenMAX IL H.264 video encoder (codec h264) V..... h264_v4l2m2m V4L2 mem2mem H.264 encoder wrapper (codec h264) VFS... mjpeg MJPEG (Motion JPEG) Check encoder options Before using an encoder, check its options by help command in ffmpeg . ffmpeg -h encoder = <format> Here is the list of formats supported by OpenMAX IL H.264 video encoder (h264_omx): ffmpeg -h encoder = h264_omx Encoder h264_omx [OpenMAX IL H.264 video encoder]: General capabilities: delay Threading capabilities: none Supported pixel formats: yuv420p h264_omx AVOptions: -omx_libname <string> ED.V...... OpenMAX library name -omx_libprefix <string> ED.V...... OpenMAX library prefix -zerocopy <int> E..V...... Try to avoid copying input frames if possible (from 0 to 1) (default 1) -profile <int> E..V...... Set the encoding profile (from -99 to 100) (default -99) baseline 66 E..V...... main 77 E..V...... high 100 E..V......","title":"5.1. Encoders"},{"location":"blog/pi/setup-camera/#52-performance","text":"Next, try to record some short video (60 seconds) with H264 format using different encoders. To measure the performance, use a small tool to check CPU and Memory Usage in monitor \u2014 Script to check performance . Note that ffmpeg will use v4l2 driver if user does not specify the driver!\u201d Video settings Video side: 1024x768 Frame rate: 30 fps Input Length: 60 seconds","title":"5.2. Performance"},{"location":"blog/pi/setup-camera/#521-raw-to-mjpeg-avi","text":"ffmpeg -y -hide_banner \\ -use_wallclock_as_timestamps 1 \\ -t 60 \\ -i /dev/video0 \\ -c:v mjpeg \\ raw_mjpeg.avi Performance: Total time: 63 seconds Average %CPU: 93 (too high) Average %MEM: 31 Input FPS: 4.8 (dropped input) Output FPS: 30 Quality: Format: JPEG Codec ID: MJPG Bit rate: 839 kb/s Raw to MJPEG","title":"5.2.1. Raw to MJPEG (.avi)"},{"location":"blog/pi/setup-camera/#522-raw-to-h264_omx-8mbps-mp4","text":"ffmpeg -y -hide_banner \\ -use_wallclock_as_timestamps 1 \\ -t 60 \\ -i /dev/video0 \\ -c:v h264_omx \\ -b:v 8M \\ raw_h264omx.mp4 Performance: Total time: 63 seconds Average %CPU: 16 (OK) Average %MEM: 27 Input FPS: 30 Output FPS: 30 Quality: Format: AVC (GOP: M=1, N=12) Codec ID: avc1 Bit rate: 2 877 kb/s Raw to H264_OMX @8Mbps","title":"5.2.2. Raw to H264_OMX @8Mbps (.mp4)"},{"location":"blog/pi/setup-camera/#523-raw-to-h264_v4l2m2m-8mbps-mp4","text":"ffmpeg -y -hide_banner \\ -use_wallclock_as_timestamps 1 \\ -t 60 \\ -i /dev/video0 \\ -c:v h264_v4l2m2m \\ -b:v 8M \\ raw_h264v4l2m2m.mp4 Performance: Total time: 62 seconds Average %CPU: 23 Average %MEM: 27 Input FPS: 30 Output FPS: 30 Quality: Format: AVC (GPO: M=1, N=60) Codec ID: avc1 Bit rate: 1 783 kb/s Raw to H264_V4L2M2M @8Mbps","title":"5.2.3. Raw to H264_V4L2M2M @8Mbps (.mp4)"},{"location":"blog/pi/setup-camera/#524-v4l2-mjpeg-direct-copy-avi","text":"ffmpeg -y -hide_banner \\ -use_wallclock_as_timestamps 1 \\ -t 60 \\ -input_format mjpeg \\ -i /dev/video0 \\ -c:v copy \\ -t 60 \\ mjpeg_avi.avi Performance: Total time: 67 seconds Average %CPU: 10 (Good) Average %MEM: 21 Input FPS: 30 Output FPS: 30 Quality: Format: JPEG Codec ID: MJPG Bit rate: 10.2 Mb/s (very high bandwidth) Save V4L2 MJPEG stream","title":"5.2.4. V4L2 MJPEG direct copy (.avi)"},{"location":"blog/pi/setup-camera/#525-v4l2-h264-direct-copy-mp4","text":"ffmpeg -y -hide_banner \\ -use_wallclock_as_timestamps 1 \\ -t 60 \\ -input_format h264 \\ -i /dev/video0 \\ -c:v copy \\ -t 60 \\ h264_mp4.mp4 Performance: Total time: 67 seconds Average %CPU: 10 (Good) Average %MEM: 24 Input FPS: 30 Output FPS: 30 Quality: Format: AVC (GPO: M=1, N=60) Codec ID: avc1 Bit rate: 5 506 kb/s (OK) Save V4L2 H264 stream","title":"5.2.5. V4L2 H264 direct copy (.mp4)"},{"location":"blog/pi/setup-camera/#526-conclusion","text":"After above tests, it can be said that using compressed input format from v4l2 is much more effective than compressing by a software encoder. Let\u2019s add some timestamp to video by using drawtext filter with built-in expandable localtime variable in Text-expansion option . ffmpeg -y -hide_banner \\ -use_wallclock_as_timestamps 1 \\ -t 10 \\ -i /dev/video0 \\ -vf \"drawtext=text='%{localtime}':fontcolor=white:x=100:y=100\" \\ -c:v h264_omx \\ -b:v 8M \\ raw_h264omx_text.mp4 Filter and stream-copy cannot be used together Text needs inserted and each frame needs re-encoded, therefore, stream-copy is unavailable. # this will not work ffmpeg -y -hide_banner \\ -use_wallclock_as_timestamps 1 \\ -t 10 \\ -input_format h264 \\ -i /dev/video0 \\ -vf \"drawtext=text='%{localtime}':fontcolor=white:x=100:y=100\" \\ -c:v copy \\ -t 10 \\ h264_mp4_text.mp4","title":"5.2.6. Conclusion"},{"location":"blog/pi/setup-camera/#6-install-picamera","text":"The PiCamera package is a pure Python interface to the Raspberry Pi camera module for Python language. If using the Raspbian distro, probably it has picamera installed by default. Run a test to check it is installed or not: python -c \"import picamera\" python3 -c \"import picamera\" If no module found, install picamera from the system\u2019s package manager: sudo apt-get install python-picamera python3-picamera There are a lot of examples in the official guide . Here are some starting points: Get maximum resolution of the camera import picamera with picamera . PiCamera () as cam : print ( cam . MAX_RESOLUTION ) Take a snapshot from time import sleep from picamera import PiCamera # setup a camera camera = PiCamera () camera . resolution = ( 1024 , 768 ) # camera warm-up time sleep ( 2 ) # capture an image camera . capture ( 'snapshot.jpg' ) Now, for the testing purpose, let\u2019s record a 60-second video from the camera and measure the resource usage with monitor , then use ffmpeg to convert raw h264 to mp4:","title":"6. Install picamera"},{"location":"blog/pi/setup-camera/#61-picamera-h264-h264","text":"Record a raw H264 video file from picamera import PiCamera # setup a camera camera = PiCamera () camera . resolution = ( 1024 , 768 ) camera . framerate = 30 # record a video camera . start_recording ( 'picamera.h264' ) camera . wait_recording ( 60 ) camera . stop_recording () Convert to MP4 video file ffmpeg -i picamera.h264 \\ -c:v copy picamera.mp4 Performance: Total time: 61 seconds Average CPU: 11 (Good) Average MEM: 5 (Good) Input FPS: 30 Output FPS: 25 Quality: Format: AVC (GPO: M=1, N=60) Codec ID: avc1 Bit rate: 3 302 kb/s (Good) PiCamera","title":"6.1. PiCamera H264 (.h264)"},{"location":"blog/pi/setup-camera/#62-picamera-h264-h264-with-text-overlay","text":"Now, try to detect how picamera can draw text on output video. Here is the test code: from picamera import PiCamera import datetime TIMEFMT = '%Y-%m- %d %H:%M:%S. %f ' # setup a camera camera = PiCamera () camera . resolution = ( 1024 , 768 ) camera . annotate_text = datetime . datetime . now () . strftime ( TIMEFMT ) # record a video camera . start_recording ( 'picamera_text.h264' ) start = datetime . datetime . now () while ( datetime . datetime . now () - start ) . seconds < 60 : camera . annotate_text = datetime . datetime . now () . strftime ( TIMEFMT ) camera . wait_recording ( 0.04 ) # 25fps # stop it camera . stop_recording () Using picamera shows an impressive %CPU and %MEM usage, comparing to using FFmpeg. The result shows that the %CPU uses twice as much as it does in non-overlay text, while the %MEM keeps the same percentage.","title":"6.2. Picamera H264 (.h264) with Text overlay"},{"location":"blog/pi/stream-ffmpeg-hls-dash/","text":"stream_ffmpeg_hls Delay when streaming in HLS protocol Big Buck Bunny movie , \u00a9 2008, Blender Foundation 1. Install FFmpeg \u2693\ufe0e Install FFmpeg from the package manager: sudo apt-get install ffmpeg -y Or compile an executable file by following Compile FFmpeg manually guide. 2. HLS vs. MPEG-DASH \u2693\ufe0e A streaming protocol is a type of technology that is designed to transport video files over the internet. In the past, online video was delivered primarily via the RTMP protocol. RTMP is a Flash-based standard that\u2019s still used today for sending video from an encoder to an online video platform. The RTMP has slowly been replaced by the HLS and MPEG-DASH protocol. 2.1. HLS \u2693\ufe0e HLS is short for HTTP Live Streaming . Originally developed by Apple, the purpose of HLS was to make the iPhone capable of accessing live streams. HLS can play video encoded with the H.264 or HEVC/H.265 codecs. As the name implies, HLS delivers content via standard HTTP web servers. This means that no special infrastructure is needed to deliver HLS content. Any standard web server or CDN will work. Additionally, content is less likely to be blocked by firewalls with this protocol, which is a plus. How it works is video is chopped up into 10-second segments. Latency for delivery tends to be in the 45-second range. With some settings applied, the delay can be reduced to 3-5 seconds. This protocol also includes several other built-in features. For example, HLS is an adaptive bit rate protocol. This means that the client device and server dynamically detect the internet speed of the user and adjusts video quality accordingly. 2.2. MPEG-DASH \u2693\ufe0e As a newer standard, MPEG-DASH is an up-and-coming competitor to HLS. This protocol was created as a response to fragmentation in the video streaming market. At the time, Apple\u2019s HLS was competing with several other streaming protocols. The outcome was uncertain, which led standards organizations to develop MPEG-DASH as an alternative, unifying streaming protocol. MPEG-DASH is an open-source standard. Like the HLS streaming protocol, MPEG-DASH is an adaptive bit rate video method. It also supports advertising, and the technology for this is rapidly advancing. However, MPEG-DASH is not supported on the mobile Safari browser. HLS is simply much more widely compatible than MPEG-DASH. 3. Setup web server \u2693\ufe0e Because HLS and MPEG-DASH are HTTP-based protocols, there is no need to install a special web server, what is needed is just a simple web server which can serve video chunk files. 3.1. Apache \u2693\ufe0e Apache is a popular web server application which can be installed on the Raspberry Pi to allow it to serve web pages. On its own, Apache can serve HTML files over HTTP, and with additional modules can serve dynamic web pages using scripting languages such as PHP. Apache\u2019s design architecture: Process Driven Approach Creates a new thread for each request. sudo apt-get install apache2 -y By default, Apache puts a test HTML file in the web folder /var/www/html/ . This default web page is served when a browse to http://localhost on the Pi itself or http://pi's_ip from other device\u2019s browsers. 3.2. NGINX \u2693\ufe0e NGINX (pronounced engine x ) is a popular lightweight web server application which can be installed on the Raspberry Pi to allow it to serve web pages. Like Apache, NGINX can serve HTML files over HTTP, and with additional modules can serve dynamic web pages using scripting languages such as PHP. NGINX\u2019s design architecture: Event-Driven approach Handles multiple requests within one thread Nginx can work very fast and wide with limited resources. sudo apt-get install nginx -y Similar to Apache, NGINX also serves web pages in /var/www/html/ . Go to http://localhost/etc/nginx/sites-available to see the site\u2019s links. As the article Apache Vs NGINX \u2014 Which Is The Best Web Server? mentioned, it should go with NGINX if serving static web page with a high traffic (requests). 4. Stream live video \u2693\ufe0e MPEG-DASH and HLS both create playlist files whose content are list of video chunks. ffmpeg can read from camera and write video chunks as well as update the playlist. To speed up and to protect SD Card, it is better to write video chunks to RAM memory. When the number of chunks go high, clear the old ones to get more space . Let\u2019s do it with HLS first! 4.1. Create video chunks \u2693\ufe0e Create a new folder in shared memory: mkdir -p /dev/shm/hls and make a soft-link to the web folder: ln -s /dev/shm/hls /var/www/html/hls Use ffmpeg to create HLS playlist: .no-list ul { list-style-type: circle; } -input_format h264 -i /dev/video0 : input from /dev/video0 (Pi Camera) with V4L2 H264 format (see more in V4L2 H264 direct copy ) -c:v copy : directly use H264 video from V4L2 driver -f hls : output in HLS format -hls_time 1 : video chunks are saved in 1-second segments -hls_list_size 30 : playlist has 30 segments -hls_flags delete_segments : delete segments not in the playlist /dev/shm/hls/live.m3u8 : the location of playlist file and video segments ffmpeg -y \\ -input_format h264 -i /dev/video0 \\ -c:v copy \\ -f hls \\ -hls_time 1 \\ -hls_list_size 30 \\ -hls_flags delete_segments \\ /dev/shm/hls/live.m3u8 4.2. Use HLS streaming \u2693\ufe0e A JavaScript named hls.js will be used to play HLS stream. /var/www/html/hls.html <!DOCTYPE html> < html > < head > < meta charset = \"utf-8\" /> < title > HLS Live Stream </ title > </ head > < body > < h1 > HLS Live Stream </ h1 > < script src = \"hls.js\" ></ script > < video id = \"video\" controls autoplay ></ video > < script > var video = document . getElementById ( \"video\" ); var videoSrc = \"hls/live.m3u8\" ; // First check for native browser HLS support if ( video . canPlayType ( \"application/vnd.apple.mpegurl\" )) { video . src = videoSrc ; } // If no native HLS support, check if hls.js is supported else if ( Hls . isSupported ()) { var hls = new Hls (); hls . loadSource ( videoSrc ); hls . attachMedia ( video ); } </ script > </ body > </ html > HLS Performance HLS is good to stream over HTTP but it has big delay. At the resolution 1024x768 @ 30fps, 1-second segments, it still shows a delay of ~10 seconds . HLS testing site https://hls-js.netlify.app/demo can measure the performance of a HLS playlist. If testing a local server, it needs to enable CORS in server settings or use CORS unblock extension. 4.3. Use MPEG-DASH streaming \u2693\ufe0e DASH is the same as HLS, the difference is in the playlist format and the container of segments. Create a new folder in shared memory: mkdir -p /dev/shm/dash and make a soft-link to the web folder: ln -s /dev/shm/dash /var/www/html/dash Use ffmpeg to create DASH playlist: -f dash : DASH format -seg_duration 1 : segment size is 1-second -streaming 1 : streaming enabled -window_size 30 -remove_at_exit 1 : playlist has 30 chunks, delete chunks when exit /dev/shm/dash/live.mpd : playlist file ffmpeg -y \\ -input_format h264 \\ -i /dev/video0 \\ -c:v copy \\ -f dash \\ -seg_duration 1 \\ -streaming 1 \\ -window_size 30 -remove_at_exit 1 \\ /dev/shm/dash/live.mpd And finally, change to Dash.js to play DASH stream: /var/www/html/dash.html <!DOCTYPE html> < html > < head > < meta charset = \"utf-8\" /> < title > MPEG-DASH Live Stream </ title > </ head > < body > < h1 > MPEG-DASH Live Stream </ h1 > < script src = \"dash.all.min.js\" ></ script > < video id = \"videoPlayer\" controls ></ video > < script > ( function () { var url = \"dash/live.mpd\" ; var player = dashjs . MediaPlayer (). create (); player . initialize ( document . querySelector ( \"#videoPlayer\" ), url , true ); player . updateSettings ({ streaming : { lowLatencyEnabled : true , liveDelay : 2 , liveCatchup : { minDrift : 0.05 , playbackRate : 1 , latencyThreshold : 30 , }, }, }); })(); </ script > </ body > </ html > MPEG-DASH Performance MPEG-DASH can achieve ~3 seconds of delay , which is much better than HLS. However, it is still far from real-time live stream. Low latency HLS and MPEG-DASH support Low Latency streaming, but need configured in server and encoder. This topic will be covered later. 5. Python Web Server \u2693\ufe0e Python HTTP server http.server.SimpleHTTPRequestHandler can stream HLS files too. Here listed necessary files to run HLS streaming server with Python: index.html Use hls.js to play HLS Stream. There is extra HLS configs: js var config = Hls.DefaultConfig; config.liveSyncDurationCount = 1; config.startFragPrefetch = true; console.log(config); var hls = new Hls(config); hls.js HLS Stream player written in JavaScript for web server.py This implements a simple HTTP Request Handler based on SimpleHTTPRequestHandler run.sh This script creates a temporary folder in shared memory to store video segments. Then it runs ffmpeg to read camera and write video chunks. Finally, it calls server.py to serve the web. Use ffmpeg to generate both HLS and DASH segments, with some options to reduce latency. ffmpeg -y \\ -input_format h264 \\ -f video4linux2 \\ -framerate 25 \\ -use_wallclock_as_timestamps 1 \\ -i /dev/video0 \\ -c:v copy \\ -f dash \\ -ldash 1 \\ -seg_duration 1 \\ -frag_duration 1 \\ -streaming 1 \\ -window_size 30 -remove_at_exit 1 \\ -strict experimental -lhls 1 \\ -hls_playlist 1 -hls_master_name live.m3u8 \\ -utc_timing_url https://time.akamai.com/?iso \\ -write_prft 1 \\ -target_latency 1 \\ /dev/shm/hls/live.mpd & The result is not good as expected, as there is still about 3.3 seconds of delay in a LAN. Delay in HLS streaming Some lines of code to handle exception are also needed, for full source code, please download by clicking on the download button at the beginning of this post. Can NOT bind to port numbers lower than 1024 Port numbers lower than 1024 are for privileged user only . Therefore: Use a port number larger than 1024 (recommended) Or run the script as a privileged user Harder, but more secure solution if it\u2019s really necessary to accept from port numbers lower than 1024: Run the as unprivileged on a higher port, and forward that port to lower port externally.","title":"HLS/DASH Streaming"},{"location":"blog/pi/stream-ffmpeg-hls-dash/#1-install-ffmpeg","text":"Install FFmpeg from the package manager: sudo apt-get install ffmpeg -y Or compile an executable file by following Compile FFmpeg manually guide.","title":"1. Install FFmpeg"},{"location":"blog/pi/stream-ffmpeg-hls-dash/#2-hls-vs-mpeg-dash","text":"A streaming protocol is a type of technology that is designed to transport video files over the internet. In the past, online video was delivered primarily via the RTMP protocol. RTMP is a Flash-based standard that\u2019s still used today for sending video from an encoder to an online video platform. The RTMP has slowly been replaced by the HLS and MPEG-DASH protocol.","title":"2. HLS vs. MPEG-DASH"},{"location":"blog/pi/stream-ffmpeg-hls-dash/#21-hls","text":"HLS is short for HTTP Live Streaming . Originally developed by Apple, the purpose of HLS was to make the iPhone capable of accessing live streams. HLS can play video encoded with the H.264 or HEVC/H.265 codecs. As the name implies, HLS delivers content via standard HTTP web servers. This means that no special infrastructure is needed to deliver HLS content. Any standard web server or CDN will work. Additionally, content is less likely to be blocked by firewalls with this protocol, which is a plus. How it works is video is chopped up into 10-second segments. Latency for delivery tends to be in the 45-second range. With some settings applied, the delay can be reduced to 3-5 seconds. This protocol also includes several other built-in features. For example, HLS is an adaptive bit rate protocol. This means that the client device and server dynamically detect the internet speed of the user and adjusts video quality accordingly.","title":"2.1. HLS"},{"location":"blog/pi/stream-ffmpeg-hls-dash/#22-mpeg-dash","text":"As a newer standard, MPEG-DASH is an up-and-coming competitor to HLS. This protocol was created as a response to fragmentation in the video streaming market. At the time, Apple\u2019s HLS was competing with several other streaming protocols. The outcome was uncertain, which led standards organizations to develop MPEG-DASH as an alternative, unifying streaming protocol. MPEG-DASH is an open-source standard. Like the HLS streaming protocol, MPEG-DASH is an adaptive bit rate video method. It also supports advertising, and the technology for this is rapidly advancing. However, MPEG-DASH is not supported on the mobile Safari browser. HLS is simply much more widely compatible than MPEG-DASH.","title":"2.2. MPEG-DASH"},{"location":"blog/pi/stream-ffmpeg-hls-dash/#3-setup-web-server","text":"Because HLS and MPEG-DASH are HTTP-based protocols, there is no need to install a special web server, what is needed is just a simple web server which can serve video chunk files.","title":"3. Setup web server"},{"location":"blog/pi/stream-ffmpeg-hls-dash/#31-apache","text":"Apache is a popular web server application which can be installed on the Raspberry Pi to allow it to serve web pages. On its own, Apache can serve HTML files over HTTP, and with additional modules can serve dynamic web pages using scripting languages such as PHP. Apache\u2019s design architecture: Process Driven Approach Creates a new thread for each request. sudo apt-get install apache2 -y By default, Apache puts a test HTML file in the web folder /var/www/html/ . This default web page is served when a browse to http://localhost on the Pi itself or http://pi's_ip from other device\u2019s browsers.","title":"3.1. Apache"},{"location":"blog/pi/stream-ffmpeg-hls-dash/#32-nginx","text":"NGINX (pronounced engine x ) is a popular lightweight web server application which can be installed on the Raspberry Pi to allow it to serve web pages. Like Apache, NGINX can serve HTML files over HTTP, and with additional modules can serve dynamic web pages using scripting languages such as PHP. NGINX\u2019s design architecture: Event-Driven approach Handles multiple requests within one thread Nginx can work very fast and wide with limited resources. sudo apt-get install nginx -y Similar to Apache, NGINX also serves web pages in /var/www/html/ . Go to http://localhost/etc/nginx/sites-available to see the site\u2019s links. As the article Apache Vs NGINX \u2014 Which Is The Best Web Server? mentioned, it should go with NGINX if serving static web page with a high traffic (requests).","title":"3.2. NGINX"},{"location":"blog/pi/stream-ffmpeg-hls-dash/#4-stream-live-video","text":"MPEG-DASH and HLS both create playlist files whose content are list of video chunks. ffmpeg can read from camera and write video chunks as well as update the playlist. To speed up and to protect SD Card, it is better to write video chunks to RAM memory. When the number of chunks go high, clear the old ones to get more space . Let\u2019s do it with HLS first!","title":"4. Stream live video"},{"location":"blog/pi/stream-ffmpeg-hls-dash/#41-create-video-chunks","text":"Create a new folder in shared memory: mkdir -p /dev/shm/hls and make a soft-link to the web folder: ln -s /dev/shm/hls /var/www/html/hls Use ffmpeg to create HLS playlist: .no-list ul { list-style-type: circle; } -input_format h264 -i /dev/video0 : input from /dev/video0 (Pi Camera) with V4L2 H264 format (see more in V4L2 H264 direct copy ) -c:v copy : directly use H264 video from V4L2 driver -f hls : output in HLS format -hls_time 1 : video chunks are saved in 1-second segments -hls_list_size 30 : playlist has 30 segments -hls_flags delete_segments : delete segments not in the playlist /dev/shm/hls/live.m3u8 : the location of playlist file and video segments ffmpeg -y \\ -input_format h264 -i /dev/video0 \\ -c:v copy \\ -f hls \\ -hls_time 1 \\ -hls_list_size 30 \\ -hls_flags delete_segments \\ /dev/shm/hls/live.m3u8","title":"4.1. Create video chunks"},{"location":"blog/pi/stream-ffmpeg-hls-dash/#42-use-hls-streaming","text":"A JavaScript named hls.js will be used to play HLS stream. /var/www/html/hls.html <!DOCTYPE html> < html > < head > < meta charset = \"utf-8\" /> < title > HLS Live Stream </ title > </ head > < body > < h1 > HLS Live Stream </ h1 > < script src = \"hls.js\" ></ script > < video id = \"video\" controls autoplay ></ video > < script > var video = document . getElementById ( \"video\" ); var videoSrc = \"hls/live.m3u8\" ; // First check for native browser HLS support if ( video . canPlayType ( \"application/vnd.apple.mpegurl\" )) { video . src = videoSrc ; } // If no native HLS support, check if hls.js is supported else if ( Hls . isSupported ()) { var hls = new Hls (); hls . loadSource ( videoSrc ); hls . attachMedia ( video ); } </ script > </ body > </ html > HLS Performance HLS is good to stream over HTTP but it has big delay. At the resolution 1024x768 @ 30fps, 1-second segments, it still shows a delay of ~10 seconds . HLS testing site https://hls-js.netlify.app/demo can measure the performance of a HLS playlist. If testing a local server, it needs to enable CORS in server settings or use CORS unblock extension.","title":"4.2. Use HLS streaming"},{"location":"blog/pi/stream-ffmpeg-hls-dash/#43-use-mpeg-dash-streaming","text":"DASH is the same as HLS, the difference is in the playlist format and the container of segments. Create a new folder in shared memory: mkdir -p /dev/shm/dash and make a soft-link to the web folder: ln -s /dev/shm/dash /var/www/html/dash Use ffmpeg to create DASH playlist: -f dash : DASH format -seg_duration 1 : segment size is 1-second -streaming 1 : streaming enabled -window_size 30 -remove_at_exit 1 : playlist has 30 chunks, delete chunks when exit /dev/shm/dash/live.mpd : playlist file ffmpeg -y \\ -input_format h264 \\ -i /dev/video0 \\ -c:v copy \\ -f dash \\ -seg_duration 1 \\ -streaming 1 \\ -window_size 30 -remove_at_exit 1 \\ /dev/shm/dash/live.mpd And finally, change to Dash.js to play DASH stream: /var/www/html/dash.html <!DOCTYPE html> < html > < head > < meta charset = \"utf-8\" /> < title > MPEG-DASH Live Stream </ title > </ head > < body > < h1 > MPEG-DASH Live Stream </ h1 > < script src = \"dash.all.min.js\" ></ script > < video id = \"videoPlayer\" controls ></ video > < script > ( function () { var url = \"dash/live.mpd\" ; var player = dashjs . MediaPlayer (). create (); player . initialize ( document . querySelector ( \"#videoPlayer\" ), url , true ); player . updateSettings ({ streaming : { lowLatencyEnabled : true , liveDelay : 2 , liveCatchup : { minDrift : 0.05 , playbackRate : 1 , latencyThreshold : 30 , }, }, }); })(); </ script > </ body > </ html > MPEG-DASH Performance MPEG-DASH can achieve ~3 seconds of delay , which is much better than HLS. However, it is still far from real-time live stream. Low latency HLS and MPEG-DASH support Low Latency streaming, but need configured in server and encoder. This topic will be covered later.","title":"4.3. Use MPEG-DASH streaming"},{"location":"blog/pi/stream-ffmpeg-hls-dash/#5-python-web-server","text":"Python HTTP server http.server.SimpleHTTPRequestHandler can stream HLS files too. Here listed necessary files to run HLS streaming server with Python: index.html Use hls.js to play HLS Stream. There is extra HLS configs: js var config = Hls.DefaultConfig; config.liveSyncDurationCount = 1; config.startFragPrefetch = true; console.log(config); var hls = new Hls(config); hls.js HLS Stream player written in JavaScript for web server.py This implements a simple HTTP Request Handler based on SimpleHTTPRequestHandler run.sh This script creates a temporary folder in shared memory to store video segments. Then it runs ffmpeg to read camera and write video chunks. Finally, it calls server.py to serve the web. Use ffmpeg to generate both HLS and DASH segments, with some options to reduce latency. ffmpeg -y \\ -input_format h264 \\ -f video4linux2 \\ -framerate 25 \\ -use_wallclock_as_timestamps 1 \\ -i /dev/video0 \\ -c:v copy \\ -f dash \\ -ldash 1 \\ -seg_duration 1 \\ -frag_duration 1 \\ -streaming 1 \\ -window_size 30 -remove_at_exit 1 \\ -strict experimental -lhls 1 \\ -hls_playlist 1 -hls_master_name live.m3u8 \\ -utc_timing_url https://time.akamai.com/?iso \\ -write_prft 1 \\ -target_latency 1 \\ /dev/shm/hls/live.mpd & The result is not good as expected, as there is still about 3.3 seconds of delay in a LAN. Delay in HLS streaming Some lines of code to handle exception are also needed, for full source code, please download by clicking on the download button at the beginning of this post. Can NOT bind to port numbers lower than 1024 Port numbers lower than 1024 are for privileged user only . Therefore: Use a port number larger than 1024 (recommended) Or run the script as a privileged user Harder, but more secure solution if it\u2019s really necessary to accept from port numbers lower than 1024: Run the as unprivileged on a higher port, and forward that port to lower port externally.","title":"5. Python Web Server"},{"location":"blog/pi/stream-picamera-h264/","text":"stream_picamera_h264 Low latency streaming using H264 format Big Buck Bunny movie , \u00a9 2008, Blender Foundation 1. Stream video \u2693\ufe0e Live-streaming requires very low latency with acceptable quality and bandwidth. MJPEG Streaming has low latency but high bandwidth. HLS/DASH Streaming is not real-time. Therefore, people have to find a method to transfer encoded video in real-time. An example of streaming real video (not frame by frame) is pistreaming which uses mpeg1video format. The video stream is sent to user\u2019s browser via a websocket , and is decoded by JSMPEG JavaScript library. This post will show a method similar to both MPEG stream and MJPEG images: send video using H264 Network Abstract Layer (NAL) units and decode those units to display video. 2. Broadway.js \u2014 An H264 decoder \u2693\ufe0e The h264-live-player is used for streaming an Android screen to a webpage. That player uses Broadway.js library to decode the video stream. It also has a streaming server for Raspberry Pi using raspivid , nodejs , and websocket . The method used in that player is quite similar to MJPEG Streaming : video stream is split into NAL units (Video Control Layer (VCL) or non-VLC packages), then transported using a websocket, and finally decoded by the Broadway.js library. Broadway.js provides Player.js , Decoder.js , YUVCanvas.js , and avc.wasm , with very simple usage: create a new Player object; then put the player\u2019s canvas to an element to display the video; and call the decode function with the stream data. var player = new Player ({ < options > }); playerElement = document . getElementById ( playerId ) playerElement . appendChild ( player . canvas ) player . decode ( < h264 data > ); 3. Create a webpage \u2693\ufe0e The webpage firstly loads necessary libraries and requests to open a websocket connection, then feeds Broadway decoder with a streaming data chunk by calling player.decode() method. index.html <!DOCTYPE html> < html > < head > < meta charset = 'utf-8' > < title > PiCamera H264 Streaming </ title > </ head > < body > < h1 > PiCamera H264 Streaming </ h1 > < div id = 'viewer' ></ div > < script src = 'Decoder.js' ></ script > < script src = 'YUVCanvas.js' ></ script > < script src = 'Player.js' ></ script > < script > // player window . player = new Player ({ useWorker : true , webgl : 'auto' , size : { width : 848 , height : 480 } }) var playerElement = document . getElementById ( 'viewer' ) playerElement . appendChild ( window . player . canvas ) // Websocket var wsUri = window . location . protocol . replace ( /http/ , 'ws' ) + '//' + window . location . hostname + ':9000' var ws = new WebSocket ( wsUri ) ws . binaryType = 'arraybuffer' ws . onopen = function ( e ) { console . log ( 'Client connected' ) ws . onmessage = function ( msg ) { // decode stream window . player . decode ( new Uint8Array ( msg . data )); } } ws . onclose = function ( e ) { console . log ( 'Client disconnected' ) } </ script > </ body > </ html > 4. Create server \u2693\ufe0e Here is the structure of a H264 streaming system use in the post. PiCamera will capture a H264 stream and write to FrameBuffer each NALU package which will be sent to the Broadway.js via a websocket. The decoded video frame will be drawn on a canvas to show in the webpage. The webpage is provided via an HTTP server which will load the Broadway.js and set up the decoder and a websocket client. H264 streaming server structure 4.1. Frame buffer \u2693\ufe0e The FrameBuffer is implemented as an output of PiCamera which store each H264 Network Abstraction Layer (NAL) unit from H264/AVC or HEVC video stream. There is a Condition object to synchronize between FrameBuffer and WebSocketServer . For more detail of how to construct FrameBuffer class, refer to Streaming using MJPEG import io from threading import Condition class FrameBuffer ( object ): def __init__ ( self ): self . frame = None self . buffer = io . BytesIO () self . condition = Condition () def write ( self , buf ): if buf . startswith ( b ' \\x00\\x00\\x00\\x01 ' ): with self . condition : self . buffer . seek ( 0 ) self . buffer . write ( buf ) self . buffer . truncate () self . frame = self . buffer . getvalue () self . condition . notify_all () 4.2. HTTP Server \u2693\ufe0e The web interface server is served by ThreadingHTTPServer with SimpleHTTPRequestHandler to serve requested files ( index.html , *.js , etc.). from http.server import SimpleHTTPRequestHandler , ThreadingHTTPServer from threading import Thread httpd = ThreadingHTTPServer (( '' , 8000 ), SimpleHTTPRequestHandler ) httpd_thread = Thread ( target = httpd . serve_forever ) 4.3. Websocket Server \u2693\ufe0e One of good WebSocket packages for Python is ws4py which supports both Python 2 and Python 3 (while websockets requires Python \u2265 3.6.1). From the package ws4py , use module wsgiref as a Web Server Gateway Interface to make a websocket server. The function make_server() needs to know the port, and some classes to initialize a server, those can be built-in objects in ws4py such as WebSocketWSGIRequestHandler , WebSocketWSGIApplication , and base WebSocket . Finally, a client manager should be created in the websocket server, to use broadcasting function later. from wsgiref.simple_server import make_server from threading import Thread websocketd = make_server ( '' , 9000 , server_class = WSGIServer , handler_class = WebSocketWSGIRequestHandler , app = WebSocketWSGIApplication ( handler_cls = WebSocket )) websocketd . initialize_websockets_manager () websocketd_thread = Thread ( target = websocketd . serve_forever ) 4.4. Main thread \u2693\ufe0e The main application will start PiCamera and write output video in h264 encode. As noted in Broadway.js, it only supports H264 Baseline profile , therefore, set profile = \"baseline\" when starting video record. import picamera with picamera . PiCamera ( resolution = '640x480' , framerate = 24 ) as camera : broadcasting = True frame_buffer = FrameBuffer () camera . start_recording ( frame_buffer , format = 'h264' , profile = \"baseline\" ) The main loop should broadcast H264 NAL units to all connected clients, after it starts threads for HTTP Server and WebSocket Server. try : websocketd_thread . start () httpd_thread . start () while broadcasting : with frame_buffer . condition : frame_buffer . condition . wait () websocketd . manager . broadcast ( frame_buffer . frame , binary = True ) Low latency in H264 streaming There may be some delay before the video shows up in user webpage because the Player has to wait for a IDR Frame (keyframe) to be able to start decoding. Some lines of code to handle exception are also needed, for full source code, please download by clicking on the download button at the beginning of this post.","title":"H264 streaming"},{"location":"blog/pi/stream-picamera-h264/#1-stream-video","text":"Live-streaming requires very low latency with acceptable quality and bandwidth. MJPEG Streaming has low latency but high bandwidth. HLS/DASH Streaming is not real-time. Therefore, people have to find a method to transfer encoded video in real-time. An example of streaming real video (not frame by frame) is pistreaming which uses mpeg1video format. The video stream is sent to user\u2019s browser via a websocket , and is decoded by JSMPEG JavaScript library. This post will show a method similar to both MPEG stream and MJPEG images: send video using H264 Network Abstract Layer (NAL) units and decode those units to display video.","title":"1. Stream video"},{"location":"blog/pi/stream-picamera-h264/#2-broadwayjs--an-h264-decoder","text":"The h264-live-player is used for streaming an Android screen to a webpage. That player uses Broadway.js library to decode the video stream. It also has a streaming server for Raspberry Pi using raspivid , nodejs , and websocket . The method used in that player is quite similar to MJPEG Streaming : video stream is split into NAL units (Video Control Layer (VCL) or non-VLC packages), then transported using a websocket, and finally decoded by the Broadway.js library. Broadway.js provides Player.js , Decoder.js , YUVCanvas.js , and avc.wasm , with very simple usage: create a new Player object; then put the player\u2019s canvas to an element to display the video; and call the decode function with the stream data. var player = new Player ({ < options > }); playerElement = document . getElementById ( playerId ) playerElement . appendChild ( player . canvas ) player . decode ( < h264 data > );","title":"2. Broadway.js \u2014 An H264 decoder"},{"location":"blog/pi/stream-picamera-h264/#3-create-a-webpage","text":"The webpage firstly loads necessary libraries and requests to open a websocket connection, then feeds Broadway decoder with a streaming data chunk by calling player.decode() method. index.html <!DOCTYPE html> < html > < head > < meta charset = 'utf-8' > < title > PiCamera H264 Streaming </ title > </ head > < body > < h1 > PiCamera H264 Streaming </ h1 > < div id = 'viewer' ></ div > < script src = 'Decoder.js' ></ script > < script src = 'YUVCanvas.js' ></ script > < script src = 'Player.js' ></ script > < script > // player window . player = new Player ({ useWorker : true , webgl : 'auto' , size : { width : 848 , height : 480 } }) var playerElement = document . getElementById ( 'viewer' ) playerElement . appendChild ( window . player . canvas ) // Websocket var wsUri = window . location . protocol . replace ( /http/ , 'ws' ) + '//' + window . location . hostname + ':9000' var ws = new WebSocket ( wsUri ) ws . binaryType = 'arraybuffer' ws . onopen = function ( e ) { console . log ( 'Client connected' ) ws . onmessage = function ( msg ) { // decode stream window . player . decode ( new Uint8Array ( msg . data )); } } ws . onclose = function ( e ) { console . log ( 'Client disconnected' ) } </ script > </ body > </ html >","title":"3. Create a webpage"},{"location":"blog/pi/stream-picamera-h264/#4-create-server","text":"Here is the structure of a H264 streaming system use in the post. PiCamera will capture a H264 stream and write to FrameBuffer each NALU package which will be sent to the Broadway.js via a websocket. The decoded video frame will be drawn on a canvas to show in the webpage. The webpage is provided via an HTTP server which will load the Broadway.js and set up the decoder and a websocket client. H264 streaming server structure","title":"4. Create server"},{"location":"blog/pi/stream-picamera-h264/#41-frame-buffer","text":"The FrameBuffer is implemented as an output of PiCamera which store each H264 Network Abstraction Layer (NAL) unit from H264/AVC or HEVC video stream. There is a Condition object to synchronize between FrameBuffer and WebSocketServer . For more detail of how to construct FrameBuffer class, refer to Streaming using MJPEG import io from threading import Condition class FrameBuffer ( object ): def __init__ ( self ): self . frame = None self . buffer = io . BytesIO () self . condition = Condition () def write ( self , buf ): if buf . startswith ( b ' \\x00\\x00\\x00\\x01 ' ): with self . condition : self . buffer . seek ( 0 ) self . buffer . write ( buf ) self . buffer . truncate () self . frame = self . buffer . getvalue () self . condition . notify_all ()","title":"4.1. Frame buffer"},{"location":"blog/pi/stream-picamera-h264/#42-http-server","text":"The web interface server is served by ThreadingHTTPServer with SimpleHTTPRequestHandler to serve requested files ( index.html , *.js , etc.). from http.server import SimpleHTTPRequestHandler , ThreadingHTTPServer from threading import Thread httpd = ThreadingHTTPServer (( '' , 8000 ), SimpleHTTPRequestHandler ) httpd_thread = Thread ( target = httpd . serve_forever )","title":"4.2. HTTP Server"},{"location":"blog/pi/stream-picamera-h264/#43-websocket-server","text":"One of good WebSocket packages for Python is ws4py which supports both Python 2 and Python 3 (while websockets requires Python \u2265 3.6.1). From the package ws4py , use module wsgiref as a Web Server Gateway Interface to make a websocket server. The function make_server() needs to know the port, and some classes to initialize a server, those can be built-in objects in ws4py such as WebSocketWSGIRequestHandler , WebSocketWSGIApplication , and base WebSocket . Finally, a client manager should be created in the websocket server, to use broadcasting function later. from wsgiref.simple_server import make_server from threading import Thread websocketd = make_server ( '' , 9000 , server_class = WSGIServer , handler_class = WebSocketWSGIRequestHandler , app = WebSocketWSGIApplication ( handler_cls = WebSocket )) websocketd . initialize_websockets_manager () websocketd_thread = Thread ( target = websocketd . serve_forever )","title":"4.3. Websocket Server"},{"location":"blog/pi/stream-picamera-h264/#44-main-thread","text":"The main application will start PiCamera and write output video in h264 encode. As noted in Broadway.js, it only supports H264 Baseline profile , therefore, set profile = \"baseline\" when starting video record. import picamera with picamera . PiCamera ( resolution = '640x480' , framerate = 24 ) as camera : broadcasting = True frame_buffer = FrameBuffer () camera . start_recording ( frame_buffer , format = 'h264' , profile = \"baseline\" ) The main loop should broadcast H264 NAL units to all connected clients, after it starts threads for HTTP Server and WebSocket Server. try : websocketd_thread . start () httpd_thread . start () while broadcasting : with frame_buffer . condition : frame_buffer . condition . wait () websocketd . manager . broadcast ( frame_buffer . frame , binary = True ) Low latency in H264 streaming There may be some delay before the video shows up in user webpage because the Player has to wait for a IDR Frame (keyframe) to be able to start decoding. Some lines of code to handle exception are also needed, for full source code, please download by clicking on the download button at the beginning of this post.","title":"4.4. Main thread"},{"location":"blog/pi/stream-picamera-mjpeg/","text":"stream_picamera_mjpeg Low latency streaming using MJPEG format Big Buck Bunny movie , \u00a9 2008, Blender Foundation There are many methods to implement a streaming server using MJPEG (MJPG) format. The basic principle is to send a series of JPEG (JPG) image to the user\u2019s webpage and display it in an image <img> tag. An example is the mjpg-streamer . This post shows a method to develop a streaming system, starting with a Python package named PiCamera and a simple Python HTTP server. Setup PiCamera To setup picamera package, please read more in the Setup Camera post. PiCamera also has an example to stream MJPEG at Web streaming section. The basic structure of this MJPEG streaming server is as below. PiCamera will capture JPEG images to a buffer that will be sent to user\u2019s web browser via an endless multipart/x-mixed-replace content when the webpage requests to show an image in a <img> element. A structure of an MJPEG streaming server 1. Record video to a stream \u2693\ufe0e This is a basic step to write a video stream to a buffered memory. Python has the io package which expects bytes-like objects and produces bytes objects. No encoding, decoding, or newline translation is performed, because PiCamera requests to V4L2 driver to handle the encoding in hardware. from io import BytesIO from picamera import PiCamera # create in-memory stream stream = BytesIO () # create camera object (instance) camera = PiCamera () # config camera camera . resolution = ( 640 , 480 ) # start recording to stream camera . start_recording ( stream , format = 'mjpeg' ) # wait camera . wait_recording ( 15 ) # stop recording camera . stop_recording () 2. Frame buffer \u2693\ufe0e Next step is to create a custom output to used in PiCamera.start_recording() method. Refer to Custom outputs . A file-like object (as far as PiCamera is concerned) is simply an object with: A write() method which must accept a single parameter consisting of a byte-string, and which can optionally return the number of bytes written. A flush() method with no parameters, which will be called at the end of output. In write() method, it can implement code that reacts to each and every frame. The write() method is called frequently, so its implementation must be sufficiently rapid that it doesn\u2019t stall the encoding flow. Let\u2019s write a class FrameBuffer() which checks the JPEG Magic Number 0xFF 0xD8 at the beginning of an JPEG image: import io class FrameBuffer ( object ): def __init__ ( self ): # store each frame self . frame = None # buffer to hold incoming frame self . buffer = io . BytesIO () def write ( self , buf ): # if it's a JPEG image if buf . startswith ( b ' \\xff\\xd8 ' ): # write to buffer self . buffer . seek ( 0 ) self . buffer . write ( buf ) # extract frame self . buffer . truncate () self . frame = self . buffer . getvalue () Note that FrameBuffer.frame will be used to send the frame to user\u2019s webpage. Then, use the FrameBuffer instead of the buffered memory: # create buffer frame_buffer = FrameBuffer () # write to framebuffer camera . start_recording ( frame_buffer , format = 'mjpeg' ) 3. Streaming Web server \u2693\ufe0e Python has a built-in simple HTTP Server, which is ready to run by providing a server address and a request handler class. from http.server import HTTPServer , BaseHTTPRequestHandler def run ( server_class = HTTPServer , handler_class = BaseHTTPRequestHandler ): server_address = ( '' , 8000 ) httpd = server_class ( server_address , handler_class ) httpd . serve_forever () Now, look at some pre-defined Request Handler classes: class http . server . BaseHTTPRequestHandler This class is used to handle the HTTP requests that arrive at the server. By itself, it cannot respond to any actual HTTP requests; BaseHTTPRequestHandler just provides a number of class and instance variables, and methods for use by subclasses. It must be sub-classed to handle each request method (e.g. GET or POST). The handler will parse the request and the headers, then call a method specific to the request type. The method name is constructed from the request. For example, for the request method SPAM , the do_SPAM() method will be called with no arguments. All the relevant information is stored in instance variables of the handler. Subclasses should not need to override or extend the __init__() method. class http . server . SimpleHTTPRequestHandler This class serves files from the current directory and below, directly mapping the directory structure to HTTP requests. A lot of the work, such as parsing the request, is done by the base class BaseHTTPRequestHandler . This class implements the do_GET() and do_HEAD() functions. class http . server . CGIHTTPRequestHandler This class is used to serve either files or output of CGI scripts from the current directory and below. Note that mapping HTTP hierarchic structure to local directory structure is exactly as in SimpleHTTPRequestHandler . The class will however, run the CGI script, instead of serving it as a file, if it guesses it to be a CGI script. Only directory-based CGI are used \u2014 the other common server configuration is to treat special extensions as denoting CGI scripts. The do_GET() and do_HEAD() functions are modified to run CGI scripts and serve the output, instead of serving files, if the request leads to somewhere below the cgi_directories path. Let\u2019s start with SimpleHTTPRequestHandler which has some implemented features. 4. Request Handler \u2693\ufe0e Based on SimpleHTTPRequestHandler , create a new class StreamingHandler and only override do_GET() method to just print requested path and then call the base method as it is already implemented. from http.server import SimpleHTTPRequestHandler class StreamingHandler ( SimpleHTTPRequestHandler ): def do_GET ( self ): print ( self . path ) # call to the base method implemented in SimpleHTTPRequestHandler super () . do_GET () The SimpleHTTPRequestHandler will serve files in GET requests, and it will look for index.html for the homepage. To display image, create an image <img> tag which will request a file named stream.mjpg . < html > < head > < title > Picamea MJPEG Live Stream </ title > </ head > < body > <!-- Request MJPEG stream --> < img src = \"stream.mjpg\" /> </ body > </ html > There is no actual stream.mjpg file! . When the web page request stream.mjpg , web server should return a stream, not a single file, therefore a special sequence is needed to handle this special request of stream.mjpg file in the do_GET() method: Send response with HTTP Status Code 200 (Successful responses) Send header with information to notify web client about type of responded content, which is multipart/x-mixed-replace Send the content in a stream format (loop forever!): send the boundary FRAME , send content type of each frame image/jpeg , send the length of the content, and then send the actual image data from http.server import SimpleHTTPRequestHandler class StreamingHandler ( SimpleHTTPRequestHandler ): def do_GET ( self ): if self . path == '/stream.mjpg' : # response self . send_response ( 200 ) # header self . send_header ( 'Age' , 0 ) self . send_header ( 'Cache-Control' , 'no-cache, private' ) self . send_header ( 'Pragma' , 'no-cache' ) self . send_header ( 'Content-Type' , 'multipart/x-mixed-replace; boundary=FRAME' ) self . end_headers () try : while True : frame = frame_buffer . frame # need frame_buffer as global self . wfile . write ( b '--FRAME \\r\\n ' ) self . send_header ( 'Content-Type' , 'image/jpeg' ) self . send_header ( 'Content-Length' , len ( frame )) self . end_headers () self . wfile . write ( frame ) self . wfile . write ( b ' \\r\\n ' ) except Exception as e : print ( str ( e )) else : super () . do_GET () Finally, wrap them up by creating an instance of FrameBuffer , PiCamera , HTTPServer to start streaming: frame_buffer = FrameBuffer () camera = PiCamera ( resolution = '640x480' , framerate = 24 ) camera . start_recording ( frame_buffer , format = 'mjpeg' ) server_address = ( '' , 8000 ) handler_class = StreamingHandler # alias try : httpd = HTTPServer ( server_address , handler_class ) httpd . serve_forever () finally : camera . stop_recording () Bug: Hangup stream When run the above code, the web page shows up but with only one frame displayed, CPU is locked up at 100%, because the block while True : loop causes the problem. Need to find a way to synchronize between camera thread and web server thread: send a frame only when it is available. 5. Synchronize between threads \u2693\ufe0e Python has implemented a lock mechanism between threads: class threading . Condition ( lock = None ) This class implements condition variable objects. A condition variable allows one or more threads to wait until they are notified by another thread. If the lock argument is given and not None , it must be a Lock or RLock object, and it is used as the underlying lock. Otherwise, a new RLock object is created and used as the underlying lock. wait ( timeout = None ) Wait until notified or until a timeout occurs. If the calling thread has not acquired the lock when this method is called, a RuntimeError is raised. This method releases the underlying lock , and then blocks until it is awakened by a notify() or notify_all() call for the same condition variable in another thread, or until the optional timeout occurs. Once awakened or timed out, it re-acquires the lock and returns. notify_all () Wake up all threads waiting on this condition. This method acts like notify() , but wakes up all waiting threads instead of one. If the calling thread has not acquired the lock when this method is called, a RuntimeError is raised. Then add a Condition object in FrameBuffer , and use it in StreamingHandler : from threading import Condition class FrameBuffer ( object ): def __init__ ( self ): self . frame = None self . buffer = io . BytesIO () # synchronize between threads self . condition = Condition () def write ( self , buf ): if buf . startswith ( b ' \\xff\\xd8 ' ): with self . condition : self . buffer . seek ( 0 ) self . buffer . write ( buf ) self . buffer . truncate () self . frame = self . buffer . getvalue () # notify other threads self . condition . notify_all () class StreamingHandler ( SimpleHTTPRequestHandler ): def do_GET ( self ): if self . path == '/stream.mjpg' : ... try : while True : with frame_buffer . condition : # wait for a new frame frame_buffer . condition . wait () frame = frame_buffer . frame # access global variable, need to change later Wow, it works!!! The latency is just about 200ms which is unachievable with HLS/ MPEG-DASH streaming. However, the CPU usage is quite high, Pi Zero W only can handle 6 clients at the same time with video quality at 640x480 @25fps. A low latency in MJPEG streaming Hint Above sections are enough to create a simple MJPEG streaming server. Below sections are for an advanced implementation which need some advanced Python programming to create multiple buffers in an application, which can be used to merge or manipulate the image before sending to user\u2019s browsers. 6. Some updates in the script \u2693\ufe0e The instance frame_buffer is used as a global variable in the StreamingHandler , it is not good if there is another FrameBuffer used for another stream in a same script. Here is an advanced method to have multiple frame buffers by passing an instance of FrameBuffer into an instance of StreamingHandler . It can be done by adding an Instance variable that holds reference to an instance of FrameBuffer , but can not be done using Class variable . Let\u2019s check how they work. 6.1. Class variable \u2693\ufe0e Class variable is shared by all instance, therefore it acts like a global static attribute of the class. class StreamingHandler ( SimpleHTTPRequestHandler ): # class variable refers to an instance of FrameBuffer my_frame_buffer = None def do_GET ( self ): ... frame = self . my_frame_buffer . frame # create an instance of FrameBuffer frame_buffer = FrameBuffer () handler_class = StreamingHandler # alias # assign class variable handler_class . my_frame_buffer = frame_buffer # all instance will share class variables first_handler = StreamingHandler () second_handler = StreamingHandler () # first_handler.my_frame_buffer will be the same as second_handler.my_frame_buffer 6.2. Instance variable \u2693\ufe0e Instance variables are for the data unique to each instance, they are created in the __init()__ constructor of that class: class StreamingHandler ( SimpleHTTPRequestHandler ): def __init__ ( self , frame_buffer , request , client_address , server , directory = None ): self . my_frame_buffer = frame_buffer super () . __init__ ( request , client_address , server , directory ) def do_GET (): ... However, with this modification, script cannot use StreamingHandler to initialize ThreadingHTTPServer anymore, because it expects to call a request handler with only required positional arguments (request, client_address, server) , without a new argument frame_buffer . Therefore, write a function that convert expected parameters list to new parameters list: frame_buffer = FrameBuffer () def getStreamingHandler ( request , client_address , server ): return StreamingHandler ( frame_buffer , request , client_address , server ) httpd = ThreadingHTTPServer ( address , getStreamingHandler ) Well, it works, but the convert function actually drop the parameter directory which is an optional parameter in original constructor of SimpleHTTPRequestHandler . To solve this problem, let\u2019s use special *args and **kwargs parameters. 6.3. *args and **kwargs \u2693\ufe0e The special *args and **kwargs parameters allow passing multiple arguments or keyword arguments to a function. Read about them in here . So, change the parameter list (request, client_address, server, ...) to *args in code, then it looks better: class StreamingHandler ( SimpleHTTPRequestHandler ): def __init__ ( self , frame_buffer , * args ): self . my_frame_buffer = frame_buffer super () . __init__ ( * args ) frame_buffer = FrameBuffer () def getStreamingHandler ( * args ): return StreamingHandler ( frame_buffer , * args ) httpd = ThreadingHTTPServer ( address , getStreamingHandler ) 6.4. Lambda function \u2693\ufe0e Python and other languages like Java, C#, and even C++ have had lambda functions added to their syntax, whereas languages like LISP or the ML family of languages, Haskell, OCaml, and F#, use lambdas as a core concept. Read more in here So, reduce the function getStreamingHandler to a lambda function which can be declared in-line when creating ThreadingHTTPServer instance: frame_buffer = FrameBuffer () httpd = ThreadingHTTPServer ( address , lambda * args : StreamingHandler ( frame_buffer , * args )) 6.5. Measure FPS \u2693\ufe0e In the while loop of sending frames, use frame_count variable to count the number of processed frames. With time package, it is easy to calculate FPS over a defined period, for example, 5 seconds in below code: try : # tracking serving time start_time = time . time () frame_count = 0 # endless stream while True : with self . frames_buffer . condition : # wait for a new frame self . frames_buffer . condition . wait () # it's available, pick it up frame = self . frames_buffer . frame # send it ... # count frames frame_count += 1 # calculate FPS every 5s if ( time . time () - start_time ) > 5 : print ( \"FPS: \" , frame_count / ( time . time () - start_time )) frame_count = 0 start_time = time . time () ... Some lines of code to handle exception are also needed, for full source code, please download by clicking on the download button at the beginning of this post.","title":"MJPEG streaming"},{"location":"blog/pi/stream-picamera-mjpeg/#1-record-video-to-a-stream","text":"This is a basic step to write a video stream to a buffered memory. Python has the io package which expects bytes-like objects and produces bytes objects. No encoding, decoding, or newline translation is performed, because PiCamera requests to V4L2 driver to handle the encoding in hardware. from io import BytesIO from picamera import PiCamera # create in-memory stream stream = BytesIO () # create camera object (instance) camera = PiCamera () # config camera camera . resolution = ( 640 , 480 ) # start recording to stream camera . start_recording ( stream , format = 'mjpeg' ) # wait camera . wait_recording ( 15 ) # stop recording camera . stop_recording ()","title":"1. Record video to a stream"},{"location":"blog/pi/stream-picamera-mjpeg/#2-frame-buffer","text":"Next step is to create a custom output to used in PiCamera.start_recording() method. Refer to Custom outputs . A file-like object (as far as PiCamera is concerned) is simply an object with: A write() method which must accept a single parameter consisting of a byte-string, and which can optionally return the number of bytes written. A flush() method with no parameters, which will be called at the end of output. In write() method, it can implement code that reacts to each and every frame. The write() method is called frequently, so its implementation must be sufficiently rapid that it doesn\u2019t stall the encoding flow. Let\u2019s write a class FrameBuffer() which checks the JPEG Magic Number 0xFF 0xD8 at the beginning of an JPEG image: import io class FrameBuffer ( object ): def __init__ ( self ): # store each frame self . frame = None # buffer to hold incoming frame self . buffer = io . BytesIO () def write ( self , buf ): # if it's a JPEG image if buf . startswith ( b ' \\xff\\xd8 ' ): # write to buffer self . buffer . seek ( 0 ) self . buffer . write ( buf ) # extract frame self . buffer . truncate () self . frame = self . buffer . getvalue () Note that FrameBuffer.frame will be used to send the frame to user\u2019s webpage. Then, use the FrameBuffer instead of the buffered memory: # create buffer frame_buffer = FrameBuffer () # write to framebuffer camera . start_recording ( frame_buffer , format = 'mjpeg' )","title":"2. Frame buffer"},{"location":"blog/pi/stream-picamera-mjpeg/#3-streaming-web-server","text":"Python has a built-in simple HTTP Server, which is ready to run by providing a server address and a request handler class. from http.server import HTTPServer , BaseHTTPRequestHandler def run ( server_class = HTTPServer , handler_class = BaseHTTPRequestHandler ): server_address = ( '' , 8000 ) httpd = server_class ( server_address , handler_class ) httpd . serve_forever () Now, look at some pre-defined Request Handler classes: class http . server . BaseHTTPRequestHandler This class is used to handle the HTTP requests that arrive at the server. By itself, it cannot respond to any actual HTTP requests; BaseHTTPRequestHandler just provides a number of class and instance variables, and methods for use by subclasses. It must be sub-classed to handle each request method (e.g. GET or POST). The handler will parse the request and the headers, then call a method specific to the request type. The method name is constructed from the request. For example, for the request method SPAM , the do_SPAM() method will be called with no arguments. All the relevant information is stored in instance variables of the handler. Subclasses should not need to override or extend the __init__() method. class http . server . SimpleHTTPRequestHandler This class serves files from the current directory and below, directly mapping the directory structure to HTTP requests. A lot of the work, such as parsing the request, is done by the base class BaseHTTPRequestHandler . This class implements the do_GET() and do_HEAD() functions. class http . server . CGIHTTPRequestHandler This class is used to serve either files or output of CGI scripts from the current directory and below. Note that mapping HTTP hierarchic structure to local directory structure is exactly as in SimpleHTTPRequestHandler . The class will however, run the CGI script, instead of serving it as a file, if it guesses it to be a CGI script. Only directory-based CGI are used \u2014 the other common server configuration is to treat special extensions as denoting CGI scripts. The do_GET() and do_HEAD() functions are modified to run CGI scripts and serve the output, instead of serving files, if the request leads to somewhere below the cgi_directories path. Let\u2019s start with SimpleHTTPRequestHandler which has some implemented features.","title":"3. Streaming Web server"},{"location":"blog/pi/stream-picamera-mjpeg/#4-request-handler","text":"Based on SimpleHTTPRequestHandler , create a new class StreamingHandler and only override do_GET() method to just print requested path and then call the base method as it is already implemented. from http.server import SimpleHTTPRequestHandler class StreamingHandler ( SimpleHTTPRequestHandler ): def do_GET ( self ): print ( self . path ) # call to the base method implemented in SimpleHTTPRequestHandler super () . do_GET () The SimpleHTTPRequestHandler will serve files in GET requests, and it will look for index.html for the homepage. To display image, create an image <img> tag which will request a file named stream.mjpg . < html > < head > < title > Picamea MJPEG Live Stream </ title > </ head > < body > <!-- Request MJPEG stream --> < img src = \"stream.mjpg\" /> </ body > </ html > There is no actual stream.mjpg file! . When the web page request stream.mjpg , web server should return a stream, not a single file, therefore a special sequence is needed to handle this special request of stream.mjpg file in the do_GET() method: Send response with HTTP Status Code 200 (Successful responses) Send header with information to notify web client about type of responded content, which is multipart/x-mixed-replace Send the content in a stream format (loop forever!): send the boundary FRAME , send content type of each frame image/jpeg , send the length of the content, and then send the actual image data from http.server import SimpleHTTPRequestHandler class StreamingHandler ( SimpleHTTPRequestHandler ): def do_GET ( self ): if self . path == '/stream.mjpg' : # response self . send_response ( 200 ) # header self . send_header ( 'Age' , 0 ) self . send_header ( 'Cache-Control' , 'no-cache, private' ) self . send_header ( 'Pragma' , 'no-cache' ) self . send_header ( 'Content-Type' , 'multipart/x-mixed-replace; boundary=FRAME' ) self . end_headers () try : while True : frame = frame_buffer . frame # need frame_buffer as global self . wfile . write ( b '--FRAME \\r\\n ' ) self . send_header ( 'Content-Type' , 'image/jpeg' ) self . send_header ( 'Content-Length' , len ( frame )) self . end_headers () self . wfile . write ( frame ) self . wfile . write ( b ' \\r\\n ' ) except Exception as e : print ( str ( e )) else : super () . do_GET () Finally, wrap them up by creating an instance of FrameBuffer , PiCamera , HTTPServer to start streaming: frame_buffer = FrameBuffer () camera = PiCamera ( resolution = '640x480' , framerate = 24 ) camera . start_recording ( frame_buffer , format = 'mjpeg' ) server_address = ( '' , 8000 ) handler_class = StreamingHandler # alias try : httpd = HTTPServer ( server_address , handler_class ) httpd . serve_forever () finally : camera . stop_recording () Bug: Hangup stream When run the above code, the web page shows up but with only one frame displayed, CPU is locked up at 100%, because the block while True : loop causes the problem. Need to find a way to synchronize between camera thread and web server thread: send a frame only when it is available.","title":"4. Request Handler"},{"location":"blog/pi/stream-picamera-mjpeg/#5-synchronize-between-threads","text":"Python has implemented a lock mechanism between threads: class threading . Condition ( lock = None ) This class implements condition variable objects. A condition variable allows one or more threads to wait until they are notified by another thread. If the lock argument is given and not None , it must be a Lock or RLock object, and it is used as the underlying lock. Otherwise, a new RLock object is created and used as the underlying lock. wait ( timeout = None ) Wait until notified or until a timeout occurs. If the calling thread has not acquired the lock when this method is called, a RuntimeError is raised. This method releases the underlying lock , and then blocks until it is awakened by a notify() or notify_all() call for the same condition variable in another thread, or until the optional timeout occurs. Once awakened or timed out, it re-acquires the lock and returns. notify_all () Wake up all threads waiting on this condition. This method acts like notify() , but wakes up all waiting threads instead of one. If the calling thread has not acquired the lock when this method is called, a RuntimeError is raised. Then add a Condition object in FrameBuffer , and use it in StreamingHandler : from threading import Condition class FrameBuffer ( object ): def __init__ ( self ): self . frame = None self . buffer = io . BytesIO () # synchronize between threads self . condition = Condition () def write ( self , buf ): if buf . startswith ( b ' \\xff\\xd8 ' ): with self . condition : self . buffer . seek ( 0 ) self . buffer . write ( buf ) self . buffer . truncate () self . frame = self . buffer . getvalue () # notify other threads self . condition . notify_all () class StreamingHandler ( SimpleHTTPRequestHandler ): def do_GET ( self ): if self . path == '/stream.mjpg' : ... try : while True : with frame_buffer . condition : # wait for a new frame frame_buffer . condition . wait () frame = frame_buffer . frame # access global variable, need to change later Wow, it works!!! The latency is just about 200ms which is unachievable with HLS/ MPEG-DASH streaming. However, the CPU usage is quite high, Pi Zero W only can handle 6 clients at the same time with video quality at 640x480 @25fps. A low latency in MJPEG streaming Hint Above sections are enough to create a simple MJPEG streaming server. Below sections are for an advanced implementation which need some advanced Python programming to create multiple buffers in an application, which can be used to merge or manipulate the image before sending to user\u2019s browsers.","title":"5. Synchronize between threads"},{"location":"blog/pi/stream-picamera-mjpeg/#6-some-updates-in-the-script","text":"The instance frame_buffer is used as a global variable in the StreamingHandler , it is not good if there is another FrameBuffer used for another stream in a same script. Here is an advanced method to have multiple frame buffers by passing an instance of FrameBuffer into an instance of StreamingHandler . It can be done by adding an Instance variable that holds reference to an instance of FrameBuffer , but can not be done using Class variable . Let\u2019s check how they work.","title":"6. Some updates in the script"},{"location":"blog/pi/stream-picamera-mjpeg/#61-class-variable","text":"Class variable is shared by all instance, therefore it acts like a global static attribute of the class. class StreamingHandler ( SimpleHTTPRequestHandler ): # class variable refers to an instance of FrameBuffer my_frame_buffer = None def do_GET ( self ): ... frame = self . my_frame_buffer . frame # create an instance of FrameBuffer frame_buffer = FrameBuffer () handler_class = StreamingHandler # alias # assign class variable handler_class . my_frame_buffer = frame_buffer # all instance will share class variables first_handler = StreamingHandler () second_handler = StreamingHandler () # first_handler.my_frame_buffer will be the same as second_handler.my_frame_buffer","title":"6.1. Class variable"},{"location":"blog/pi/stream-picamera-mjpeg/#62-instance-variable","text":"Instance variables are for the data unique to each instance, they are created in the __init()__ constructor of that class: class StreamingHandler ( SimpleHTTPRequestHandler ): def __init__ ( self , frame_buffer , request , client_address , server , directory = None ): self . my_frame_buffer = frame_buffer super () . __init__ ( request , client_address , server , directory ) def do_GET (): ... However, with this modification, script cannot use StreamingHandler to initialize ThreadingHTTPServer anymore, because it expects to call a request handler with only required positional arguments (request, client_address, server) , without a new argument frame_buffer . Therefore, write a function that convert expected parameters list to new parameters list: frame_buffer = FrameBuffer () def getStreamingHandler ( request , client_address , server ): return StreamingHandler ( frame_buffer , request , client_address , server ) httpd = ThreadingHTTPServer ( address , getStreamingHandler ) Well, it works, but the convert function actually drop the parameter directory which is an optional parameter in original constructor of SimpleHTTPRequestHandler . To solve this problem, let\u2019s use special *args and **kwargs parameters.","title":"6.2. Instance variable"},{"location":"blog/pi/stream-picamera-mjpeg/#63-args-and-kwargs","text":"The special *args and **kwargs parameters allow passing multiple arguments or keyword arguments to a function. Read about them in here . So, change the parameter list (request, client_address, server, ...) to *args in code, then it looks better: class StreamingHandler ( SimpleHTTPRequestHandler ): def __init__ ( self , frame_buffer , * args ): self . my_frame_buffer = frame_buffer super () . __init__ ( * args ) frame_buffer = FrameBuffer () def getStreamingHandler ( * args ): return StreamingHandler ( frame_buffer , * args ) httpd = ThreadingHTTPServer ( address , getStreamingHandler )","title":"6.3. *args and **kwargs"},{"location":"blog/pi/stream-picamera-mjpeg/#64-lambda-function","text":"Python and other languages like Java, C#, and even C++ have had lambda functions added to their syntax, whereas languages like LISP or the ML family of languages, Haskell, OCaml, and F#, use lambdas as a core concept. Read more in here So, reduce the function getStreamingHandler to a lambda function which can be declared in-line when creating ThreadingHTTPServer instance: frame_buffer = FrameBuffer () httpd = ThreadingHTTPServer ( address , lambda * args : StreamingHandler ( frame_buffer , * args ))","title":"6.4. Lambda function"},{"location":"blog/pi/stream-picamera-mjpeg/#65-measure-fps","text":"In the while loop of sending frames, use frame_count variable to count the number of processed frames. With time package, it is easy to calculate FPS over a defined period, for example, 5 seconds in below code: try : # tracking serving time start_time = time . time () frame_count = 0 # endless stream while True : with self . frames_buffer . condition : # wait for a new frame self . frames_buffer . condition . wait () # it's available, pick it up frame = self . frames_buffer . frame # send it ... # count frames frame_count += 1 # calculate FPS every 5s if ( time . time () - start_time ) > 5 : print ( \"FPS: \" , frame_count / ( time . time () - start_time )) frame_count = 0 start_time = time . time () ... Some lines of code to handle exception are also needed, for full source code, please download by clicking on the download button at the beginning of this post.","title":"6.5. Measure FPS"},{"location":"blog/pi/ubuntu/","text":"1. Ubuntu \u2693\ufe0e Ubuntu Desktop comes with a rich desktop environment which consumes a bit high system resource and performance. Therefore, other lightweight version of Ubuntu will be chosen. In December 2019, Canonical published a support roadmap for the latest Raspberry Pi 4 single-board computer on their Ubuntu Server operating system and pledged to fully support Ubuntu on all Raspberry Pi boards. Ubuntu currently supports Raspberry Pi 2, Raspberry Pi 3, and Raspberry Pi 4 models, and images are available for the latest version of Ubuntu LTS (Long-Term Support) at https://ubuntu.com/download/raspberry-pi . Old-releases archived images Visit https://old-releases.ubuntu.com/releases/ see the list of prebuilt images for older versions. 2. Supported boards \u2693\ufe0e Ubuntu supports : Raspberry Pi 2 Raspberry Pi 3 Raspberry Pi 4 Raspberry Pi 400 Raspberry Pi CM4 All boards have 2 version: 64-bit and 32-bit , except Raspberry Pi 2 which has only 32-bit version. 64-bit version This version is built for 64-bit mode of the CPU used in Raspberry Pi boards. It has arm4 tag in the image name. 32-bit version This version is built for 32-bit mode of the CPU used in Raspberry Pi boards. It has armhf tag in the image name. Choose an OS version 3. Flash image to a MicroSD Card \u2693\ufe0e Follow the instruction of using Etcher to flash the image. Launch Etcher and select the image file and the target SD card. The process will take a few minutes, so be patient. When Etcher is done, follow the headless mode setup if needed as the installed Ubuntu version is for server. Boot up Login with the default user: Login: ubuntu Password: ubuntu Right after the first time logging in, default password have to be changed. 4. Wi-Fi setup \u2693\ufe0e Starting from Ubuntu 18.04 LTS, Ubuntu uses Netplan to configure network interfaces by default. Netplan is a utility for configuring network interfaces on Linux. Netplan uses YAML files for configuring network interfaces. YAML configuration file format is really simple. It has clear and easy to understand syntax. Edit the Netplan YAML configuration file /etc/netplan/50-cloud-init.yaml with the following command: sudo nano /etc/netplan/50-cloud-init.yaml Add the Wi-Fi access information. Make sure not to use tab for space, use the spaces to create the blank. # This file is generated from information provided by # the datasource. Changes to it will not persist across an instance. # To disable cloud-init's network configuration capabilities, write a file # /etc/cloud/cloud.cfg.d/99-disable-network-config.cfg with the following: # network: {config: disabled} network : version : 2 ethernets : eth0 : optional : true dhcp4 : true # add wifi setup information here ... wifis : wlan0 : optional : true access-points : \"YOUR-SSID-NAME\" : password : \"NETWORK-PASSWORD\" dhcp4 : true Change the SSID-NAME and the NETWORK-PASSWORD with the Wi-Fi AP information. Close and save the file using Ctrl + X and press yes. Now, check whether there\u2019s any error in the configuration file with the following command: sudo netplan --debug try If any error encounters then check with this command for detailed error information: sudo netplan --debug generate Apply the configuration file with the following command: sudo netplan --debug apply 4.1. Setup priority \u2693\ufe0e By default, Ethernet has higher priority to route network packets through it. Run: route -n This will show the metric value for eth0 is 100 and that value of wlan0 is 600. Lower value has higher priority. Destination Gateway Genmask Flags Metric Ref Use Iface 0.0.0.0 192.168.0.1 0.0.0.0 UG 100 0 0 eth0 0.0.0.0 192.168.1.1 0.0.0.0 UG 600 0 0 wlan0 192.168.0.0 0.0.0.0 255.255.255.0 U 0 0 0 eth0 192.168.0.1 0.0.0.0 255.255.255.255 UH 100 0 0 eth0 192.168.1.0 0.0.0.0 255.255.255.0 U 0 0 0 wlan0 192.168.1.1 0.0.0.0 255.255.255.255 UH 600 0 0 wlan0 To make Wi-Fi has higher priority, add a config line in Netplan configuration file: sudo nano /etc/netplan/50-cloud-init.yaml wifis : wlan0 : access-points : \"SSID\" : password : \"pasword\" dhcp4 : true dhcp4-overrides : route-metric : 50 optional : true Then regenerate network configs and apply them: sudo netplan --debug generate && \\ sudo netplan --debug apply Run again: route -n to see the metric for wlan0 is now set to 50: Kernel IP routing table Destination Gateway Genmask Flags Metric Ref Use Iface 0.0.0.0 192.168.1.1 0.0.0.0 UG 50 0 0 wlan0 0.0.0.0 192.168.0.1 0.0.0.0 UG 100 0 0 eth0 192.168.0.0 0.0.0.0 255.255.255.0 U 0 0 0 eth0 192.168.0.1 0.0.0.0 255.255.255.255 UH 100 0 0 eth0 192.168.1.0 0.0.0.0 255.255.255.0 U 0 0 0 wlan0 192.168.1.1 0.0.0.0 255.255.255.255 UH 50 0 0 wlan0 Netplan configuration Refer to https://netplan.io/reference/ 5. Install Desktop Environment \u2693\ufe0e The installed Ubuntu version is for server which is designed to use minimal resources. To install a very lightweight desktop environment run bellow command: To install a very lightweight desktop environment run bellow command or sudo apt-get install lubuntu-desktop Lubuntu vs Xubuntu If you are looking for the most lightweight, Lubuntu is the choice to go. It uses the least system resources and comes with the fewest installed applications, unlike Xubuntu which packs some punch in polish and features meaning a lot more resource use. Xubuntu is relatively lightweight, as in, it\u2019s lighter than Ubuntu and Kubuntu but Lubuntu is actually lightweight . Ubuntu Mate This is an alternative Ubuntu version using MATE desktop environment. The latest version is available at https://ubuntu-mate.org/download/ , while old releases are listed in https://releases.ubuntu-mate.org/archived .","title":"Ubuntu"},{"location":"blog/pi/ubuntu/#1-ubuntu","text":"Ubuntu Desktop comes with a rich desktop environment which consumes a bit high system resource and performance. Therefore, other lightweight version of Ubuntu will be chosen. In December 2019, Canonical published a support roadmap for the latest Raspberry Pi 4 single-board computer on their Ubuntu Server operating system and pledged to fully support Ubuntu on all Raspberry Pi boards. Ubuntu currently supports Raspberry Pi 2, Raspberry Pi 3, and Raspberry Pi 4 models, and images are available for the latest version of Ubuntu LTS (Long-Term Support) at https://ubuntu.com/download/raspberry-pi . Old-releases archived images Visit https://old-releases.ubuntu.com/releases/ see the list of prebuilt images for older versions.","title":"1. Ubuntu"},{"location":"blog/pi/ubuntu/#2-supported-boards","text":"Ubuntu supports : Raspberry Pi 2 Raspberry Pi 3 Raspberry Pi 4 Raspberry Pi 400 Raspberry Pi CM4 All boards have 2 version: 64-bit and 32-bit , except Raspberry Pi 2 which has only 32-bit version. 64-bit version This version is built for 64-bit mode of the CPU used in Raspberry Pi boards. It has arm4 tag in the image name. 32-bit version This version is built for 32-bit mode of the CPU used in Raspberry Pi boards. It has armhf tag in the image name. Choose an OS version","title":"2. Supported boards"},{"location":"blog/pi/ubuntu/#3-flash-image-to-a-microsd-card","text":"Follow the instruction of using Etcher to flash the image. Launch Etcher and select the image file and the target SD card. The process will take a few minutes, so be patient. When Etcher is done, follow the headless mode setup if needed as the installed Ubuntu version is for server. Boot up Login with the default user: Login: ubuntu Password: ubuntu Right after the first time logging in, default password have to be changed.","title":"3. Flash image to a MicroSD Card"},{"location":"blog/pi/ubuntu/#4-wi-fi-setup","text":"Starting from Ubuntu 18.04 LTS, Ubuntu uses Netplan to configure network interfaces by default. Netplan is a utility for configuring network interfaces on Linux. Netplan uses YAML files for configuring network interfaces. YAML configuration file format is really simple. It has clear and easy to understand syntax. Edit the Netplan YAML configuration file /etc/netplan/50-cloud-init.yaml with the following command: sudo nano /etc/netplan/50-cloud-init.yaml Add the Wi-Fi access information. Make sure not to use tab for space, use the spaces to create the blank. # This file is generated from information provided by # the datasource. Changes to it will not persist across an instance. # To disable cloud-init's network configuration capabilities, write a file # /etc/cloud/cloud.cfg.d/99-disable-network-config.cfg with the following: # network: {config: disabled} network : version : 2 ethernets : eth0 : optional : true dhcp4 : true # add wifi setup information here ... wifis : wlan0 : optional : true access-points : \"YOUR-SSID-NAME\" : password : \"NETWORK-PASSWORD\" dhcp4 : true Change the SSID-NAME and the NETWORK-PASSWORD with the Wi-Fi AP information. Close and save the file using Ctrl + X and press yes. Now, check whether there\u2019s any error in the configuration file with the following command: sudo netplan --debug try If any error encounters then check with this command for detailed error information: sudo netplan --debug generate Apply the configuration file with the following command: sudo netplan --debug apply","title":"4. Wi-Fi setup"},{"location":"blog/pi/ubuntu/#41-setup-priority","text":"By default, Ethernet has higher priority to route network packets through it. Run: route -n This will show the metric value for eth0 is 100 and that value of wlan0 is 600. Lower value has higher priority. Destination Gateway Genmask Flags Metric Ref Use Iface 0.0.0.0 192.168.0.1 0.0.0.0 UG 100 0 0 eth0 0.0.0.0 192.168.1.1 0.0.0.0 UG 600 0 0 wlan0 192.168.0.0 0.0.0.0 255.255.255.0 U 0 0 0 eth0 192.168.0.1 0.0.0.0 255.255.255.255 UH 100 0 0 eth0 192.168.1.0 0.0.0.0 255.255.255.0 U 0 0 0 wlan0 192.168.1.1 0.0.0.0 255.255.255.255 UH 600 0 0 wlan0 To make Wi-Fi has higher priority, add a config line in Netplan configuration file: sudo nano /etc/netplan/50-cloud-init.yaml wifis : wlan0 : access-points : \"SSID\" : password : \"pasword\" dhcp4 : true dhcp4-overrides : route-metric : 50 optional : true Then regenerate network configs and apply them: sudo netplan --debug generate && \\ sudo netplan --debug apply Run again: route -n to see the metric for wlan0 is now set to 50: Kernel IP routing table Destination Gateway Genmask Flags Metric Ref Use Iface 0.0.0.0 192.168.1.1 0.0.0.0 UG 50 0 0 wlan0 0.0.0.0 192.168.0.1 0.0.0.0 UG 100 0 0 eth0 192.168.0.0 0.0.0.0 255.255.255.0 U 0 0 0 eth0 192.168.0.1 0.0.0.0 255.255.255.255 UH 100 0 0 eth0 192.168.1.0 0.0.0.0 255.255.255.0 U 0 0 0 wlan0 192.168.1.1 0.0.0.0 255.255.255.255 UH 50 0 0 wlan0 Netplan configuration Refer to https://netplan.io/reference/","title":"4.1. Setup priority"},{"location":"blog/pi/ubuntu/#5-install-desktop-environment","text":"The installed Ubuntu version is for server which is designed to use minimal resources. To install a very lightweight desktop environment run bellow command: To install a very lightweight desktop environment run bellow command or sudo apt-get install lubuntu-desktop Lubuntu vs Xubuntu If you are looking for the most lightweight, Lubuntu is the choice to go. It uses the least system resources and comes with the fewest installed applications, unlike Xubuntu which packs some punch in polish and features meaning a lot more resource use. Xubuntu is relatively lightweight, as in, it\u2019s lighter than Ubuntu and Kubuntu but Lubuntu is actually lightweight . Ubuntu Mate This is an alternative Ubuntu version using MATE desktop environment. The latest version is available at https://ubuntu-mate.org/download/ , while old releases are listed in https://releases.ubuntu-mate.org/archived .","title":"5. Install Desktop Environment"},{"location":"blog/ros/","text":"","title":"ROS"},{"location":"blog/ros/tutorial-beginner/","text":"A Gentle Introduction to ROS by Jason M. O\u2019Kane The official guide is at https://wiki.ros.org/ROS/Tutorials . This guide was created using ROS Melodic on Ubuntu 18.04 LTS . 1. Install ROS \u2693\ufe0e There is more than one ROS distribution supported at a time. Some are older releases with long term support, making them more stable, while others are newer with shorter support life times, but with binaries for more recent platforms and more recent versions of the ROS packages that make them up. Recommend ones of the versions below: ROS Melodic Morenia Released May, 2018 LTS until May, 2023 Recommended for Ubuntu 18.04 ROS Noetic Ninjemys Released May, 2020 LTS until May, 2025 Recommended for Ubuntu 20.04 What is the difference between ROS Melodic model and Noetic model? There aren\u2019t many differences at the base level. The ROS Noetic is recommended for Ubuntu 20.04 whereas ROS Melodic for Ubuntu 18.04: Feature ROS Noetic ROS Melodic Python 3.8 2.7 Gazebo 11.x 9.0 OpenCV 4.2 3.2 Detailed comparison is at repositories.ros.org . Choose the ROS version based on the installed OS. Here, Melodic is used on Ubuntu 18.04 . 1.1. Configure repositories \u2693\ufe0e Configure the Ubuntu repositories to allow \u201crestricted,\u201d \u201cuniverse,\u201d and \u201cmultiverse\u201d by following the Ubuntu guide . Setup source list to get ROS packages: sudo sh -c 'echo \"deb http://packages.ros.org/ros/ubuntu $(lsb_release -sc) main\" > /etc/apt/sources.list.d/ros-latest.list' Add keys: sudo apt install -y curl && \\ curl -s https://raw.githubusercontent.com/ros/rosdistro/master/ros.asc | sudo apt-key add - Then pull the package list: sudo apt update Finally, install a desktop-full package as recommended to start learning: sudo apt install -y ros-melodic-desktop-full && \\ sudo apt install -y ros-melodic-rqt && \\ sudo apt install -y ros-melodic-rqt-common-plugins It\u2019s convenient if the ROS environment variables are automatically added to a bash session every time a new shell is launched: echo \"source /opt/ros/melodic/setup.bash\" >> ~/.bashrc && \\ source ~/.bashrc A good way to check the installation is to ensure that environment variables like ROS_ROOT and ROS_PACKAGE_PATH are set: printenv | grep ROS ROS_ETC_DIR = /opt/ros/melodic/etc/ros ROS_ROOT = /opt/ros/melodic/share/ros ROS_MASTER_URI = http://localhost:11311 ROS_VERSION = 1 ROS_PYTHON_VERSION = 2 ROS_PACKAGE_PATH = /opt/ros/melodic/share ROSLISP_PACKAGE_DIRECTORIES = ROS_DISTRO = melodic 1.2. Build packages \u2693\ufe0e Build packages are needed for code compilation. sudo apt install -y python-rosdep python-rosinstall python-rosinstall-generator python-wstool build-essential Initialize the package rosdep to track package dependency: sudo rosdep init && \\ rosdep update 2. ROS Workspace \u2693\ufe0e A catkin workspace is a folder where to modify, build, and install catkin packages. The catkin_make command is a convenience tool for working with catkin workspaces. Running it the first time in a workspace, it will create a CMakeLists.txt link in the \u2018src\u2019 folder. mkdir -p catkin_ws/src && \\ cd catkin_ws && \\ catkin_make In the current directory, it should now have a build and devel folder. Inside the devel folder, there are now several setup.*sh files. Sourcing any of these files will overlay this workspace on top of current environment. source devel/setup.bash To make sure workspace is properly overlaid by the setup script, make sure ROS_PACKAGE_PATH environment variable includes the current workspace directory. echo $ROS_PACKAGE_PATH /home/vqtrong/Work/catkin_ws/src:/opt/ros/melodic/share This also helps ROS to find new packages. 2.1. The ROS File system \u2693\ufe0e For this tutorial, to inspect a package in ros-tutorials, please install a prebuilt package using: sudo apt install -y ros-melodic-ros-tutorials Two main concepts of the File Systems: Packages are the software organization unit of ROS code. Each package can contain libraries, executables, scripts, or other artifacts. Manifests (package.xml) is a description of a package. It serves to define dependencies between packages and to capture meta information about the package like version, maintainer, license, etc\u2026 Code is spread across many ROS packages. Navigating with command-line tools such as ls and cd can be very tedious which is why ROS provides tools to help. 2.2. File system Tools \u2693\ufe0e rospack allows getting information about packages. rospack find roscpp roscd allows changing directory ( cd ) directly to a package, and also is able to move to a subdirectory of a package roscd roscpp # go to cpp package roscd roscpp/cmake # go to cmake folder inside the cpp package roscd log # go to the log folder, available after run roscore 3. Create a ROS Package \u2693\ufe0e Firstly, use the catkin_create_pkg script to create a new package called beginner_tutorials which depends on std_msgs , roscpp , and rospy : catkin_ws/ cd src && \\ catkin_create_pkg beginner_tutorials std_msgs rospy roscpp This will create a beginner_tutorials folder which contains a package.xml and a CMakeLists.txt , which have been partially filled out with the information given in the catkin_create_pkg command. Build that new workspace again to see beginner_tutorials is added into build folder: catkin_ws/src cd .. && \\ catkin_make Add the workspace to the ROS environment: source devel/setup.bash To check the direct dependencies of a package: rospack depends1 beginner_tutorials To check the indirect dependencies of a package: rospack depends beginner_tutorials 4. ROS Nodes \u2693\ufe0e Quick overview of Graph Concepts: Nodes : A node is an executable that uses ROS to communicate with other nodes. Messages : ROS data type used when subscribing or publishing to a topic. Topics : Nodes can publish messages to a topic as well as subscribe to a topic to receive messages. Master : Name service for ROS (i.e. helps nodes find each other) Rosout : ROS equivalent of stdout/stderr Roscore : Master + Rosout + Ros parameter server (parameter server will be introduced later) 4.1. Roscore \u2693\ufe0e roscore will start up a ROS Master, a ROS Parameter Server and a Rosout logging node Options: -h, --help # show this help message and exit -p, --port = # master port. Only valid if master is launched -v # verbose printing -w, --numworkers = # override number of worker threads -t, --timeout = # override the socket connection timeout (in seconds). --master-logger-level = # set logger level # ('debug', 'info', 'warn', 'error', 'fatal') See more in http://wiki.ros.org/roscore . 4.2. Rosnode \u2693\ufe0e rosnode is a command-line tool for printing information about ROS Nodes. Commands: rosnode ping # test connectivity to node rosnode list # list active nodes rosnode info # print information about node rosnode machine # list nodes running on a particular machine rosnode kill # kill a running node rosnode cleanup # purge registration information of unreachable nodes Type rosnode <command> -h for more detailed usage. 4.3. Rosrun \u2693\ufe0e The syntax for rosrun is: rosrun [ --prefix cmd ] [ --debug ] PACKAGE EXECUTABLE [ ARGS ] The tool rosrun will locate PACKAGE and try to find an executable named EXECUTABLE in the PACKAGE tree. If it finds it, it will run it with ARGS . Start with this guide, run the turtlesim_node in the turtlesim package: rosrun turtlesim turtlesim_node Turtle sim 5. ROS Topics \u2693\ufe0e Run turtle keyboard turtle_teleop_key node in a new terminal: rosrun turtlesim turtle_teleop_key After that, the turtle can be moved by using keyboard arrow keys. The turtlesim_node and the turtle_teleop_key node are communicating with each other over a ROS Topic. turtle_teleop_key is publishing the keystrokes on a topic, while turtlesim subscribes to the same topic to receive the keystrokes. 5.1. Rqt_graph \u2693\ufe0e The rqt_graph tool creates a dynamic graph of what\u2019s going on in the system. rqt_graph is part of the rqt package. sudo apt install -y ros-melodic-rqt && \\ sudo apt install -y ros-melodic-rqt-common-plugins Run rqt_graph in a new terminal: rosrun rqt_graph rqt_graph The turtlesim_node and the turtle_teleop_key nodes are communicating on the topic named /turtle1/command_vel . RosGraph 5.2. Rostopic \u2693\ufe0e The rostopic tool allows getting information about ROS topics. rostopic bw # display bandwidth used by topic rostopic echo # print messages to screen rostopic hz # display publishing rate of topic rostopic list # print information about active topics rostopic pub # publish data to topic rostopic type # print topic type 6. ROS Messages \u2693\ufe0e Communication on topics happens by sending ROS messages between nodes. For the publisher ( turtle_teleop_key ) and subscriber ( turtlesim_node ) to communicate, the publisher and subscriber must send and receive the same type of message. This means that a topic type is defined by the message type published on it. The type of the message sent on a topic can be determined using rostopic type. rostopic type /turtle1/cmd_vel geometry_msgs/Twist The command rosmsg show prints out the details of the message: rosmsg show geometry_msgs/Twist geometry_msgs/Vector3 linear float64 x float64 y float64 z geometry_msgs/Vector3 angular float64 x float64 y float64 z 6.1. Publish a message \u2693\ufe0e A message can be published through command line: rostopic pub [ topic ] [ msg_type ] [ args ] For example, to send one message on the topic /turtle1/cmd_vel using message type geometry_msgs/Twist and its required -- parameters '[2.0, 0.0, 0.0]' '[0.0, 0.0, 1.8]' , enter the below command: rostopic pub -1 \\ /turtle1/cmd_vel \\ geometry_msgs/Twist \\ -- '[2.0, 0.0, 0.0]' '[0.0, 0.0, 1.8]' To continuously send message at the rate of 1Hz, use -r 1 options: rostopic pub -r 1 \\ /turtle1/cmd_vel \\ geometry_msgs/Twist \\ -- '[2.0, 0.0, 0.0]' '[0.0, 0.0, -1.8]' The rate of message can be inspected by using the command rostopic hz : rostopic hz /turtle1/pose 6.2. Rqt_plot \u2693\ufe0e The rqt_plot tool displays a scrolling time plot of the data published on topics: rosrun rqt_plot rqt_plot In the new window that should pop up, a text box in the upper left corner gives the ability to add any topic to the plot. Typing /turtle1/pose/x will highlight the plus button, previously disabled. Press it and repeat the same procedure with the topic /turtle1/pose/y . Now the turtle\u2019s x-y location is plotted in the graph. RosPlot 7. ROS Services \u2693\ufe0e Services are another way that nodes can communicate with each other. Services allow nodes to send a request and receive a response . A rosservice can easily be attached to ROS\u2019s client/service framework with services. Commands that can be used on services are: rosservice list # print information about active services rosservice call # call the service with the provided args rosservice type # print service type rosservice find # find services by service type rosservice uri # print service ROSRPC uri Let\u2019s see current services: rosservice list /clear /kill /reset /rosout/get_loggers /rosout/set_logger_level /spawn /turtle1/set_pen /turtle1/teleport_absolute /turtle1/teleport_relative /turtlesim/get_loggers /turtlesim/set_logger_level Check the parameter of a service: rosservice type /clear std_srvs/Empty The /clear service shows an Empty parameter, but the /spawn has 4 parameter and returns string: rosservice type /spawn turtlesim/Spawn rosservice type /spawn | rossrv show float32 x float32 y float32 theta string name --- string name The input parameter are x , y , theta and name , and the output is name . Ok, let\u2019s clear the background and spawn a new turtle: rosservice call /clear && \\ rosservice call /spawn 2 2 0 .2 \"\" 7.1. Rosparam \u2693\ufe0e The rosparam tool allows storing and manipulate data on the ROS Parameter Server. The Parameter Server can store integers, floats, boolean, dictionaries, and lists. rosparam uses the YAML markup language for syntax. In simple cases, YAML looks very natural: 1 is an integer, 1.0 is a float, one is a string, true is a boolean, [1, 2, 3] is a list of integers, and {a: b, c: d} is a dictionary. rosparam has many commands that can be used on parameters, as shown below: rosparam set # set parameter rosparam get # get parameter rosparam load # load parameters from file rosparam dump # dump parameters to file rosparam delete # delete parameter rosparam list # list parameter names See the list of parameters: rosparam list /rosdistro /roslaunch/uris/host_ubuntu18__43509 /rosversion /run_id /turtlesim/background_b /turtlesim/background_g /turtlesim/background_r Here will change the red channel of the background color: rosparam set /turtlesim/background_r 150 Use get command to see the parameters: rosparam get / && \\ rosparam get /turtlesim/background_g dump and load option are also available: rosparam dump [ file_name ] [ namespace ] rosparam load [ file_name ] [ namespace ] For example: rosparam dump params.yaml will create a file params.yaml with the content similar to: rosdistro : \"melodic \" roslaunch : uris : { host_ubuntu18__43509 : \"http://ubuntu18:43509/\" } rosversion : \"1.14.11 \" run_id : 409b84fc-e2ff-11eb-be5c-080027b61567 turtlesim : { background_b : 255 , background_g : 86 , background_r : 150 } 8. ROS Console \u2693\ufe0e The command rqt_console attaches to ROS\u2019s logging framework to display output from nodes. rqt_logger_level allows to change the verbosity level ( DEBUG , WARN , INFO , and ERROR ) of nodes as they run. rosrun rqt_console rqt_console && \\ rosrun rqt_logger_level rqt_logger_level ROS Console and Logger Level Logging levels are prioritized in the following order: Fatal Error Warn Info Debug The Fatal level has the highest priority and Debug level has the lowest. By setting the logger level, logger will show all messages of that priority level or higher. For example, by setting the level to Warn , it will get all Warn , Error , and Fatal logging messages. 9. ROS Launch \u2693\ufe0e The roslaunch command starts nodes as defined in a launch file. roslaunch [ package ] [ filename.launch ] Starting with the beginner_tutorials package: cd catkin_ws && \\ source devel/setup.bash && \\ roscd beginner_tutorials vqtrong@ubuntu18:~/Work/catkin_ws/src/beginner_tutorials$ Then let\u2019s make a launch directory: mkdir launch && \\ cd launch Now let\u2019s create a launch file called turtlemimic.launch and paste the following: <launch> <group ns= \"turtlesim1\" > <node pkg= \"turtlesim\" name= \"sim\" type= \"turtlesim_node\" /> </group> <group ns= \"turtlesim2\" > <node pkg= \"turtlesim\" name= \"sim\" type= \"turtlesim_node\" /> </group> <node pkg= \"turtlesim\" name= \"mimic\" type= \"mimic\" > <remap from= \"input\" to= \"turtlesim1/turtle1\" /> <remap from= \"output\" to= \"turtlesim2/turtle1\" /> </node> </launch> Notes: Two groups with a namespace tag of turtlesim1 and turtlesim2 are created from a turtlesim node with a name of sim . This allows to start two simulators without having name conflicts. The mimic node with the topics input and output remapped to turtlesim1 and turtlesim2 . This renaming will cause turtlesim2 to mimic turtlesim1 . 9.1. Roslaunch \u2693\ufe0e Start the launch file: roslaunch beginner_tutorials turtlemimic.launch And post messages to the first turtle: rostopic pub /turtlesim1/turtle1/cmd_vel geometry_msgs/Twist -r 1 -- '[2.0, 0.0, 0.0]' '[0.0, 0.0, -1.8]' Run the rqt_graph to see what is going on: rqt_graph Turtle mimic nodes graph 10. Create ROS msg and srv \u2693\ufe0e The msg files are simple text files that describe the fields of a ROS message. They are used to generating source code for messages in different languages. The msg files are stored in the msg directory of a package The field types include: int8 , int16 , int32 , int64 float32 , float64 string time , duration other msg files variable-length array[] and fixed-length array[x] There is also a special type in ROS: Header , the header contains a timestamp and coordinate frame information that are commonly used in ROS. Here is an example of a msg that uses a Header , a string primitive, and two other messages : Header header string child_frame_id geometry_msgs/PoseWithCovariance pose geometry_msgs/TwistWithCovariance twist The srv file describes a service. It is composed of two parts: a request and a response, and srv files are stored in the srv directory. The two parts are separated by a \u2018\u2014\u2018 line. Here is an example of a srv file: int64 A int64 B --- int64 Sum In the above example, A and B are the request, and Sum is the response. 10.1. Create a msg \u2693\ufe0e Let\u2019s define a new msg in the beginner_tutorials package: roscd beginner_tutorials && \\ mkdir msg && \\ echo \"int64 num\" > msg/Num.msg Using rosmsg to see a message definition: rosmsg show beginner_tutorials/Num 10.2. Creating a srv \u2693\ufe0e Let\u2019s define a new msg in the beginner_tutorials package: roscd beginner_tutorials && \\ mkdir srv && \\ touch srv/AddTwoInts.srv The file content: AddTwoInts.srv int64 a int64 b --- int64 sum Using rossrv to see a service definition: rossrv show beginner_tutorials/AddTwoInts 10.3. Generate msg and srv \u2693\ufe0e To make sure that the msg files are turned into source code for C++, Python, and other languages, open package.xml , and make sure these two lines are in it: package.xml <build_depend> message_generation </build_depend> <exec_depend> message_runtime </exec_depend> and then add these packages into the CMakeLists.txt file: CMakeLists.txt find_package ( catkin REQUIRED COMPONENTS roscpp rospy std_msgs message_generation ) ## Generate messages in the 'msg' folder add_message_files ( FILES Num.msg ) ## Generate services in the 'srv' folder add_service_files ( FILES AddTwoInts.srv ) ## Generate added messages and services with any dependencies listed here generate_messages ( DEPENDENCIES std_msgs ) make the package again: roscd beginner_tutorials && \\ cd ../.. && \\ catkin_make && \\ cd - Any .msg file in the msg directory will generate code for use in all supported languages: The C++ message header file will be generated in catkin_ws/devel/include/beginner_tutorials/ . The Python script will be created in catkin_ws/devel/lib/python2.7/dist-packages/beginner_tutorials/msg . The lisp file appears in catkin_ws/devel/share/common-lisp/ros/beginner_tutorials/msg/ . Similarly, any .srv files in the srv directory will have generated code in supported languages. For C++, this will generate header files in the same directory as the messages. For Python and Lisp, there will be a srv folder beside the msg folders. Here are the generated files: devel/include/beginner_tutorials/Num.h devel/include/beginner_tutorials/AddTwoInts.h Let\u2019s see what was generated! In the Num.h header file: Create a namespace based on the package name namespace beginner_tutorials {} Use a template of an Allocator to create a new Num type: template < class ContainerAllocator > struct Num_ { typedef Num_ < ContainerAllocator > Type ; // constructor Num_ () : num ( 0 ) { } Num_ ( const ContainerAllocator & _alloc ) : num ( 0 ) { ( void ) _alloc ; } // members typedef int64_t _num_type ; _num_type num ; // define new type of pointer typedef boost :: shared_ptr < :: beginner_tutorials :: Num_ < ContainerAllocator > > Ptr ; typedef boost :: shared_ptr < :: beginner_tutorials :: Num_ < ContainerAllocator > const > ConstPtr ; }; // struct Num_ Create new pointer types of this new Num type typedef :: beginner_tutorials :: Num_ < std :: allocator < void > > Num ; typedef boost :: shared_ptr < :: beginner_tutorials :: Num > NumPtr ; typedef boost :: shared_ptr < :: beginner_tutorials :: Num const > NumConstPtr ; Noted that ROS uses shared_ptr to manage the memory, that will prevent any memory leak issue. Create friendly operations template < class ContainerAllocator > struct Printer < :: beginner_tutorials :: Num_ < ContainerAllocator > > { template < typename Stream > static void stream ( Stream & s , const std :: string & indent , const :: beginner_tutorials :: Num_ < ContainerAllocator >& v ) { s << indent << \"num: \" ; Printer < int64_t >:: stream ( s , indent + \" \" , v . num ); } }; template < typename ContainerAllocator > std :: ostream & operator << ( std :: ostream & s , const :: beginner_tutorials :: Num_ < ContainerAllocator > & v ) { ros :: message_operations :: Printer < :: beginner_tutorials :: Num_ < ContainerAllocator > > :: stream ( s , \"\" , v ); return s ; } template < typename ContainerAllocator1 , typename ContainerAllocator2 > bool operator == ( const :: beginner_tutorials :: Num_ < ContainerAllocator1 > & lhs , const :: beginner_tutorials :: Num_ < ContainerAllocator2 > & rhs ) { return lhs . num == rhs . num ; } template < typename ContainerAllocator1 , typename ContainerAllocator2 > bool operator != ( const :: beginner_tutorials :: Num_ < ContainerAllocator1 > & lhs , const :: beginner_tutorials :: Num_ < ContainerAllocator2 > & rhs ) { return ! ( lhs == rhs ); } Metadata which will be used by ROS to show object\u2019s information template < class ContainerAllocator > struct IsFixedSize < :: beginner_tutorials :: Num_ < ContainerAllocator > > : TrueType { }; template < class ContainerAllocator > struct IsFixedSize < :: beginner_tutorials :: Num_ < ContainerAllocator > const > : TrueType { }; template < class ContainerAllocator > struct IsMessage < :: beginner_tutorials :: Num_ < ContainerAllocator > > : TrueType { }; template < class ContainerAllocator > struct IsMessage < :: beginner_tutorials :: Num_ < ContainerAllocator > const > : TrueType { }; template < class ContainerAllocator > struct HasHeader < :: beginner_tutorials :: Num_ < ContainerAllocator > > : FalseType { }; template < class ContainerAllocator > struct HasHeader < :: beginner_tutorials :: Num_ < ContainerAllocator > const > : FalseType { }; template < class ContainerAllocator > struct MD5Sum < :: beginner_tutorials :: Num_ < ContainerAllocator > > { static const char * value () { return \"57d3c40ec3ac3754af76a83e6e73127a\" ; } static const char * value ( const :: beginner_tutorials :: Num_ < ContainerAllocator >& ) { return value (); } static const uint64_t static_value1 = 0x57d3c40ec3ac3754ULL ; static const uint64_t static_value2 = 0xaf76a83e6e73127aULL ; }; template < class ContainerAllocator > struct DataType < :: beginner_tutorials :: Num_ < ContainerAllocator > > { static const char * value () { return \"beginner_tutorials/Num\" ; } static const char * value ( const :: beginner_tutorials :: Num_ < ContainerAllocator >& ) { return value (); } }; template < class ContainerAllocator > struct Definition < :: beginner_tutorials :: Num_ < ContainerAllocator > > { static const char * value () { return \"int64 num \\n \" ; } static const char * value ( const :: beginner_tutorials :: Num_ < ContainerAllocator >& ) { return value (); } }; 11. Publisher and Subscriber (C++) \u2693\ufe0e Go to the source code folder of the beginner_tutorials package: roscd beginner_tutorials && \\ mkdir src && \\ cd src 11.1. A Publisher Node \u2693\ufe0e This tutorial demonstrates simple sending of messages over the ROS system. nano talker.cpp src/talker.cpp #include \"ros/ros.h\" #include \"std_msgs/String.h\" #include <sstream> int main ( int argc , char ** argv ) { // init with a name ros :: init ( argc , argv , \"talker\" ); // create a node ros :: NodeHandle n ; // publish on a the `chatter` topic, queue = 1000 ros :: Publisher chatter_pub = n . advertise < std_msgs :: String > ( \"chatter\" , 1000 ); // publishing rate 1 Hz ros :: Rate loop_rate ( 1 ); // main loop int count = 0 ; while ( ros :: ok ()) { // message std_msgs :: String msg ; // content std :: stringstream ss ; ss << \"hello world \" << count ++ ; msg . data = ss . str (); ROS_INFO ( \"%s\" , msg . data . c_str ()); // publish chatter_pub . publish ( msg ); // check status ros :: spinOnce (); // sleep loop_rate . sleep (); } return 0 ; } 11.2. A Subscriber Node \u2693\ufe0e This tutorial demonstrates simple receipt of messages over the ROS system. nano listener.cpp src/listener.cpp #include \"ros/ros.h\" #include \"std_msgs/String.h\" void chatterCallback ( const std_msgs :: String :: ConstPtr & msg ) { ROS_INFO ( \"I heard: [%s]\" , msg -> data . c_str ()); } int main ( int argc , char ** argv ) { // init with a name ros :: init ( argc , argv , \"listener\" ); // create a node ros :: NodeHandle n ; // subscribe on a the `chatter` topic, queue = 1000 // execute chatterCallback on receive ros :: Subscriber sub = n . subscribe ( \"chatter\" , 1000 , chatterCallback ); // main loop ros :: spin (); return 0 ; } 11.3. Building new nodes \u2693\ufe0e Add the source code files which need to be compiled into the CMakeLists.txt . With all dependency packages listed above, add below lines also: cd .. && \\ nano CMakeLists.txt CMakeLists.txt ## Declare a C++ executable add_executable ( talker src/talker.cpp ) target_link_libraries ( talker ${ catkin_LIBRARIES } ) add_dependencies ( talker beginner_tutorials_generate_messages_cpp ) add_executable ( listener src/listener.cpp ) target_link_libraries ( listener ${ catkin_LIBRARIES } ) add_dependencies ( listener beginner_tutorials_generate_messages_cpp ) This will create two executables, talker and listener, which by default will go into package directory in devel space, located by default at catkin_ws/devel/lib/<package name> . Finally, make the package again: roscd beginner_tutorials && \\ cd ../.. && \\ catkin_make && \\ cd - 11.4. Run new nodes \u2693\ufe0e Run roscore first if it is not running. Then run 2 new nodes in two terminals: rosrun beginner_tutorials talker rosrun beginner_tutorials listener Talker and Listener 12. Publisher and Subscriber (Python) \u2693\ufe0e Go to the scripts\u2019 folder of the beginner_tutorials package: roscd beginner_tutorials && \\ mkdir scripts && \\ cd scripts 12.1. A Publisher Node \u2693\ufe0e This tutorial demonstrates simple sending of messages over the ROS system. nano talker.py Note that a node is created from a publisher, in contrast to C++ implementation, a publisher is created from a node. In ROS, nodes are uniquely named. If two nodes with the same name are launched, the previous one is kicked off. The anonymous=True flag means that rospy will choose a unique name for a new listener node so that multiple listeners can run simultaneously. scripts/talker.py #!/usr/bin/env python import rospy from std_msgs.msg import String def talker (): # create a publisher, on topic `chatter` pub = rospy . Publisher ( 'chatter' , String , queue_size = 10 ) # create a node rospy . init_node ( 'talker' , anonymous = True ) # set the rate of publishing rate = rospy . Rate ( 1 ) # 1hz # main loop while not rospy . is_shutdown (): # make content hello_str = \"hello world %s \" % rospy . get_time () rospy . loginfo ( hello_str ) # publish a message pub . publish ( hello_str ) rate . sleep () if __name__ == '__main__' : try : talker () except rospy . ROSInterruptException : pass 12.2. A Subscriber Node \u2693\ufe0e This tutorial demonstrates simple receipt of messages over the ROS system. nano listener.py scripts/listener.py #!/usr/bin/env python import rospy from std_msgs.msg import String def callback ( data ): rospy . loginfo ( rospy . get_caller_id () + \"I heard %s \" , data . data ) def listener (): # create a node rospy . init_node ( 'listener' , anonymous = True ) # create a subcriber rospy . Subscriber ( \"chatter\" , String , callback ) # spin() simply keeps python from exiting until this node is stopped rospy . spin () if __name__ == '__main__' : listener () rospy.spin() simply keeps the node from exiting until the node has been shutdown. Unlike roscpp, rospy.spin() does not affect the subscriber callback functions, as those have their own threads. 12.3. Make script executable \u2693\ufe0e Scripts need to get execution permission before they can run: scripts chmod +x * 12.4. Building new nodes \u2693\ufe0e Add the source code files which need to be compiled into the CMakeLists.txt . With all dependency packages listed above, add below lines also: cd .. && \\ nano CMakeLists.txt CMakeLists.txt catkin_install_python ( PROGRAMS scripts/talker.py scripts/listener.py DESTINATION ${ CATKIN_PACKAGE_BIN_DESTINATION } ) Finally, make the package again: roscd beginner_tutorials && \\ cd ../.. && \\ catkin_make && \\ cd - 12.5. Run new nodes \u2693\ufe0e Run roscore first if it is not running. Then run 2 new nodes in two terminals: rosrun beginner_tutorials talker.py rosrun beginner_tutorials listener.py Python script execution If the error /usr/bin/env: \u2018python \\r \u2019: No such file or directory shows up, it is because of the ending line characters. Unix use LF only while Windows use CRLF . Save python scripts in Unix ending character only. 13. Service and Client (C++) \u2693\ufe0e Go to the source code folder of the beginner_tutorials package: roscd beginner_tutorials && \\ mkdir src && \\ cd src 13.1. A Service Node \u2693\ufe0e This guide will create the service add_two_ints_server node which will receive two ints and return the sum. This service uses the beginner_tutorials/AddTwoInts.h header file generated from the srv file that is created earlier. nano add_two_ints_server.cpp src/add_two_ints_server.cpp #include \"ros/ros.h\" #include \"beginner_tutorials/AddTwoInts.h\" // service fuction bool add ( beginner_tutorials :: AddTwoInts :: Request & req , beginner_tutorials :: AddTwoInts :: Response & res ) { res . sum = req . a + req . b ; ROS_INFO ( \"request: x=%ld, y=%ld\" , ( long int ) req . a , ( long int ) req . b ); ROS_INFO ( \"sending back response: [%ld]\" , ( long int ) res . sum ); return true ; } int main ( int argc , char ** argv ) { ros :: init ( argc , argv , \"add_two_ints_server\" ); // create a node ros :: NodeHandle n ; // node will have a service ros :: ServiceServer service = n . advertiseService ( \"add_two_ints\" , add ); ROS_INFO ( \"Ready to add two ints.\" ); // main loop ros :: spin (); return 0 ; } 13.2. A Client Node \u2693\ufe0e This guide will create the service add_two_ints_client node which will receive two ints and return the sum. nano add_two_ints_client.cpp src/add_two_ints_client.cpp #include \"ros/ros.h\" #include \"beginner_tutorials/AddTwoInts.h\" #include <cstdlib> int main ( int argc , char ** argv ) { // check args ros :: init ( argc , argv , \"add_two_ints_client\" ); if ( argc != 3 ) { ROS_INFO ( \"usage: add_two_ints_client X Y\" ); return 1 ; } // create a node ros :: NodeHandle n ; // node will have a client ros :: ServiceClient client = n . serviceClient < beginner_tutorials :: AddTwoInts > ( \"add_two_ints\" ); // create a service target beginner_tutorials :: AddTwoInts srv ; // add params srv . request . a = atoll ( argv [ 1 ]); srv . request . b = atoll ( argv [ 2 ]); // call to service if ( client . call ( srv )) { ROS_INFO ( \"Sum: %ld\" , ( long int ) srv . response . sum ); } else { ROS_ERROR ( \"Failed to call service add_two_ints\" ); return 1 ; } return 0 ; } 13.3. Building new nodes \u2693\ufe0e Add the source code files which need to be compiled into the CMakeLists.txt . With all dependency packages listed above, add below lines also: cd .. && \\ nano CMakeLists.txt CMakeLists.txt ## Declare a C++ executable add_executable ( add_two_ints_server src/add_two_ints_server.cpp ) target_link_libraries ( add_two_ints_server ${ catkin_LIBRARIES } ) add_dependencies ( add_two_ints_server beginner_tutorials_gencpp ) add_executable ( add_two_ints_client src/add_two_ints_client.cpp ) target_link_libraries ( add_two_ints_client ${ catkin_LIBRARIES } ) add_dependencies ( add_two_ints_client beginner_tutorials_gencpp ) This will create two executables, add_two_ints_server and add_two_ints_client, which by default will go into package directory in devel space, located by default at catkin_ws/devel/lib/<package name> . Finally, make the package again: roscd beginner_tutorials && \\ cd ../.. && \\ catkin_make && \\ cd - 13.4. Run new nodes \u2693\ufe0e Run roscore first if it is not running. Then run 2 new nodes in two terminals: rosrun beginner_tutorials add_two_ints_server rosrun beginner_tutorials add_two_ints_client 1 2 Service and Client 14. Service and Client (Python) \u2693\ufe0e Go to the source code folder of the beginner_tutorials package: roscd beginner_tutorials && \\ mkdir scripts && \\ cd scripts && \\ 14.1. A Service Node \u2693\ufe0e This guide will create the service add_two_ints_server node which will receive two ints and return the sum. This service uses the beginner_tutorials/AddTwoInts.h header file generated from the srv file that is created earlier. nano add_two_ints_server.py scripts/add_two_ints_server.py #!/usr/bin/env python from __future__ import print_function from beginner_tutorials.srv import AddTwoInts , AddTwoIntsResponse import rospy def handle_add_two_ints ( req ): print ( \"Returning [ %s + %s = %s ]\" % ( req . a , req . b , ( req . a + req . b ))) return AddTwoIntsResponse ( req . a + req . b ) def add_two_ints_server (): rospy . init_node ( 'add_two_ints_server' ) s = rospy . Service ( 'add_two_ints' , AddTwoInts , handle_add_two_ints ) print ( \"Ready to add two ints.\" ) rospy . spin () if __name__ == \"__main__\" : add_two_ints_server () 14.2. A Client Node \u2693\ufe0e This guide will create the service add_two_ints_client node which will receive two ints and return the sum. nano add_two_ints_client.py scripts/add_two_ints_client.py #!/usr/bin/env python from __future__ import print_function import sys import rospy from beginner_tutorials.srv import * def add_two_ints_client ( x , y ): rospy . wait_for_service ( 'add_two_ints' ) try : add_two_ints = rospy . ServiceProxy ( 'add_two_ints' , AddTwoInts ) resp1 = add_two_ints ( x , y ) return resp1 . sum except rospy . ServiceException as e : print ( \"Service call failed: %s \" % e ) def usage (): return \" %s [x y]\" % sys . argv [ 0 ] if __name__ == \"__main__\" : if len ( sys . argv ) == 3 : x = int ( sys . argv [ 1 ]) y = int ( sys . argv [ 2 ]) else : print ( usage ()) sys . exit ( 1 ) print ( \"Requesting %s + %s \" % ( x , y )) print ( \" %s + %s = %s \" % ( x , y , add_two_ints_client ( x , y ))) 14.3. Make scripts executable \u2693\ufe0e Scripts need to get execution permission before they can run: chmod +x * 14.4. Building new nodes \u2693\ufe0e Add the source code files which need to be compiled into the CMakeLists.txt . With all dependency packages listed above, add below lines also: cd .. && \\ nano CMakeLists.txt CMakeLists.txt catkin_install_python ( PROGRAMS scripts/add_two_ints_server.py scripts/add_two_ints_client.py DESTINATION ${ CATKIN_PACKAGE_BIN_DESTINATION } ) This will create two executables, add_two_ints_server and add_two_ints_client, which by default will go into package directory in devel space, located by default at catkin_ws/devel/lib/<package name> . Finally, make the package again: roscd beginner_tutorials && \\ cd ../.. && \\ catkin_make && \\ cd - 14.5. Run new nodes \u2693\ufe0e Run roscore first if it is not running. Then run 2 new nodes in two terminals: rosrun beginner_tutorials add_two_ints_server.py rosrun beginner_tutorials add_two_ints_client.py 1 3 15. Playback data \u2693\ufe0e This tutorial will teach how to record data from a running ROS system into a .bag file, and then to play back the data to produce similar behavior in a running system. 15.1. Record data \u2693\ufe0e First, execute the following commands in separate terminals: Terminal 1: roscore Terminal 2: rosrun turtlesim turtlesim_node Terminal 3: rosrun turtlesim turtle_teleop_key This will start two nodes \u2014 the turtlesim visualizer and a node that allows for the keyboard control of turtlesim using the arrows keys on the keyboard. Let\u2019s examine the full list of topics that are currently being published in the running system. To do this, open a new terminal and execute the command: rostopic list -v Published topics: * /turtle1/color_sensor [ turtlesim/Color ] 1 publisher * /turtle1/cmd_vel [ geometry_msgs/Twist ] 1 publisher * /rosout [ rosgraph_msgs/Log ] 2 publishers * /rosout_agg [ rosgraph_msgs/Log ] 1 publisher * /turtle1/pose [ turtlesim/Pose ] 1 publisher Subscribed topics: * /turtle1/cmd_vel [ geometry_msgs/Twist ] 1 subscriber * /rosout [ rosgraph_msgs/Log ] 1 subscriber The list of published topics is the only message types that could potentially be recorded in the data log file, as only published messages are recorded: The topic /turtle1/cmd_vel is the command message published by the teleop_turtle node that is taken as input by the turtlesim process. The messages /turtle1/color_sensor and /turtle1/pose are output messages published by turtlesim . Open a new terminal window. In this window run the following commands. Running rosbag record with the option -a indicates that all published topics should be accumulated in a bag file. roscd beginner_tutorials && \\ mkdir bagfiles && \\ cd bagfiles && \\ rosbag record -a [ INFO] [1626862434.586239631]: Recording to '2021-07-21-17-13-54.bag'. [ INFO] [1626862434.587320465]: Subscribing to /turtle1/color_sensor [ INFO] [1626862434.589356574]: Subscribing to /turtle1/cmd_vel [ INFO] [1626862434.591447646]: Subscribing to /rosout [ INFO] [1626862434.593544025]: Subscribing to /rosout_agg [ INFO] [1626862434.595557444]: Subscribing to /turtle1/pose Move back to the terminal window with turtle_teleop and move the turtle around for 10 or so seconds. 15.2. Rosbag info \u2693\ufe0e Run the command rosbag info to see the info of a rosbag file: rosbag info <bagfile> path: xxx.bag version: 2 .0 duration: 2 :21s ( 141s ) start: xxx end: xxx size: 1 .3 MB messages: 18150 compression: none [ 2 /2 chunks ] types: geometry_msgs/Twist [ 9f195f881246fdfa2798d1d3eebca84a ] rosgraph_msgs/Log [ acffd30cd6b6de30f120938c17c593fb ] turtlesim/Color [ 353891e354491c51aabe32df673fb446 ] turtlesim/Pose [ 863b248d5016ca62ea2e895ae5265cf9 ] topics: /rosout 217 msgs : rosgraph_msgs/Log ( 2 connections ) /rosout_agg 214 msgs : rosgraph_msgs/Log /turtle1/cmd_vel 286 msgs : geometry_msgs/Twist /turtle1/color_sensor 8716 msgs : turtlesim/Color /turtle1/pose 8717 msgs : turtlesim/Pose 15.3. Rosbag play \u2693\ufe0e The next step in this tutorial is to replay the bag file to reproduce behavior in the running system. First kill the tele-operator program that may be still running from the previous section. Leave turtlesim running. In a terminal window run the following command: rosbag play <bagfile> In its default mode rosbag play will wait for a certain period (.2 seconds) after advertising each message before it actually begins publishing the contents of the bag file. Waiting for some duration allows any subscriber of a message to be alerted that the message has been advertised and that messages may follow. If rosbag play publishes messages immediately upon advertising, subscribers may not receive the first several published messages. The waiting period can be specified with the -d option. 15.4. Recording a subset \u2693\ufe0e When running a complicated system, such as the pr2 software suite, there may be hundreds of topics being published, with some topics, like camera image streams, potentially publishing huge amounts of data. In such a system it is often impractical to write log files consisting of all topics to disk in a single bag file. The rosbag record command supports logging only particular topics to a bag file, allowing users to only record the topics of interest to them. rosbag record -O subset /turtle1/cmd_vel /turtle1/pose The -O argument tells rosbag record to log to a file named subset.bag , and the topic arguments cause rosbag record to only subscribe to these two topics. The limitations of rosbag record/play Different start condition can cause different results even the events are the same. The rate of recorded events is not guaranteed to be the same as the real actions. 16. Read message from Rosbag \u2693\ufe0e The script ros_readbagfile will read rosbag file and extract all messages of selected topics: ros_readbagfile <mybagfile.bag> [ info ] [ N ] [ topic1 ] [ topic2 ] [ ... ] Download and install ros_readbag.py using below command: cd ~ && \\ wget https://raw.githubusercontent.com/vuquangtrong/ \\ ros_readbagfile/main/ros_readbagfile Edit shebang to use python 2 if needed. Change #!/usr/bin/python3 to #!/usr/bin/python . Make it executable: chmod +x ros_readbagfile The ~/bin directory for personal binaries: mkdir -p ~/bin Add this folder to the PATH : echo \"PATH=\\\" $PATH :~/bin\\\"\" >> ~/.bashrc Move this executable script into that directory as ros_readbagfile , so that it will be available as that command: mv ros_readbagfile ~/bin/ros_readbagfile Usage See the information of the input bag file: ros_readbagfile mybagfile.bag info Print all messages of all topics in the bag file to the screen: ros_readbagfile mybagfile.bag Print all messages of the topic /test in the bag file to the screen: ros_readbagfile mybagfile.bag /test Print at most N first messages of all topics in the bag file to the screen: ros_readbagfile mybagfile.bag N Print at most N first messages of the topic /test in the bag file to the screen: ros_readbagfile mybagfile.bag N /test To save the output to a file, use redirection syntax: ros_readbagfile mybagfile.bag N /test > output.txt Determine the exact topic names you\u2019d like to read from the bag file, by using rosbag info as mentioned above, or use ros_readbagfile info command: Use ros_readbagfile from terminal as below: rosbag info 2021 -07-21-17-13-54.bag path: 2021-07-21-17-13-54.bag version: 2.0 duration: 30.8s start: Jul 21 2021 17:13:54.60 (1626862434.60) end: Jul 21 2021 17:14:25.40 (1626862465.40) size: 280.8 KB messages: 3895 compression: none [1/1 chunks] types: geometry_msgs/Twist [9f195f881246fdfa2798d1d3eebca84a] rosgraph_msgs/Log [acffd30cd6b6de30f120938c17c593fb] turtlesim/Color [353891e354491c51aabe32df673fb446] turtlesim/Pose [863b248d5016ca62ea2e895ae5265cf9] topics: /rosout 4 msgs : rosgraph_msgs/Log (2 connections) /turtle1/cmd_vel 93 msgs : geometry_msgs/Twist /turtle1/color_sensor 1899 msgs : turtlesim/Color /turtle1/pose 1899 msgs : turtlesim/Pose Now, get all messages of the topic /turtle1/pose and save to the file: ros_readbagfile 2021 -07-21-17-13-54.bag /turtle1/pose > turtle1_pose.yaml # ======================================= # topic: /turtle1/pose # msg_count: 1899 # timestamp (sec): 1626862465.397807837 # - - - x: 10.0430784225 y: 6.37491464615 theta: -2.62400007248 linear_velocity: 0.0 angular_velocity: 0.0 # ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ # Total messages found: 1899 # # /turtle1/pose: 1899 # # DONE. # ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ 17. Reference \u2693\ufe0e There is an interesting book named A Gentle Introduction to ROS by Jason M. O\u2019Kane published on https://cse.sc.edu/~jokane/agitr/ . This book supplements ROS\u2019s own documentation, explaining how to interact with existing ROS systems and how to create new ROS programs using C++, with special attention to common mistakes and misunderstandings. An excerpt from the book: Giving ROS control The final complication is that ROS will only execute our callback function when we give it explicit permission to do so. There are actually two slightly different ways to accomplish this. One version looks like this: ros :: spinOnce (); This code asks ROS to execute all of the pending callbacks from all of the node\u2019s subscriptions, and then return control back to us. The other option looks like this: ros :: spin (); This alternative to ros::spinOnce() asks ROS to wait for and execute callbacks until the node shuts down. In other words, ros::spin() is roughly equivalent to this loop: while ( ros :: ok ()) { ros :: spinOnce (); } The question of whether to use ros::spinOnce() or ros::spin() comes down to this: Does your program have any repetitive work to do, other than responding to callbacks? If the answer is No , then use ros::spin() . If the answer is Yes , then a reasonable option is to write a loop that does that other work and calls ros::spinOnce() periodically to process callbacks. A common error in subscriber programs is to mistakenly omit both ros::spinOnce() and ros::spin() . In this case, ROS never has an opportunity to execute your callback function. Omitting ros::spin() will likely cause your program to exit shortly after it starts. Omitting ros::spinOnce() might make it appear as though no messages are being received.","title":"Tutorial for Beginners"},{"location":"blog/ros/tutorial-beginner/#1-install-ros","text":"There is more than one ROS distribution supported at a time. Some are older releases with long term support, making them more stable, while others are newer with shorter support life times, but with binaries for more recent platforms and more recent versions of the ROS packages that make them up. Recommend ones of the versions below: ROS Melodic Morenia Released May, 2018 LTS until May, 2023 Recommended for Ubuntu 18.04 ROS Noetic Ninjemys Released May, 2020 LTS until May, 2025 Recommended for Ubuntu 20.04 What is the difference between ROS Melodic model and Noetic model? There aren\u2019t many differences at the base level. The ROS Noetic is recommended for Ubuntu 20.04 whereas ROS Melodic for Ubuntu 18.04: Feature ROS Noetic ROS Melodic Python 3.8 2.7 Gazebo 11.x 9.0 OpenCV 4.2 3.2 Detailed comparison is at repositories.ros.org . Choose the ROS version based on the installed OS. Here, Melodic is used on Ubuntu 18.04 .","title":"1. Install ROS"},{"location":"blog/ros/tutorial-beginner/#11-configure-repositories","text":"Configure the Ubuntu repositories to allow \u201crestricted,\u201d \u201cuniverse,\u201d and \u201cmultiverse\u201d by following the Ubuntu guide . Setup source list to get ROS packages: sudo sh -c 'echo \"deb http://packages.ros.org/ros/ubuntu $(lsb_release -sc) main\" > /etc/apt/sources.list.d/ros-latest.list' Add keys: sudo apt install -y curl && \\ curl -s https://raw.githubusercontent.com/ros/rosdistro/master/ros.asc | sudo apt-key add - Then pull the package list: sudo apt update Finally, install a desktop-full package as recommended to start learning: sudo apt install -y ros-melodic-desktop-full && \\ sudo apt install -y ros-melodic-rqt && \\ sudo apt install -y ros-melodic-rqt-common-plugins It\u2019s convenient if the ROS environment variables are automatically added to a bash session every time a new shell is launched: echo \"source /opt/ros/melodic/setup.bash\" >> ~/.bashrc && \\ source ~/.bashrc A good way to check the installation is to ensure that environment variables like ROS_ROOT and ROS_PACKAGE_PATH are set: printenv | grep ROS ROS_ETC_DIR = /opt/ros/melodic/etc/ros ROS_ROOT = /opt/ros/melodic/share/ros ROS_MASTER_URI = http://localhost:11311 ROS_VERSION = 1 ROS_PYTHON_VERSION = 2 ROS_PACKAGE_PATH = /opt/ros/melodic/share ROSLISP_PACKAGE_DIRECTORIES = ROS_DISTRO = melodic","title":"1.1. Configure repositories"},{"location":"blog/ros/tutorial-beginner/#12-build-packages","text":"Build packages are needed for code compilation. sudo apt install -y python-rosdep python-rosinstall python-rosinstall-generator python-wstool build-essential Initialize the package rosdep to track package dependency: sudo rosdep init && \\ rosdep update","title":"1.2. Build packages"},{"location":"blog/ros/tutorial-beginner/#2-ros-workspace","text":"A catkin workspace is a folder where to modify, build, and install catkin packages. The catkin_make command is a convenience tool for working with catkin workspaces. Running it the first time in a workspace, it will create a CMakeLists.txt link in the \u2018src\u2019 folder. mkdir -p catkin_ws/src && \\ cd catkin_ws && \\ catkin_make In the current directory, it should now have a build and devel folder. Inside the devel folder, there are now several setup.*sh files. Sourcing any of these files will overlay this workspace on top of current environment. source devel/setup.bash To make sure workspace is properly overlaid by the setup script, make sure ROS_PACKAGE_PATH environment variable includes the current workspace directory. echo $ROS_PACKAGE_PATH /home/vqtrong/Work/catkin_ws/src:/opt/ros/melodic/share This also helps ROS to find new packages.","title":"2. ROS Workspace"},{"location":"blog/ros/tutorial-beginner/#21-the-ros-file-system","text":"For this tutorial, to inspect a package in ros-tutorials, please install a prebuilt package using: sudo apt install -y ros-melodic-ros-tutorials Two main concepts of the File Systems: Packages are the software organization unit of ROS code. Each package can contain libraries, executables, scripts, or other artifacts. Manifests (package.xml) is a description of a package. It serves to define dependencies between packages and to capture meta information about the package like version, maintainer, license, etc\u2026 Code is spread across many ROS packages. Navigating with command-line tools such as ls and cd can be very tedious which is why ROS provides tools to help.","title":"2.1. The ROS File system"},{"location":"blog/ros/tutorial-beginner/#22-file-system-tools","text":"rospack allows getting information about packages. rospack find roscpp roscd allows changing directory ( cd ) directly to a package, and also is able to move to a subdirectory of a package roscd roscpp # go to cpp package roscd roscpp/cmake # go to cmake folder inside the cpp package roscd log # go to the log folder, available after run roscore","title":"2.2. File system Tools"},{"location":"blog/ros/tutorial-beginner/#3-create-a-ros-package","text":"Firstly, use the catkin_create_pkg script to create a new package called beginner_tutorials which depends on std_msgs , roscpp , and rospy : catkin_ws/ cd src && \\ catkin_create_pkg beginner_tutorials std_msgs rospy roscpp This will create a beginner_tutorials folder which contains a package.xml and a CMakeLists.txt , which have been partially filled out with the information given in the catkin_create_pkg command. Build that new workspace again to see beginner_tutorials is added into build folder: catkin_ws/src cd .. && \\ catkin_make Add the workspace to the ROS environment: source devel/setup.bash To check the direct dependencies of a package: rospack depends1 beginner_tutorials To check the indirect dependencies of a package: rospack depends beginner_tutorials","title":"3. Create a ROS Package"},{"location":"blog/ros/tutorial-beginner/#4-ros-nodes","text":"Quick overview of Graph Concepts: Nodes : A node is an executable that uses ROS to communicate with other nodes. Messages : ROS data type used when subscribing or publishing to a topic. Topics : Nodes can publish messages to a topic as well as subscribe to a topic to receive messages. Master : Name service for ROS (i.e. helps nodes find each other) Rosout : ROS equivalent of stdout/stderr Roscore : Master + Rosout + Ros parameter server (parameter server will be introduced later)","title":"4. ROS Nodes"},{"location":"blog/ros/tutorial-beginner/#41-roscore","text":"roscore will start up a ROS Master, a ROS Parameter Server and a Rosout logging node Options: -h, --help # show this help message and exit -p, --port = # master port. Only valid if master is launched -v # verbose printing -w, --numworkers = # override number of worker threads -t, --timeout = # override the socket connection timeout (in seconds). --master-logger-level = # set logger level # ('debug', 'info', 'warn', 'error', 'fatal') See more in http://wiki.ros.org/roscore .","title":"4.1. Roscore"},{"location":"blog/ros/tutorial-beginner/#42-rosnode","text":"rosnode is a command-line tool for printing information about ROS Nodes. Commands: rosnode ping # test connectivity to node rosnode list # list active nodes rosnode info # print information about node rosnode machine # list nodes running on a particular machine rosnode kill # kill a running node rosnode cleanup # purge registration information of unreachable nodes Type rosnode <command> -h for more detailed usage.","title":"4.2. Rosnode"},{"location":"blog/ros/tutorial-beginner/#43-rosrun","text":"The syntax for rosrun is: rosrun [ --prefix cmd ] [ --debug ] PACKAGE EXECUTABLE [ ARGS ] The tool rosrun will locate PACKAGE and try to find an executable named EXECUTABLE in the PACKAGE tree. If it finds it, it will run it with ARGS . Start with this guide, run the turtlesim_node in the turtlesim package: rosrun turtlesim turtlesim_node Turtle sim","title":"4.3. Rosrun"},{"location":"blog/ros/tutorial-beginner/#5-ros-topics","text":"Run turtle keyboard turtle_teleop_key node in a new terminal: rosrun turtlesim turtle_teleop_key After that, the turtle can be moved by using keyboard arrow keys. The turtlesim_node and the turtle_teleop_key node are communicating with each other over a ROS Topic. turtle_teleop_key is publishing the keystrokes on a topic, while turtlesim subscribes to the same topic to receive the keystrokes.","title":"5. ROS Topics"},{"location":"blog/ros/tutorial-beginner/#51-rqt_graph","text":"The rqt_graph tool creates a dynamic graph of what\u2019s going on in the system. rqt_graph is part of the rqt package. sudo apt install -y ros-melodic-rqt && \\ sudo apt install -y ros-melodic-rqt-common-plugins Run rqt_graph in a new terminal: rosrun rqt_graph rqt_graph The turtlesim_node and the turtle_teleop_key nodes are communicating on the topic named /turtle1/command_vel . RosGraph","title":"5.1. Rqt_graph"},{"location":"blog/ros/tutorial-beginner/#52-rostopic","text":"The rostopic tool allows getting information about ROS topics. rostopic bw # display bandwidth used by topic rostopic echo # print messages to screen rostopic hz # display publishing rate of topic rostopic list # print information about active topics rostopic pub # publish data to topic rostopic type # print topic type","title":"5.2. Rostopic"},{"location":"blog/ros/tutorial-beginner/#6-ros-messages","text":"Communication on topics happens by sending ROS messages between nodes. For the publisher ( turtle_teleop_key ) and subscriber ( turtlesim_node ) to communicate, the publisher and subscriber must send and receive the same type of message. This means that a topic type is defined by the message type published on it. The type of the message sent on a topic can be determined using rostopic type. rostopic type /turtle1/cmd_vel geometry_msgs/Twist The command rosmsg show prints out the details of the message: rosmsg show geometry_msgs/Twist geometry_msgs/Vector3 linear float64 x float64 y float64 z geometry_msgs/Vector3 angular float64 x float64 y float64 z","title":"6. ROS Messages"},{"location":"blog/ros/tutorial-beginner/#61-publish-a-message","text":"A message can be published through command line: rostopic pub [ topic ] [ msg_type ] [ args ] For example, to send one message on the topic /turtle1/cmd_vel using message type geometry_msgs/Twist and its required -- parameters '[2.0, 0.0, 0.0]' '[0.0, 0.0, 1.8]' , enter the below command: rostopic pub -1 \\ /turtle1/cmd_vel \\ geometry_msgs/Twist \\ -- '[2.0, 0.0, 0.0]' '[0.0, 0.0, 1.8]' To continuously send message at the rate of 1Hz, use -r 1 options: rostopic pub -r 1 \\ /turtle1/cmd_vel \\ geometry_msgs/Twist \\ -- '[2.0, 0.0, 0.0]' '[0.0, 0.0, -1.8]' The rate of message can be inspected by using the command rostopic hz : rostopic hz /turtle1/pose","title":"6.1. Publish a message"},{"location":"blog/ros/tutorial-beginner/#62-rqt_plot","text":"The rqt_plot tool displays a scrolling time plot of the data published on topics: rosrun rqt_plot rqt_plot In the new window that should pop up, a text box in the upper left corner gives the ability to add any topic to the plot. Typing /turtle1/pose/x will highlight the plus button, previously disabled. Press it and repeat the same procedure with the topic /turtle1/pose/y . Now the turtle\u2019s x-y location is plotted in the graph. RosPlot","title":"6.2. Rqt_plot"},{"location":"blog/ros/tutorial-beginner/#7-ros-services","text":"Services are another way that nodes can communicate with each other. Services allow nodes to send a request and receive a response . A rosservice can easily be attached to ROS\u2019s client/service framework with services. Commands that can be used on services are: rosservice list # print information about active services rosservice call # call the service with the provided args rosservice type # print service type rosservice find # find services by service type rosservice uri # print service ROSRPC uri Let\u2019s see current services: rosservice list /clear /kill /reset /rosout/get_loggers /rosout/set_logger_level /spawn /turtle1/set_pen /turtle1/teleport_absolute /turtle1/teleport_relative /turtlesim/get_loggers /turtlesim/set_logger_level Check the parameter of a service: rosservice type /clear std_srvs/Empty The /clear service shows an Empty parameter, but the /spawn has 4 parameter and returns string: rosservice type /spawn turtlesim/Spawn rosservice type /spawn | rossrv show float32 x float32 y float32 theta string name --- string name The input parameter are x , y , theta and name , and the output is name . Ok, let\u2019s clear the background and spawn a new turtle: rosservice call /clear && \\ rosservice call /spawn 2 2 0 .2 \"\"","title":"7. ROS Services"},{"location":"blog/ros/tutorial-beginner/#71-rosparam","text":"The rosparam tool allows storing and manipulate data on the ROS Parameter Server. The Parameter Server can store integers, floats, boolean, dictionaries, and lists. rosparam uses the YAML markup language for syntax. In simple cases, YAML looks very natural: 1 is an integer, 1.0 is a float, one is a string, true is a boolean, [1, 2, 3] is a list of integers, and {a: b, c: d} is a dictionary. rosparam has many commands that can be used on parameters, as shown below: rosparam set # set parameter rosparam get # get parameter rosparam load # load parameters from file rosparam dump # dump parameters to file rosparam delete # delete parameter rosparam list # list parameter names See the list of parameters: rosparam list /rosdistro /roslaunch/uris/host_ubuntu18__43509 /rosversion /run_id /turtlesim/background_b /turtlesim/background_g /turtlesim/background_r Here will change the red channel of the background color: rosparam set /turtlesim/background_r 150 Use get command to see the parameters: rosparam get / && \\ rosparam get /turtlesim/background_g dump and load option are also available: rosparam dump [ file_name ] [ namespace ] rosparam load [ file_name ] [ namespace ] For example: rosparam dump params.yaml will create a file params.yaml with the content similar to: rosdistro : \"melodic \" roslaunch : uris : { host_ubuntu18__43509 : \"http://ubuntu18:43509/\" } rosversion : \"1.14.11 \" run_id : 409b84fc-e2ff-11eb-be5c-080027b61567 turtlesim : { background_b : 255 , background_g : 86 , background_r : 150 }","title":"7.1. Rosparam"},{"location":"blog/ros/tutorial-beginner/#8-ros-console","text":"The command rqt_console attaches to ROS\u2019s logging framework to display output from nodes. rqt_logger_level allows to change the verbosity level ( DEBUG , WARN , INFO , and ERROR ) of nodes as they run. rosrun rqt_console rqt_console && \\ rosrun rqt_logger_level rqt_logger_level ROS Console and Logger Level Logging levels are prioritized in the following order: Fatal Error Warn Info Debug The Fatal level has the highest priority and Debug level has the lowest. By setting the logger level, logger will show all messages of that priority level or higher. For example, by setting the level to Warn , it will get all Warn , Error , and Fatal logging messages.","title":"8. ROS Console"},{"location":"blog/ros/tutorial-beginner/#9-ros-launch","text":"The roslaunch command starts nodes as defined in a launch file. roslaunch [ package ] [ filename.launch ] Starting with the beginner_tutorials package: cd catkin_ws && \\ source devel/setup.bash && \\ roscd beginner_tutorials vqtrong@ubuntu18:~/Work/catkin_ws/src/beginner_tutorials$ Then let\u2019s make a launch directory: mkdir launch && \\ cd launch Now let\u2019s create a launch file called turtlemimic.launch and paste the following: <launch> <group ns= \"turtlesim1\" > <node pkg= \"turtlesim\" name= \"sim\" type= \"turtlesim_node\" /> </group> <group ns= \"turtlesim2\" > <node pkg= \"turtlesim\" name= \"sim\" type= \"turtlesim_node\" /> </group> <node pkg= \"turtlesim\" name= \"mimic\" type= \"mimic\" > <remap from= \"input\" to= \"turtlesim1/turtle1\" /> <remap from= \"output\" to= \"turtlesim2/turtle1\" /> </node> </launch> Notes: Two groups with a namespace tag of turtlesim1 and turtlesim2 are created from a turtlesim node with a name of sim . This allows to start two simulators without having name conflicts. The mimic node with the topics input and output remapped to turtlesim1 and turtlesim2 . This renaming will cause turtlesim2 to mimic turtlesim1 .","title":"9. ROS Launch"},{"location":"blog/ros/tutorial-beginner/#91-roslaunch","text":"Start the launch file: roslaunch beginner_tutorials turtlemimic.launch And post messages to the first turtle: rostopic pub /turtlesim1/turtle1/cmd_vel geometry_msgs/Twist -r 1 -- '[2.0, 0.0, 0.0]' '[0.0, 0.0, -1.8]' Run the rqt_graph to see what is going on: rqt_graph Turtle mimic nodes graph","title":"9.1. Roslaunch"},{"location":"blog/ros/tutorial-beginner/#10-create-ros-msg-and-srv","text":"The msg files are simple text files that describe the fields of a ROS message. They are used to generating source code for messages in different languages. The msg files are stored in the msg directory of a package The field types include: int8 , int16 , int32 , int64 float32 , float64 string time , duration other msg files variable-length array[] and fixed-length array[x] There is also a special type in ROS: Header , the header contains a timestamp and coordinate frame information that are commonly used in ROS. Here is an example of a msg that uses a Header , a string primitive, and two other messages : Header header string child_frame_id geometry_msgs/PoseWithCovariance pose geometry_msgs/TwistWithCovariance twist The srv file describes a service. It is composed of two parts: a request and a response, and srv files are stored in the srv directory. The two parts are separated by a \u2018\u2014\u2018 line. Here is an example of a srv file: int64 A int64 B --- int64 Sum In the above example, A and B are the request, and Sum is the response.","title":"10. Create ROS msg and srv"},{"location":"blog/ros/tutorial-beginner/#101-create-a-msg","text":"Let\u2019s define a new msg in the beginner_tutorials package: roscd beginner_tutorials && \\ mkdir msg && \\ echo \"int64 num\" > msg/Num.msg Using rosmsg to see a message definition: rosmsg show beginner_tutorials/Num","title":"10.1. Create a msg"},{"location":"blog/ros/tutorial-beginner/#102-creating-a-srv","text":"Let\u2019s define a new msg in the beginner_tutorials package: roscd beginner_tutorials && \\ mkdir srv && \\ touch srv/AddTwoInts.srv The file content: AddTwoInts.srv int64 a int64 b --- int64 sum Using rossrv to see a service definition: rossrv show beginner_tutorials/AddTwoInts","title":"10.2. Creating a srv"},{"location":"blog/ros/tutorial-beginner/#103-generate-msg-and-srv","text":"To make sure that the msg files are turned into source code for C++, Python, and other languages, open package.xml , and make sure these two lines are in it: package.xml <build_depend> message_generation </build_depend> <exec_depend> message_runtime </exec_depend> and then add these packages into the CMakeLists.txt file: CMakeLists.txt find_package ( catkin REQUIRED COMPONENTS roscpp rospy std_msgs message_generation ) ## Generate messages in the 'msg' folder add_message_files ( FILES Num.msg ) ## Generate services in the 'srv' folder add_service_files ( FILES AddTwoInts.srv ) ## Generate added messages and services with any dependencies listed here generate_messages ( DEPENDENCIES std_msgs ) make the package again: roscd beginner_tutorials && \\ cd ../.. && \\ catkin_make && \\ cd - Any .msg file in the msg directory will generate code for use in all supported languages: The C++ message header file will be generated in catkin_ws/devel/include/beginner_tutorials/ . The Python script will be created in catkin_ws/devel/lib/python2.7/dist-packages/beginner_tutorials/msg . The lisp file appears in catkin_ws/devel/share/common-lisp/ros/beginner_tutorials/msg/ . Similarly, any .srv files in the srv directory will have generated code in supported languages. For C++, this will generate header files in the same directory as the messages. For Python and Lisp, there will be a srv folder beside the msg folders. Here are the generated files: devel/include/beginner_tutorials/Num.h devel/include/beginner_tutorials/AddTwoInts.h Let\u2019s see what was generated! In the Num.h header file: Create a namespace based on the package name namespace beginner_tutorials {} Use a template of an Allocator to create a new Num type: template < class ContainerAllocator > struct Num_ { typedef Num_ < ContainerAllocator > Type ; // constructor Num_ () : num ( 0 ) { } Num_ ( const ContainerAllocator & _alloc ) : num ( 0 ) { ( void ) _alloc ; } // members typedef int64_t _num_type ; _num_type num ; // define new type of pointer typedef boost :: shared_ptr < :: beginner_tutorials :: Num_ < ContainerAllocator > > Ptr ; typedef boost :: shared_ptr < :: beginner_tutorials :: Num_ < ContainerAllocator > const > ConstPtr ; }; // struct Num_ Create new pointer types of this new Num type typedef :: beginner_tutorials :: Num_ < std :: allocator < void > > Num ; typedef boost :: shared_ptr < :: beginner_tutorials :: Num > NumPtr ; typedef boost :: shared_ptr < :: beginner_tutorials :: Num const > NumConstPtr ; Noted that ROS uses shared_ptr to manage the memory, that will prevent any memory leak issue. Create friendly operations template < class ContainerAllocator > struct Printer < :: beginner_tutorials :: Num_ < ContainerAllocator > > { template < typename Stream > static void stream ( Stream & s , const std :: string & indent , const :: beginner_tutorials :: Num_ < ContainerAllocator >& v ) { s << indent << \"num: \" ; Printer < int64_t >:: stream ( s , indent + \" \" , v . num ); } }; template < typename ContainerAllocator > std :: ostream & operator << ( std :: ostream & s , const :: beginner_tutorials :: Num_ < ContainerAllocator > & v ) { ros :: message_operations :: Printer < :: beginner_tutorials :: Num_ < ContainerAllocator > > :: stream ( s , \"\" , v ); return s ; } template < typename ContainerAllocator1 , typename ContainerAllocator2 > bool operator == ( const :: beginner_tutorials :: Num_ < ContainerAllocator1 > & lhs , const :: beginner_tutorials :: Num_ < ContainerAllocator2 > & rhs ) { return lhs . num == rhs . num ; } template < typename ContainerAllocator1 , typename ContainerAllocator2 > bool operator != ( const :: beginner_tutorials :: Num_ < ContainerAllocator1 > & lhs , const :: beginner_tutorials :: Num_ < ContainerAllocator2 > & rhs ) { return ! ( lhs == rhs ); } Metadata which will be used by ROS to show object\u2019s information template < class ContainerAllocator > struct IsFixedSize < :: beginner_tutorials :: Num_ < ContainerAllocator > > : TrueType { }; template < class ContainerAllocator > struct IsFixedSize < :: beginner_tutorials :: Num_ < ContainerAllocator > const > : TrueType { }; template < class ContainerAllocator > struct IsMessage < :: beginner_tutorials :: Num_ < ContainerAllocator > > : TrueType { }; template < class ContainerAllocator > struct IsMessage < :: beginner_tutorials :: Num_ < ContainerAllocator > const > : TrueType { }; template < class ContainerAllocator > struct HasHeader < :: beginner_tutorials :: Num_ < ContainerAllocator > > : FalseType { }; template < class ContainerAllocator > struct HasHeader < :: beginner_tutorials :: Num_ < ContainerAllocator > const > : FalseType { }; template < class ContainerAllocator > struct MD5Sum < :: beginner_tutorials :: Num_ < ContainerAllocator > > { static const char * value () { return \"57d3c40ec3ac3754af76a83e6e73127a\" ; } static const char * value ( const :: beginner_tutorials :: Num_ < ContainerAllocator >& ) { return value (); } static const uint64_t static_value1 = 0x57d3c40ec3ac3754ULL ; static const uint64_t static_value2 = 0xaf76a83e6e73127aULL ; }; template < class ContainerAllocator > struct DataType < :: beginner_tutorials :: Num_ < ContainerAllocator > > { static const char * value () { return \"beginner_tutorials/Num\" ; } static const char * value ( const :: beginner_tutorials :: Num_ < ContainerAllocator >& ) { return value (); } }; template < class ContainerAllocator > struct Definition < :: beginner_tutorials :: Num_ < ContainerAllocator > > { static const char * value () { return \"int64 num \\n \" ; } static const char * value ( const :: beginner_tutorials :: Num_ < ContainerAllocator >& ) { return value (); } };","title":"10.3. Generate msg and srv"},{"location":"blog/ros/tutorial-beginner/#11-publisher-and-subscriber-c","text":"Go to the source code folder of the beginner_tutorials package: roscd beginner_tutorials && \\ mkdir src && \\ cd src","title":"11. Publisher and Subscriber (C++)"},{"location":"blog/ros/tutorial-beginner/#111-a-publisher-node","text":"This tutorial demonstrates simple sending of messages over the ROS system. nano talker.cpp src/talker.cpp #include \"ros/ros.h\" #include \"std_msgs/String.h\" #include <sstream> int main ( int argc , char ** argv ) { // init with a name ros :: init ( argc , argv , \"talker\" ); // create a node ros :: NodeHandle n ; // publish on a the `chatter` topic, queue = 1000 ros :: Publisher chatter_pub = n . advertise < std_msgs :: String > ( \"chatter\" , 1000 ); // publishing rate 1 Hz ros :: Rate loop_rate ( 1 ); // main loop int count = 0 ; while ( ros :: ok ()) { // message std_msgs :: String msg ; // content std :: stringstream ss ; ss << \"hello world \" << count ++ ; msg . data = ss . str (); ROS_INFO ( \"%s\" , msg . data . c_str ()); // publish chatter_pub . publish ( msg ); // check status ros :: spinOnce (); // sleep loop_rate . sleep (); } return 0 ; }","title":"11.1. A Publisher Node"},{"location":"blog/ros/tutorial-beginner/#112-a-subscriber-node","text":"This tutorial demonstrates simple receipt of messages over the ROS system. nano listener.cpp src/listener.cpp #include \"ros/ros.h\" #include \"std_msgs/String.h\" void chatterCallback ( const std_msgs :: String :: ConstPtr & msg ) { ROS_INFO ( \"I heard: [%s]\" , msg -> data . c_str ()); } int main ( int argc , char ** argv ) { // init with a name ros :: init ( argc , argv , \"listener\" ); // create a node ros :: NodeHandle n ; // subscribe on a the `chatter` topic, queue = 1000 // execute chatterCallback on receive ros :: Subscriber sub = n . subscribe ( \"chatter\" , 1000 , chatterCallback ); // main loop ros :: spin (); return 0 ; }","title":"11.2. A Subscriber Node"},{"location":"blog/ros/tutorial-beginner/#113-building-new-nodes","text":"Add the source code files which need to be compiled into the CMakeLists.txt . With all dependency packages listed above, add below lines also: cd .. && \\ nano CMakeLists.txt CMakeLists.txt ## Declare a C++ executable add_executable ( talker src/talker.cpp ) target_link_libraries ( talker ${ catkin_LIBRARIES } ) add_dependencies ( talker beginner_tutorials_generate_messages_cpp ) add_executable ( listener src/listener.cpp ) target_link_libraries ( listener ${ catkin_LIBRARIES } ) add_dependencies ( listener beginner_tutorials_generate_messages_cpp ) This will create two executables, talker and listener, which by default will go into package directory in devel space, located by default at catkin_ws/devel/lib/<package name> . Finally, make the package again: roscd beginner_tutorials && \\ cd ../.. && \\ catkin_make && \\ cd -","title":"11.3. Building new nodes"},{"location":"blog/ros/tutorial-beginner/#114-run-new-nodes","text":"Run roscore first if it is not running. Then run 2 new nodes in two terminals: rosrun beginner_tutorials talker rosrun beginner_tutorials listener Talker and Listener","title":"11.4. Run new nodes"},{"location":"blog/ros/tutorial-beginner/#12-publisher-and-subscriber-python","text":"Go to the scripts\u2019 folder of the beginner_tutorials package: roscd beginner_tutorials && \\ mkdir scripts && \\ cd scripts","title":"12. Publisher and Subscriber (Python)"},{"location":"blog/ros/tutorial-beginner/#121-a-publisher-node","text":"This tutorial demonstrates simple sending of messages over the ROS system. nano talker.py Note that a node is created from a publisher, in contrast to C++ implementation, a publisher is created from a node. In ROS, nodes are uniquely named. If two nodes with the same name are launched, the previous one is kicked off. The anonymous=True flag means that rospy will choose a unique name for a new listener node so that multiple listeners can run simultaneously. scripts/talker.py #!/usr/bin/env python import rospy from std_msgs.msg import String def talker (): # create a publisher, on topic `chatter` pub = rospy . Publisher ( 'chatter' , String , queue_size = 10 ) # create a node rospy . init_node ( 'talker' , anonymous = True ) # set the rate of publishing rate = rospy . Rate ( 1 ) # 1hz # main loop while not rospy . is_shutdown (): # make content hello_str = \"hello world %s \" % rospy . get_time () rospy . loginfo ( hello_str ) # publish a message pub . publish ( hello_str ) rate . sleep () if __name__ == '__main__' : try : talker () except rospy . ROSInterruptException : pass","title":"12.1. A Publisher Node"},{"location":"blog/ros/tutorial-beginner/#122-a-subscriber-node","text":"This tutorial demonstrates simple receipt of messages over the ROS system. nano listener.py scripts/listener.py #!/usr/bin/env python import rospy from std_msgs.msg import String def callback ( data ): rospy . loginfo ( rospy . get_caller_id () + \"I heard %s \" , data . data ) def listener (): # create a node rospy . init_node ( 'listener' , anonymous = True ) # create a subcriber rospy . Subscriber ( \"chatter\" , String , callback ) # spin() simply keeps python from exiting until this node is stopped rospy . spin () if __name__ == '__main__' : listener () rospy.spin() simply keeps the node from exiting until the node has been shutdown. Unlike roscpp, rospy.spin() does not affect the subscriber callback functions, as those have their own threads.","title":"12.2. A Subscriber Node"},{"location":"blog/ros/tutorial-beginner/#123-make-script-executable","text":"Scripts need to get execution permission before they can run: scripts chmod +x *","title":"12.3. Make script executable"},{"location":"blog/ros/tutorial-beginner/#124-building-new-nodes","text":"Add the source code files which need to be compiled into the CMakeLists.txt . With all dependency packages listed above, add below lines also: cd .. && \\ nano CMakeLists.txt CMakeLists.txt catkin_install_python ( PROGRAMS scripts/talker.py scripts/listener.py DESTINATION ${ CATKIN_PACKAGE_BIN_DESTINATION } ) Finally, make the package again: roscd beginner_tutorials && \\ cd ../.. && \\ catkin_make && \\ cd -","title":"12.4. Building new nodes"},{"location":"blog/ros/tutorial-beginner/#125-run-new-nodes","text":"Run roscore first if it is not running. Then run 2 new nodes in two terminals: rosrun beginner_tutorials talker.py rosrun beginner_tutorials listener.py Python script execution If the error /usr/bin/env: \u2018python \\r \u2019: No such file or directory shows up, it is because of the ending line characters. Unix use LF only while Windows use CRLF . Save python scripts in Unix ending character only.","title":"12.5. Run new nodes"},{"location":"blog/ros/tutorial-beginner/#13-service-and-client-c","text":"Go to the source code folder of the beginner_tutorials package: roscd beginner_tutorials && \\ mkdir src && \\ cd src","title":"13. Service and Client (C++)"},{"location":"blog/ros/tutorial-beginner/#131-a-service-node","text":"This guide will create the service add_two_ints_server node which will receive two ints and return the sum. This service uses the beginner_tutorials/AddTwoInts.h header file generated from the srv file that is created earlier. nano add_two_ints_server.cpp src/add_two_ints_server.cpp #include \"ros/ros.h\" #include \"beginner_tutorials/AddTwoInts.h\" // service fuction bool add ( beginner_tutorials :: AddTwoInts :: Request & req , beginner_tutorials :: AddTwoInts :: Response & res ) { res . sum = req . a + req . b ; ROS_INFO ( \"request: x=%ld, y=%ld\" , ( long int ) req . a , ( long int ) req . b ); ROS_INFO ( \"sending back response: [%ld]\" , ( long int ) res . sum ); return true ; } int main ( int argc , char ** argv ) { ros :: init ( argc , argv , \"add_two_ints_server\" ); // create a node ros :: NodeHandle n ; // node will have a service ros :: ServiceServer service = n . advertiseService ( \"add_two_ints\" , add ); ROS_INFO ( \"Ready to add two ints.\" ); // main loop ros :: spin (); return 0 ; }","title":"13.1. A Service Node"},{"location":"blog/ros/tutorial-beginner/#132-a-client-node","text":"This guide will create the service add_two_ints_client node which will receive two ints and return the sum. nano add_two_ints_client.cpp src/add_two_ints_client.cpp #include \"ros/ros.h\" #include \"beginner_tutorials/AddTwoInts.h\" #include <cstdlib> int main ( int argc , char ** argv ) { // check args ros :: init ( argc , argv , \"add_two_ints_client\" ); if ( argc != 3 ) { ROS_INFO ( \"usage: add_two_ints_client X Y\" ); return 1 ; } // create a node ros :: NodeHandle n ; // node will have a client ros :: ServiceClient client = n . serviceClient < beginner_tutorials :: AddTwoInts > ( \"add_two_ints\" ); // create a service target beginner_tutorials :: AddTwoInts srv ; // add params srv . request . a = atoll ( argv [ 1 ]); srv . request . b = atoll ( argv [ 2 ]); // call to service if ( client . call ( srv )) { ROS_INFO ( \"Sum: %ld\" , ( long int ) srv . response . sum ); } else { ROS_ERROR ( \"Failed to call service add_two_ints\" ); return 1 ; } return 0 ; }","title":"13.2. A Client Node"},{"location":"blog/ros/tutorial-beginner/#133-building-new-nodes","text":"Add the source code files which need to be compiled into the CMakeLists.txt . With all dependency packages listed above, add below lines also: cd .. && \\ nano CMakeLists.txt CMakeLists.txt ## Declare a C++ executable add_executable ( add_two_ints_server src/add_two_ints_server.cpp ) target_link_libraries ( add_two_ints_server ${ catkin_LIBRARIES } ) add_dependencies ( add_two_ints_server beginner_tutorials_gencpp ) add_executable ( add_two_ints_client src/add_two_ints_client.cpp ) target_link_libraries ( add_two_ints_client ${ catkin_LIBRARIES } ) add_dependencies ( add_two_ints_client beginner_tutorials_gencpp ) This will create two executables, add_two_ints_server and add_two_ints_client, which by default will go into package directory in devel space, located by default at catkin_ws/devel/lib/<package name> . Finally, make the package again: roscd beginner_tutorials && \\ cd ../.. && \\ catkin_make && \\ cd -","title":"13.3. Building new nodes"},{"location":"blog/ros/tutorial-beginner/#134-run-new-nodes","text":"Run roscore first if it is not running. Then run 2 new nodes in two terminals: rosrun beginner_tutorials add_two_ints_server rosrun beginner_tutorials add_two_ints_client 1 2 Service and Client","title":"13.4. Run new nodes"},{"location":"blog/ros/tutorial-beginner/#14-service-and-client-python","text":"Go to the source code folder of the beginner_tutorials package: roscd beginner_tutorials && \\ mkdir scripts && \\ cd scripts && \\","title":"14. Service and Client (Python)"},{"location":"blog/ros/tutorial-beginner/#141-a-service-node","text":"This guide will create the service add_two_ints_server node which will receive two ints and return the sum. This service uses the beginner_tutorials/AddTwoInts.h header file generated from the srv file that is created earlier. nano add_two_ints_server.py scripts/add_two_ints_server.py #!/usr/bin/env python from __future__ import print_function from beginner_tutorials.srv import AddTwoInts , AddTwoIntsResponse import rospy def handle_add_two_ints ( req ): print ( \"Returning [ %s + %s = %s ]\" % ( req . a , req . b , ( req . a + req . b ))) return AddTwoIntsResponse ( req . a + req . b ) def add_two_ints_server (): rospy . init_node ( 'add_two_ints_server' ) s = rospy . Service ( 'add_two_ints' , AddTwoInts , handle_add_two_ints ) print ( \"Ready to add two ints.\" ) rospy . spin () if __name__ == \"__main__\" : add_two_ints_server ()","title":"14.1. A Service Node"},{"location":"blog/ros/tutorial-beginner/#142-a-client-node","text":"This guide will create the service add_two_ints_client node which will receive two ints and return the sum. nano add_two_ints_client.py scripts/add_two_ints_client.py #!/usr/bin/env python from __future__ import print_function import sys import rospy from beginner_tutorials.srv import * def add_two_ints_client ( x , y ): rospy . wait_for_service ( 'add_two_ints' ) try : add_two_ints = rospy . ServiceProxy ( 'add_two_ints' , AddTwoInts ) resp1 = add_two_ints ( x , y ) return resp1 . sum except rospy . ServiceException as e : print ( \"Service call failed: %s \" % e ) def usage (): return \" %s [x y]\" % sys . argv [ 0 ] if __name__ == \"__main__\" : if len ( sys . argv ) == 3 : x = int ( sys . argv [ 1 ]) y = int ( sys . argv [ 2 ]) else : print ( usage ()) sys . exit ( 1 ) print ( \"Requesting %s + %s \" % ( x , y )) print ( \" %s + %s = %s \" % ( x , y , add_two_ints_client ( x , y )))","title":"14.2. A Client Node"},{"location":"blog/ros/tutorial-beginner/#143-make-scripts-executable","text":"Scripts need to get execution permission before they can run: chmod +x *","title":"14.3. Make scripts executable"},{"location":"blog/ros/tutorial-beginner/#144-building-new-nodes","text":"Add the source code files which need to be compiled into the CMakeLists.txt . With all dependency packages listed above, add below lines also: cd .. && \\ nano CMakeLists.txt CMakeLists.txt catkin_install_python ( PROGRAMS scripts/add_two_ints_server.py scripts/add_two_ints_client.py DESTINATION ${ CATKIN_PACKAGE_BIN_DESTINATION } ) This will create two executables, add_two_ints_server and add_two_ints_client, which by default will go into package directory in devel space, located by default at catkin_ws/devel/lib/<package name> . Finally, make the package again: roscd beginner_tutorials && \\ cd ../.. && \\ catkin_make && \\ cd -","title":"14.4. Building new nodes"},{"location":"blog/ros/tutorial-beginner/#145-run-new-nodes","text":"Run roscore first if it is not running. Then run 2 new nodes in two terminals: rosrun beginner_tutorials add_two_ints_server.py rosrun beginner_tutorials add_two_ints_client.py 1 3","title":"14.5. Run new nodes"},{"location":"blog/ros/tutorial-beginner/#15-playback-data","text":"This tutorial will teach how to record data from a running ROS system into a .bag file, and then to play back the data to produce similar behavior in a running system.","title":"15. Playback data"},{"location":"blog/ros/tutorial-beginner/#151-record-data","text":"First, execute the following commands in separate terminals: Terminal 1: roscore Terminal 2: rosrun turtlesim turtlesim_node Terminal 3: rosrun turtlesim turtle_teleop_key This will start two nodes \u2014 the turtlesim visualizer and a node that allows for the keyboard control of turtlesim using the arrows keys on the keyboard. Let\u2019s examine the full list of topics that are currently being published in the running system. To do this, open a new terminal and execute the command: rostopic list -v Published topics: * /turtle1/color_sensor [ turtlesim/Color ] 1 publisher * /turtle1/cmd_vel [ geometry_msgs/Twist ] 1 publisher * /rosout [ rosgraph_msgs/Log ] 2 publishers * /rosout_agg [ rosgraph_msgs/Log ] 1 publisher * /turtle1/pose [ turtlesim/Pose ] 1 publisher Subscribed topics: * /turtle1/cmd_vel [ geometry_msgs/Twist ] 1 subscriber * /rosout [ rosgraph_msgs/Log ] 1 subscriber The list of published topics is the only message types that could potentially be recorded in the data log file, as only published messages are recorded: The topic /turtle1/cmd_vel is the command message published by the teleop_turtle node that is taken as input by the turtlesim process. The messages /turtle1/color_sensor and /turtle1/pose are output messages published by turtlesim . Open a new terminal window. In this window run the following commands. Running rosbag record with the option -a indicates that all published topics should be accumulated in a bag file. roscd beginner_tutorials && \\ mkdir bagfiles && \\ cd bagfiles && \\ rosbag record -a [ INFO] [1626862434.586239631]: Recording to '2021-07-21-17-13-54.bag'. [ INFO] [1626862434.587320465]: Subscribing to /turtle1/color_sensor [ INFO] [1626862434.589356574]: Subscribing to /turtle1/cmd_vel [ INFO] [1626862434.591447646]: Subscribing to /rosout [ INFO] [1626862434.593544025]: Subscribing to /rosout_agg [ INFO] [1626862434.595557444]: Subscribing to /turtle1/pose Move back to the terminal window with turtle_teleop and move the turtle around for 10 or so seconds.","title":"15.1. Record data"},{"location":"blog/ros/tutorial-beginner/#152-rosbag-info","text":"Run the command rosbag info to see the info of a rosbag file: rosbag info <bagfile> path: xxx.bag version: 2 .0 duration: 2 :21s ( 141s ) start: xxx end: xxx size: 1 .3 MB messages: 18150 compression: none [ 2 /2 chunks ] types: geometry_msgs/Twist [ 9f195f881246fdfa2798d1d3eebca84a ] rosgraph_msgs/Log [ acffd30cd6b6de30f120938c17c593fb ] turtlesim/Color [ 353891e354491c51aabe32df673fb446 ] turtlesim/Pose [ 863b248d5016ca62ea2e895ae5265cf9 ] topics: /rosout 217 msgs : rosgraph_msgs/Log ( 2 connections ) /rosout_agg 214 msgs : rosgraph_msgs/Log /turtle1/cmd_vel 286 msgs : geometry_msgs/Twist /turtle1/color_sensor 8716 msgs : turtlesim/Color /turtle1/pose 8717 msgs : turtlesim/Pose","title":"15.2. Rosbag info"},{"location":"blog/ros/tutorial-beginner/#153-rosbag-play","text":"The next step in this tutorial is to replay the bag file to reproduce behavior in the running system. First kill the tele-operator program that may be still running from the previous section. Leave turtlesim running. In a terminal window run the following command: rosbag play <bagfile> In its default mode rosbag play will wait for a certain period (.2 seconds) after advertising each message before it actually begins publishing the contents of the bag file. Waiting for some duration allows any subscriber of a message to be alerted that the message has been advertised and that messages may follow. If rosbag play publishes messages immediately upon advertising, subscribers may not receive the first several published messages. The waiting period can be specified with the -d option.","title":"15.3. Rosbag play"},{"location":"blog/ros/tutorial-beginner/#154-recording-a-subset","text":"When running a complicated system, such as the pr2 software suite, there may be hundreds of topics being published, with some topics, like camera image streams, potentially publishing huge amounts of data. In such a system it is often impractical to write log files consisting of all topics to disk in a single bag file. The rosbag record command supports logging only particular topics to a bag file, allowing users to only record the topics of interest to them. rosbag record -O subset /turtle1/cmd_vel /turtle1/pose The -O argument tells rosbag record to log to a file named subset.bag , and the topic arguments cause rosbag record to only subscribe to these two topics. The limitations of rosbag record/play Different start condition can cause different results even the events are the same. The rate of recorded events is not guaranteed to be the same as the real actions.","title":"15.4. Recording a subset"},{"location":"blog/ros/tutorial-beginner/#16-read-message-from-rosbag","text":"The script ros_readbagfile will read rosbag file and extract all messages of selected topics: ros_readbagfile <mybagfile.bag> [ info ] [ N ] [ topic1 ] [ topic2 ] [ ... ] Download and install ros_readbag.py using below command: cd ~ && \\ wget https://raw.githubusercontent.com/vuquangtrong/ \\ ros_readbagfile/main/ros_readbagfile Edit shebang to use python 2 if needed. Change #!/usr/bin/python3 to #!/usr/bin/python . Make it executable: chmod +x ros_readbagfile The ~/bin directory for personal binaries: mkdir -p ~/bin Add this folder to the PATH : echo \"PATH=\\\" $PATH :~/bin\\\"\" >> ~/.bashrc Move this executable script into that directory as ros_readbagfile , so that it will be available as that command: mv ros_readbagfile ~/bin/ros_readbagfile Usage See the information of the input bag file: ros_readbagfile mybagfile.bag info Print all messages of all topics in the bag file to the screen: ros_readbagfile mybagfile.bag Print all messages of the topic /test in the bag file to the screen: ros_readbagfile mybagfile.bag /test Print at most N first messages of all topics in the bag file to the screen: ros_readbagfile mybagfile.bag N Print at most N first messages of the topic /test in the bag file to the screen: ros_readbagfile mybagfile.bag N /test To save the output to a file, use redirection syntax: ros_readbagfile mybagfile.bag N /test > output.txt Determine the exact topic names you\u2019d like to read from the bag file, by using rosbag info as mentioned above, or use ros_readbagfile info command: Use ros_readbagfile from terminal as below: rosbag info 2021 -07-21-17-13-54.bag path: 2021-07-21-17-13-54.bag version: 2.0 duration: 30.8s start: Jul 21 2021 17:13:54.60 (1626862434.60) end: Jul 21 2021 17:14:25.40 (1626862465.40) size: 280.8 KB messages: 3895 compression: none [1/1 chunks] types: geometry_msgs/Twist [9f195f881246fdfa2798d1d3eebca84a] rosgraph_msgs/Log [acffd30cd6b6de30f120938c17c593fb] turtlesim/Color [353891e354491c51aabe32df673fb446] turtlesim/Pose [863b248d5016ca62ea2e895ae5265cf9] topics: /rosout 4 msgs : rosgraph_msgs/Log (2 connections) /turtle1/cmd_vel 93 msgs : geometry_msgs/Twist /turtle1/color_sensor 1899 msgs : turtlesim/Color /turtle1/pose 1899 msgs : turtlesim/Pose Now, get all messages of the topic /turtle1/pose and save to the file: ros_readbagfile 2021 -07-21-17-13-54.bag /turtle1/pose > turtle1_pose.yaml # ======================================= # topic: /turtle1/pose # msg_count: 1899 # timestamp (sec): 1626862465.397807837 # - - - x: 10.0430784225 y: 6.37491464615 theta: -2.62400007248 linear_velocity: 0.0 angular_velocity: 0.0 # ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ # Total messages found: 1899 # # /turtle1/pose: 1899 # # DONE. # ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~","title":"16. Read message from Rosbag"},{"location":"blog/ros/tutorial-beginner/#17-reference","text":"There is an interesting book named A Gentle Introduction to ROS by Jason M. O\u2019Kane published on https://cse.sc.edu/~jokane/agitr/ . This book supplements ROS\u2019s own documentation, explaining how to interact with existing ROS systems and how to create new ROS programs using C++, with special attention to common mistakes and misunderstandings. An excerpt from the book: Giving ROS control The final complication is that ROS will only execute our callback function when we give it explicit permission to do so. There are actually two slightly different ways to accomplish this. One version looks like this: ros :: spinOnce (); This code asks ROS to execute all of the pending callbacks from all of the node\u2019s subscriptions, and then return control back to us. The other option looks like this: ros :: spin (); This alternative to ros::spinOnce() asks ROS to wait for and execute callbacks until the node shuts down. In other words, ros::spin() is roughly equivalent to this loop: while ( ros :: ok ()) { ros :: spinOnce (); } The question of whether to use ros::spinOnce() or ros::spin() comes down to this: Does your program have any repetitive work to do, other than responding to callbacks? If the answer is No , then use ros::spin() . If the answer is Yes , then a reasonable option is to write a loop that does that other work and calls ros::spinOnce() periodically to process callbacks. A common error in subscriber programs is to mistakenly omit both ros::spinOnce() and ros::spin() . In this case, ROS never has an opportunity to execute your callback function. Omitting ros::spin() will likely cause your program to exit shortly after it starts. Omitting ros::spinOnce() might make it appear as though no messages are being received.","title":"17. Reference"},{"location":"blog/setup-blog/","text":"1. Installation \u2693\ufe0e There are some static site generators written in several languages such as JavaScript, Go, Ruby, Python. They also use different template languages, e.g. React, Go, Liquid, Jinja. Among those generators, I\u2019d like to choose an engine based on Python language, because I am familiar with Python, so if I want to modify or add an extension, I can do it myself. Python-based site generators include MkDocs, Pelican, Sphinx, etc. MkDocs and Pelican are the most popular ones. I used Pelican few years ago, but recently, I was looking for a way to export blog posts to PDF files for printing and offline sharing, then Material theme for MkDocs which has a clear printing style became my choice. 1.1. Material for MkDocs \u2693\ufe0e MkDocs is a fast and simple engine to build a site for project documentation. Content source files are written in Markdown format, and the site is configured with a single YAML config file. MkDocs runs on Python 3 , so download and install it first. Material for MkDocs is a popular theme for MkDocs. It has a simple UI with Material color palettes. It also brings more features than the base MkDocs: it has web app mode, flexible settings, and as I mentioned, it has a clear layout and good styles for printing. When installing this Material theme, it will automatically install the MkDocs engine. 1.1.1. Start a new project \u2693\ufe0e Create a new folder to store the project: mkdir CodeInsideOut cd CodeInsideOut Create the project\u2019s virtual environment to isolate this project with others from a possible package conflict: python -m venv .venv Activate the virtual environment: .venv\\Scripts\\activate.bat 1.1.2. Install main packages \u2693\ufe0e Update the pip , setuptools and wheel as they\u2019re used to installing and configuring other packages: python -m pip install -U pip setuptools wheel -U or --upgrade will upgrade the package if it is already installed Then install the Material for MkDocs package: pip install -U mkdocs-material 1.1.3. Initialize the site \u2693\ufe0e Bring up the base of the site: mkdocs new . This will create the following file structure: . \u251c\u2500 mkdocs.yml # The configuration file \u2514\u2500 docs/ # Other markdown pages \u251c\u2500 index.md # The documentation homepage \u2514\u2500 ... # Other files Change the theme to material in the project configuration file mkdocs.yml : theme : name : material 1.1.4. Start a local server \u2693\ufe0e Run a local server with: mkdocs serve And preview the site at http://localhost:8000 to see the default homepage. 1.1.5. Write a post \u2693\ufe0e Each Markdown file inside the folder docs will be rendered to a page of the site. The index page is located at docs\\index.md . There can be sub-folders inside the docs directory to contain a group of posts in separate main topics. If a post is named other than index.md , the filename will be used as the directory path of the generated page. Here is how MkDocs generates URLs for Markdown posts: folder docs becomes the root of the site www.site.com/ file docs\\blog\\index.md becomes a link www.site.com/blog/ file docs\\blog\\a-post.md becomes a link www.site.com/blog/a-post/ Use hyphen - in folder name and file name to create good URLs. Here are some tips to keep URLs simple . 1.1.6. Publish \u2693\ufe0e To publish the site, build it first: mkdocs build Then copy all the content in the site folder to the website root folder. 1.2. Visual Studio Code \u2693\ufe0e Download and install Visual Studio Code \u2014 a lightweight but powerful source code editor. It well supports users to write code, documents, notes. This editor also have some extensions to turn it into a full-feature IDE for coding, such as PlatformIO . Write blog posts and preview in a local browser Useful extensions for writing in Markdown format and editing HTML template: Markdown All in One : add keyboard shortcuts, auto-completion, edit and format list and table Markdown Paste : paste images, links from the clipboard Draw.io Integration : edit diagrams and SVG images Jinja : highlight Jinja syntax in HTML templates Sublime Text Key map and Settings Importer : import keybindings and settings Code Spell Checker : catch common spelling errors Prettier \u2014 Code formatter : a formatter which supports a lot of languages 2. Configuration \u2693\ufe0e Material for MkDocs is just a start point. It is needed to be customized a little to fit my personal tastes. Refer to the official homepage of for more and complete guides, as I just list here main points to tweak the theme. 2.1. Site information \u2693\ufe0e Site information consists of the name, the URL, the title, a description and some keywords that are used to get brief information about the content of the site. This information is configured in the config file mkdocs.yml as below: site_name : Code Inside Out site_url : https://www.codeinsideout.com/ # must have the trailing slash site_author : vqtrong site_email : vuquangtrong@gmail.com site_description : >- Interesting stuff in Embedded Systems and IoT Applications. From hardwares to cloud applications. Step by step. site_keywords : embedded systems application programming copyright : >- \u00a9 2021 Code Inside Out The social links can be added in the extra section in the config file mkdocs.yml . Refer to the guide of setting up the footer . The icon field must point to a valid icon path referencing to a bundled icon . extra : social : - icon : fontawesome/brands/github-alt link : https://github.com/vuquangtrong name : vuquangtrong - icon : fontawesome/brands/facebook-f link : https://facebook.com/trongvq name : trongvq - icon : fontawesome/brands/linkedin-in link : https://www.linkedin.com/in/vqtrong name : vqtrong 2.2. Color palette \u2693\ufe0e Changing color is to select colors for 2 main groups: The primary color which is used for the header, the sidebar, text links and several other components. The accent color which is used to denote elements that can be interacted with, e.g. hovered links, buttons and scroll-bars. Both of them can be changed in mkdocs.yml by choosing a valid color name. As this page is intent to be printed on paper, I choose the white color as the primary look and feel, and the deep orange color for interactive elements. theme : palette : primary : white accent : deep orange 2.3. Fonts \u2693\ufe0e Serif fonts 1 are widely used for body text because they are considered to be easier to read than Sans-Serif fonts in print. For better reading, distinguishing the digit zero 0 from the Latin script letter Oh o or O is a way to avoid mistake, especially while reading technical notes. Fonts for source code do have slashed / dotted / open zero 2 , but fonts for reading don\u2019t have those styles. It\u2019s also needed to clearly distinguish the digit one 1 with lowercase i i , the uppercase i I , and the lowercase l l . Luckily, they usually do not stand close to each other. To replace the defaults fonts , this site uses Noto Serif for the body text, and Roboto Mono for the code block. theme : font : text : Noto Serif code : Roboto Mono Can you easily read below pairs of characters? Body text: 0o 0O oO 1i 1I 1l 1L iI il iL Il IL lL Code block: 0o 0O oO 1i 1I 1l 1L iI il iL Il IL lL 2.4. Logo & Icon \u2693\ufe0e I want to replace the default icon and logo with this code symbol . theme : icon : logo : fontawesome/solid/code favicon : favicon.png To use the included icons in Material theme, refer to Markdown syntax \u2014 Icons and Emojis . 2.5. Navigation \u2693\ufe0e Here are some interesting features for the navigation in Material theme: 2.5.1. Instant loading \u2693\ufe0e When instant loading is enabled, clicks on internal links will be intercepted and dispatched via XHR without fully reloading the page. The resulting page is parsed and injected and all event handlers and components are rebound automatically. This means that the site behaves like a Single Page Application, which is especially useful for large documentation sites that come with a massive search index, as the search index will now remain intact in-between document switches. Material for MkDocs is the only MkDocs theme offering this feature. Dynamic JavaScript-enabled elements do not work after AJAX content is loaded After an AJAX request is done, the old content is replaced with the new content, causing dynamic content and handlers are destroyed, such as items were selected by javascript query, Mermaid code blocks, disqus comments, registered event for clicking, etc. A solution is given in Fix AJAX issue . 2.5.2. Navigation tabs \u2693\ufe0e When tabs are enabled, top-level sections (first-level directories in the docs folder) are rendered in a menu layer below the header. 2.5.3. Back-to-top button \u2693\ufe0e A back-to-top button can be shown when the user, after scrolling down, starts to scroll up again. It\u2019s rendered in the lower right corner of the viewport, and help to go to the top of the page quickly. 2.5.4. Hide header bar \u2693\ufe0e When auto hiding is enabled, the header is automatically hidden when the user scrolls past a certain threshold, leaving more space for content. theme : features : - navigation.instant - navigation.tabs - navigation.top - header.autohide 2.6. Table of Content \u2693\ufe0e The Table of Content extension provides a quick navigation between sections in the post, it also places an anchor link at each header. This anchor can be used to link the header from other pages. The toc_depth: 4 makes the list displays from <h1> to <h4> . markdown_extensions : - toc : permalink : \u2693\ufe0e slugify : !!python/name:pymdownx.slugs.uslugify toc_depth : 4 2.7. Site analytics \u2693\ufe0e Material for MkDocs natively integrates with Google Analytics . Just need to create a new GA property in order to obtain a unique tracking ID of the form UA-XXXXXXXX-X , add it to mkdocs.yml: google_analytics : - UA-XXXXXXXX-X - auto 2.8. Comments section \u2693\ufe0e Material for MkDocs is natively integrated with Disqus , a comment system that provides a wide range of features like social integrations, user profiles, as well as spam and moderation tools. After setting up the site_url in mkdocs.yml , Disqus is configured by adding the Disqus short name: extra : disqus : \"shortname\" This will insert a comment system on every page, except the index page . If the Metadata extension is enabled, Disqus can be disabled per page by using an empty string: --- disqus : \"\" --- 2.9. Extra styles and scripts \u2693\ufe0e Add stylesheets and JavaScript files to the docs directory as below structure: . \u251c\u2500 docs/ \u2502 \u251c\u2500 assets/ \u2502 | \u2514\u2500 extra.css \u2502 | \u2514\u2500 extra.js | \u2514\u2500 blog/ \u2514\u2500 mkdocs.yml Then, add the following line to mkdocs.yml : extra_css : - assets/extra.css extra_javascript : - assets/extra.js It\u2019s ready to add extra styles and scripts to the site at the moment, but it should be done later after adding new layouts and elements to the theme. At this time, I just need to add some small additional styles to make the theme look a bit harmonious with the selected theme color. To do that, in the webpage, right-click on an element, then select Inspect menu to go to the Developer Mode , and check the tag and the class of the selected element. The page content is usually wrapped inside the tag < article class = \"md-content__inner md-typeset\" > </ article > , so select either the tag or a class of that tag to use as the container of extra styles. Here are some small requirements: Logo and headers should be in orange to be highlighted, and active links can be in dark blue: . md-logo , . md-typeset h1 { color : orangered ; } . md-typeset h2 , . md-typeset h3 , . md-typeset h4 , . md-tabs__link . md-tabs__link--active , . md-nav__link . md-nav__link--active { color : darkblue ; } Search input should have white background color: . md-search__input { background-color : white !important ; } Non-highlighted code needs stand out a bit in dark red in white background: . md-typeset code { color : darkred ; background-color : rgba ( 0 , 0 , 0 , 0.01 ); } Normal paragraph should be fully justified: . md-typeset p { text-align : justify ; } Emphasized text should be in dark magenta: . md-typeset em { color : darkmagenta ; } Footer should look smaller by changing the background color: . md-footer { color : unset ; background-color : unset ; } . md-footer-meta { background-color : black ; } For more styles, please read more in Customize theme . 2.10. Override templates \u2693\ufe0e MkDocs allows to override them by just adding extra files that will replace the original ones when building the site. Create a new folder overrides in the project folder to save the overriding files, then enable them in the config file mkdocs.yml : theme : name : material custom_dir : overrides 2.10.1. Override files \u2693\ufe0e The structure in the overrides directory must mirror the directory structure of the original theme, as any file in the overridden directory will replace the file with the same name which is part of the original theme. Besides, further assets may also be put in the overridden directory. . \u251c\u2500 .icons/ # Bundled icon sets \u251c\u2500 assets/ \u2502 \u251c\u2500 images/ # Images and icons \u2502 \u251c\u2500 javascripts/ # JavaScript \u2502 \u2514\u2500 stylesheets/ # Stylesheets \u251c\u2500 partials/ \u2502 \u251c\u2500 integrations/ # Third-party integrations \u2502 \u2502 \u251c\u2500 analytics.html # - Google Analytics \u2502 \u2502 \u2514\u2500 disqus.html # - Disqus \u2502 \u251c\u2500 languages/ # Localized languages \u2502 \u251c\u2500 footer.html # Footer bar \u2502 \u251c\u2500 header.html # Header bar \u2502 \u251c\u2500 language.html # Localized labels \u2502 \u251c\u2500 logo.html # Logo in header and sidebar \u2502 \u251c\u2500 nav.html # Main navigation \u2502 \u251c\u2500 nav-item.html # Main navigation item \u2502 \u251c\u2500 palette.html # Color palette \u2502 \u251c\u2500 search.html # Search box \u2502 \u251c\u2500 social.html # Social links \u2502 \u251c\u2500 source.html # Repository information \u2502 \u251c\u2500 source-date.html # Last updated date \u2502 \u251c\u2500 source-link.html # Link to source file \u2502 \u251c\u2500 tabs.html # Tabs navigation \u2502 \u251c\u2500 tabs-item.html # Tabs navigation item \u2502 \u251c\u2500 toc.html # Table of contents \u2502 \u2514\u2500 toc-item.html # Table of contents item \u251c\u2500 404 .html # 404 error page \u251c\u2500 base.html # Base template \u2514\u2500 main.html # Default page The template file base.html , which originally located in the folder .venv\\Lib\\site-packages\\material , is the starting point of any site\u2019s page. All other pages should extend from it. The main.html template, which extends the base.html , is used to add a custom template. To use other template, in the metadata of the Markdown file, set the attribute template with the name of template file. For example: --- title: Blog template: blog.html --- 2.10.2. Override blocks \u2693\ufe0e Besides overriding partials, it\u2019s also possible to override (and extend) template blocks, which are defined inside the template files and wrap specific features. To override a block, create a new template .html file inside the overrides directory, and define a same block name with the one which will be overridden: {% extends \"base.html\" %} {% block htmltitle %} <title>New title</title> {% endblock %} To extend a block, use the {{ super () }} command: {% extends \"base.html\" %} {% block head %} {{ super () }} Appended content {% endblock %} To replace a block, don\u2019t use the {{ super () }} command. {% block head %} New content {% endblock %} The list of blocks: analytics # Wraps the Google Analytics integration announce # Wraps the announcement bar config # Wraps the JavaScript application config content # Wraps the main content disqus # Wraps the Disqus integration extrahead # Empty block to add custom meta tags fonts # Wraps the font definitions footer # Wraps the footer with navigation and copyright header # Wraps the fixed header bar hero # Wraps the hero teaser (if available) htmltitle # Wraps the <title> tag libs # Wraps the JavaScript libraries (header) outdated # Wraps the version warning scripts # Wraps the JavaScript application (footer) source # Wraps the linked source files site_meta # Wraps the meta tags in the document head site_nav # Wraps the site navigation and table of contents styles # Wraps the stylesheets (also extra sources) tabs # Wraps the tabs navigation (if available) 2.10.3. The index page \u2693\ufe0e The index page of the website is located at docs\\index.md . Material theme created a default one then it has to be modified. I\u2019d like to write brief information about me and why this blog is created: Welcome to # Code Inside Out Interesting stuff in Embedded Systems and IoT Applications. From hardwares to cloud applications. Step by step. (\uff89 \u25d5 \u30ee \u25d5)\uff89\\*:\u30fb\uff9f \u2727 2.10.4. The 404 page \u2693\ufe0e Whenever a page is not found in a website, the error 404 is return to the requested users. I need to create this special page to display a short message and guide user to search in this blog. The 404 page should be created in the overrides folder as it will replace the default 404 pages of Material theme. Its layout is based on the base.html , and the content is a message displayed in the center of the page. The disqus comment section is removed. The sidebar should not be visible to display message clearly. {% extends \"main.html\" %} {% block content %} <style> .md-sidebar { display: none; } </style> <div style=\"text-align: center;\"> <h1> Oops! Something went wrong! </h1> <h3> Please go back to the <a href=\" {{ config.site_url }} \"> {{ config.site_name }} </a> homepage, <br> or press <kbd>S</kbd> to search on this site. </h3> </div> {% endblock %} {% block disqus %} {% endblock %} 3. Markdown extensions \u2693\ufe0e Markdown comes with a simple syntax to create headers, links, images, and paragraphs with formatted text, lists. However, that\u2019s not enough. Some Markdown extensions bring more syntaxes to create complex elements or new layouts that help writing documents easier, faster, and look professional. Read more in Markdown syntax . 4. MkDocs plugins \u2693\ufe0e New features can be added to MkDocs engine by installing plugins. These packages can modify the navigation behavior, or render new content types, or export the site to PDF documents. Plugins also can be modified easily as they are written in Python. Read more in MkDocs plugins . 5. Customize theme \u2693\ufe0e A personal website should look different to others to make it unique and standout. I prefer a simple look which goes straight to the content, and pages should be clear to be printed on papers. Therefore, I modified styles for some elements, also bring must-have elements of a blog like tag cloud, tag page, list of posts. Read more in Customize theme . 6. Print to PDF \u2693\ufe0e For printing or offline reading, the document should be exported to PDF format. A manual method is to print each post by the user browser. There is a plugin to automatically export all site\u2019s posts to PDF during the build time, but it needs some configuration to work as I expected. Generated PDF files can be downloaded by clicking on the download button at the beginning of each page. Read more in Print to PDF . https://en.wikipedia.org/wiki/Serif \u21a9 https://en.wikipedia.org/wiki/Slashed_zero \u21a9","title":"Setup blog"},{"location":"blog/setup-blog/#1-installation","text":"There are some static site generators written in several languages such as JavaScript, Go, Ruby, Python. They also use different template languages, e.g. React, Go, Liquid, Jinja. Among those generators, I\u2019d like to choose an engine based on Python language, because I am familiar with Python, so if I want to modify or add an extension, I can do it myself. Python-based site generators include MkDocs, Pelican, Sphinx, etc. MkDocs and Pelican are the most popular ones. I used Pelican few years ago, but recently, I was looking for a way to export blog posts to PDF files for printing and offline sharing, then Material theme for MkDocs which has a clear printing style became my choice.","title":"1. Installation"},{"location":"blog/setup-blog/#11-material-for-mkdocs","text":"MkDocs is a fast and simple engine to build a site for project documentation. Content source files are written in Markdown format, and the site is configured with a single YAML config file. MkDocs runs on Python 3 , so download and install it first. Material for MkDocs is a popular theme for MkDocs. It has a simple UI with Material color palettes. It also brings more features than the base MkDocs: it has web app mode, flexible settings, and as I mentioned, it has a clear layout and good styles for printing. When installing this Material theme, it will automatically install the MkDocs engine.","title":"1.1. Material for MkDocs"},{"location":"blog/setup-blog/#111-start-a-new-project","text":"Create a new folder to store the project: mkdir CodeInsideOut cd CodeInsideOut Create the project\u2019s virtual environment to isolate this project with others from a possible package conflict: python -m venv .venv Activate the virtual environment: .venv\\Scripts\\activate.bat","title":"1.1.1. Start a new project"},{"location":"blog/setup-blog/#112-install-main-packages","text":"Update the pip , setuptools and wheel as they\u2019re used to installing and configuring other packages: python -m pip install -U pip setuptools wheel -U or --upgrade will upgrade the package if it is already installed Then install the Material for MkDocs package: pip install -U mkdocs-material","title":"1.1.2. Install main packages"},{"location":"blog/setup-blog/#113-initialize-the-site","text":"Bring up the base of the site: mkdocs new . This will create the following file structure: . \u251c\u2500 mkdocs.yml # The configuration file \u2514\u2500 docs/ # Other markdown pages \u251c\u2500 index.md # The documentation homepage \u2514\u2500 ... # Other files Change the theme to material in the project configuration file mkdocs.yml : theme : name : material","title":"1.1.3. Initialize the site"},{"location":"blog/setup-blog/#114-start-a-local-server","text":"Run a local server with: mkdocs serve And preview the site at http://localhost:8000 to see the default homepage.","title":"1.1.4. Start a local server"},{"location":"blog/setup-blog/#115-write-a-post","text":"Each Markdown file inside the folder docs will be rendered to a page of the site. The index page is located at docs\\index.md . There can be sub-folders inside the docs directory to contain a group of posts in separate main topics. If a post is named other than index.md , the filename will be used as the directory path of the generated page. Here is how MkDocs generates URLs for Markdown posts: folder docs becomes the root of the site www.site.com/ file docs\\blog\\index.md becomes a link www.site.com/blog/ file docs\\blog\\a-post.md becomes a link www.site.com/blog/a-post/ Use hyphen - in folder name and file name to create good URLs. Here are some tips to keep URLs simple .","title":"1.1.5. Write a post"},{"location":"blog/setup-blog/#116-publish","text":"To publish the site, build it first: mkdocs build Then copy all the content in the site folder to the website root folder.","title":"1.1.6. Publish"},{"location":"blog/setup-blog/#12-visual-studio-code","text":"Download and install Visual Studio Code \u2014 a lightweight but powerful source code editor. It well supports users to write code, documents, notes. This editor also have some extensions to turn it into a full-feature IDE for coding, such as PlatformIO . Write blog posts and preview in a local browser Useful extensions for writing in Markdown format and editing HTML template: Markdown All in One : add keyboard shortcuts, auto-completion, edit and format list and table Markdown Paste : paste images, links from the clipboard Draw.io Integration : edit diagrams and SVG images Jinja : highlight Jinja syntax in HTML templates Sublime Text Key map and Settings Importer : import keybindings and settings Code Spell Checker : catch common spelling errors Prettier \u2014 Code formatter : a formatter which supports a lot of languages","title":"1.2. Visual Studio Code"},{"location":"blog/setup-blog/#2-configuration","text":"Material for MkDocs is just a start point. It is needed to be customized a little to fit my personal tastes. Refer to the official homepage of for more and complete guides, as I just list here main points to tweak the theme.","title":"2. Configuration"},{"location":"blog/setup-blog/#21-site-information","text":"Site information consists of the name, the URL, the title, a description and some keywords that are used to get brief information about the content of the site. This information is configured in the config file mkdocs.yml as below: site_name : Code Inside Out site_url : https://www.codeinsideout.com/ # must have the trailing slash site_author : vqtrong site_email : vuquangtrong@gmail.com site_description : >- Interesting stuff in Embedded Systems and IoT Applications. From hardwares to cloud applications. Step by step. site_keywords : embedded systems application programming copyright : >- \u00a9 2021 Code Inside Out The social links can be added in the extra section in the config file mkdocs.yml . Refer to the guide of setting up the footer . The icon field must point to a valid icon path referencing to a bundled icon . extra : social : - icon : fontawesome/brands/github-alt link : https://github.com/vuquangtrong name : vuquangtrong - icon : fontawesome/brands/facebook-f link : https://facebook.com/trongvq name : trongvq - icon : fontawesome/brands/linkedin-in link : https://www.linkedin.com/in/vqtrong name : vqtrong","title":"2.1. Site information"},{"location":"blog/setup-blog/#22-color-palette","text":"Changing color is to select colors for 2 main groups: The primary color which is used for the header, the sidebar, text links and several other components. The accent color which is used to denote elements that can be interacted with, e.g. hovered links, buttons and scroll-bars. Both of them can be changed in mkdocs.yml by choosing a valid color name. As this page is intent to be printed on paper, I choose the white color as the primary look and feel, and the deep orange color for interactive elements. theme : palette : primary : white accent : deep orange","title":"2.2. Color palette"},{"location":"blog/setup-blog/#23-fonts","text":"Serif fonts 1 are widely used for body text because they are considered to be easier to read than Sans-Serif fonts in print. For better reading, distinguishing the digit zero 0 from the Latin script letter Oh o or O is a way to avoid mistake, especially while reading technical notes. Fonts for source code do have slashed / dotted / open zero 2 , but fonts for reading don\u2019t have those styles. It\u2019s also needed to clearly distinguish the digit one 1 with lowercase i i , the uppercase i I , and the lowercase l l . Luckily, they usually do not stand close to each other. To replace the defaults fonts , this site uses Noto Serif for the body text, and Roboto Mono for the code block. theme : font : text : Noto Serif code : Roboto Mono Can you easily read below pairs of characters? Body text: 0o 0O oO 1i 1I 1l 1L iI il iL Il IL lL Code block: 0o 0O oO 1i 1I 1l 1L iI il iL Il IL lL","title":"2.3. Fonts"},{"location":"blog/setup-blog/#24-logo--icon","text":"I want to replace the default icon and logo with this code symbol . theme : icon : logo : fontawesome/solid/code favicon : favicon.png To use the included icons in Material theme, refer to Markdown syntax \u2014 Icons and Emojis .","title":"2.4. Logo &amp; Icon"},{"location":"blog/setup-blog/#25-navigation","text":"Here are some interesting features for the navigation in Material theme:","title":"2.5. Navigation"},{"location":"blog/setup-blog/#251-instant-loading","text":"When instant loading is enabled, clicks on internal links will be intercepted and dispatched via XHR without fully reloading the page. The resulting page is parsed and injected and all event handlers and components are rebound automatically. This means that the site behaves like a Single Page Application, which is especially useful for large documentation sites that come with a massive search index, as the search index will now remain intact in-between document switches. Material for MkDocs is the only MkDocs theme offering this feature. Dynamic JavaScript-enabled elements do not work after AJAX content is loaded After an AJAX request is done, the old content is replaced with the new content, causing dynamic content and handlers are destroyed, such as items were selected by javascript query, Mermaid code blocks, disqus comments, registered event for clicking, etc. A solution is given in Fix AJAX issue .","title":"2.5.1. Instant loading"},{"location":"blog/setup-blog/#252-navigation-tabs","text":"When tabs are enabled, top-level sections (first-level directories in the docs folder) are rendered in a menu layer below the header.","title":"2.5.2. Navigation tabs"},{"location":"blog/setup-blog/#253-back-to-top-button","text":"A back-to-top button can be shown when the user, after scrolling down, starts to scroll up again. It\u2019s rendered in the lower right corner of the viewport, and help to go to the top of the page quickly.","title":"2.5.3. Back-to-top button"},{"location":"blog/setup-blog/#254-hide-header-bar","text":"When auto hiding is enabled, the header is automatically hidden when the user scrolls past a certain threshold, leaving more space for content. theme : features : - navigation.instant - navigation.tabs - navigation.top - header.autohide","title":"2.5.4. Hide header bar"},{"location":"blog/setup-blog/#26-table-of-content","text":"The Table of Content extension provides a quick navigation between sections in the post, it also places an anchor link at each header. This anchor can be used to link the header from other pages. The toc_depth: 4 makes the list displays from <h1> to <h4> . markdown_extensions : - toc : permalink : \u2693\ufe0e slugify : !!python/name:pymdownx.slugs.uslugify toc_depth : 4","title":"2.6. Table of Content"},{"location":"blog/setup-blog/#27-site-analytics","text":"Material for MkDocs natively integrates with Google Analytics . Just need to create a new GA property in order to obtain a unique tracking ID of the form UA-XXXXXXXX-X , add it to mkdocs.yml: google_analytics : - UA-XXXXXXXX-X - auto","title":"2.7. Site analytics"},{"location":"blog/setup-blog/#28-comments-section","text":"Material for MkDocs is natively integrated with Disqus , a comment system that provides a wide range of features like social integrations, user profiles, as well as spam and moderation tools. After setting up the site_url in mkdocs.yml , Disqus is configured by adding the Disqus short name: extra : disqus : \"shortname\" This will insert a comment system on every page, except the index page . If the Metadata extension is enabled, Disqus can be disabled per page by using an empty string: --- disqus : \"\" ---","title":"2.8. Comments section"},{"location":"blog/setup-blog/#29-extra-styles-and-scripts","text":"Add stylesheets and JavaScript files to the docs directory as below structure: . \u251c\u2500 docs/ \u2502 \u251c\u2500 assets/ \u2502 | \u2514\u2500 extra.css \u2502 | \u2514\u2500 extra.js | \u2514\u2500 blog/ \u2514\u2500 mkdocs.yml Then, add the following line to mkdocs.yml : extra_css : - assets/extra.css extra_javascript : - assets/extra.js It\u2019s ready to add extra styles and scripts to the site at the moment, but it should be done later after adding new layouts and elements to the theme. At this time, I just need to add some small additional styles to make the theme look a bit harmonious with the selected theme color. To do that, in the webpage, right-click on an element, then select Inspect menu to go to the Developer Mode , and check the tag and the class of the selected element. The page content is usually wrapped inside the tag < article class = \"md-content__inner md-typeset\" > </ article > , so select either the tag or a class of that tag to use as the container of extra styles. Here are some small requirements: Logo and headers should be in orange to be highlighted, and active links can be in dark blue: . md-logo , . md-typeset h1 { color : orangered ; } . md-typeset h2 , . md-typeset h3 , . md-typeset h4 , . md-tabs__link . md-tabs__link--active , . md-nav__link . md-nav__link--active { color : darkblue ; } Search input should have white background color: . md-search__input { background-color : white !important ; } Non-highlighted code needs stand out a bit in dark red in white background: . md-typeset code { color : darkred ; background-color : rgba ( 0 , 0 , 0 , 0.01 ); } Normal paragraph should be fully justified: . md-typeset p { text-align : justify ; } Emphasized text should be in dark magenta: . md-typeset em { color : darkmagenta ; } Footer should look smaller by changing the background color: . md-footer { color : unset ; background-color : unset ; } . md-footer-meta { background-color : black ; } For more styles, please read more in Customize theme .","title":"2.9. Extra styles and scripts"},{"location":"blog/setup-blog/#210-override-templates","text":"MkDocs allows to override them by just adding extra files that will replace the original ones when building the site. Create a new folder overrides in the project folder to save the overriding files, then enable them in the config file mkdocs.yml : theme : name : material custom_dir : overrides","title":"2.10. Override templates"},{"location":"blog/setup-blog/#2101-override-files","text":"The structure in the overrides directory must mirror the directory structure of the original theme, as any file in the overridden directory will replace the file with the same name which is part of the original theme. Besides, further assets may also be put in the overridden directory. . \u251c\u2500 .icons/ # Bundled icon sets \u251c\u2500 assets/ \u2502 \u251c\u2500 images/ # Images and icons \u2502 \u251c\u2500 javascripts/ # JavaScript \u2502 \u2514\u2500 stylesheets/ # Stylesheets \u251c\u2500 partials/ \u2502 \u251c\u2500 integrations/ # Third-party integrations \u2502 \u2502 \u251c\u2500 analytics.html # - Google Analytics \u2502 \u2502 \u2514\u2500 disqus.html # - Disqus \u2502 \u251c\u2500 languages/ # Localized languages \u2502 \u251c\u2500 footer.html # Footer bar \u2502 \u251c\u2500 header.html # Header bar \u2502 \u251c\u2500 language.html # Localized labels \u2502 \u251c\u2500 logo.html # Logo in header and sidebar \u2502 \u251c\u2500 nav.html # Main navigation \u2502 \u251c\u2500 nav-item.html # Main navigation item \u2502 \u251c\u2500 palette.html # Color palette \u2502 \u251c\u2500 search.html # Search box \u2502 \u251c\u2500 social.html # Social links \u2502 \u251c\u2500 source.html # Repository information \u2502 \u251c\u2500 source-date.html # Last updated date \u2502 \u251c\u2500 source-link.html # Link to source file \u2502 \u251c\u2500 tabs.html # Tabs navigation \u2502 \u251c\u2500 tabs-item.html # Tabs navigation item \u2502 \u251c\u2500 toc.html # Table of contents \u2502 \u2514\u2500 toc-item.html # Table of contents item \u251c\u2500 404 .html # 404 error page \u251c\u2500 base.html # Base template \u2514\u2500 main.html # Default page The template file base.html , which originally located in the folder .venv\\Lib\\site-packages\\material , is the starting point of any site\u2019s page. All other pages should extend from it. The main.html template, which extends the base.html , is used to add a custom template. To use other template, in the metadata of the Markdown file, set the attribute template with the name of template file. For example: --- title: Blog template: blog.html ---","title":"2.10.1. Override files"},{"location":"blog/setup-blog/#2102-override-blocks","text":"Besides overriding partials, it\u2019s also possible to override (and extend) template blocks, which are defined inside the template files and wrap specific features. To override a block, create a new template .html file inside the overrides directory, and define a same block name with the one which will be overridden: {% extends \"base.html\" %} {% block htmltitle %} <title>New title</title> {% endblock %} To extend a block, use the {{ super () }} command: {% extends \"base.html\" %} {% block head %} {{ super () }} Appended content {% endblock %} To replace a block, don\u2019t use the {{ super () }} command. {% block head %} New content {% endblock %} The list of blocks: analytics # Wraps the Google Analytics integration announce # Wraps the announcement bar config # Wraps the JavaScript application config content # Wraps the main content disqus # Wraps the Disqus integration extrahead # Empty block to add custom meta tags fonts # Wraps the font definitions footer # Wraps the footer with navigation and copyright header # Wraps the fixed header bar hero # Wraps the hero teaser (if available) htmltitle # Wraps the <title> tag libs # Wraps the JavaScript libraries (header) outdated # Wraps the version warning scripts # Wraps the JavaScript application (footer) source # Wraps the linked source files site_meta # Wraps the meta tags in the document head site_nav # Wraps the site navigation and table of contents styles # Wraps the stylesheets (also extra sources) tabs # Wraps the tabs navigation (if available)","title":"2.10.2. Override blocks"},{"location":"blog/setup-blog/#2103-the-index-page","text":"The index page of the website is located at docs\\index.md . Material theme created a default one then it has to be modified. I\u2019d like to write brief information about me and why this blog is created: Welcome to # Code Inside Out Interesting stuff in Embedded Systems and IoT Applications. From hardwares to cloud applications. Step by step. (\uff89 \u25d5 \u30ee \u25d5)\uff89\\*:\u30fb\uff9f \u2727","title":"2.10.3. The index page"},{"location":"blog/setup-blog/#2104-the-404-page","text":"Whenever a page is not found in a website, the error 404 is return to the requested users. I need to create this special page to display a short message and guide user to search in this blog. The 404 page should be created in the overrides folder as it will replace the default 404 pages of Material theme. Its layout is based on the base.html , and the content is a message displayed in the center of the page. The disqus comment section is removed. The sidebar should not be visible to display message clearly. {% extends \"main.html\" %} {% block content %} <style> .md-sidebar { display: none; } </style> <div style=\"text-align: center;\"> <h1> Oops! Something went wrong! </h1> <h3> Please go back to the <a href=\" {{ config.site_url }} \"> {{ config.site_name }} </a> homepage, <br> or press <kbd>S</kbd> to search on this site. </h3> </div> {% endblock %} {% block disqus %} {% endblock %}","title":"2.10.4. The 404 page"},{"location":"blog/setup-blog/#3-markdown-extensions","text":"Markdown comes with a simple syntax to create headers, links, images, and paragraphs with formatted text, lists. However, that\u2019s not enough. Some Markdown extensions bring more syntaxes to create complex elements or new layouts that help writing documents easier, faster, and look professional. Read more in Markdown syntax .","title":"3. Markdown extensions"},{"location":"blog/setup-blog/#4-mkdocs-plugins","text":"New features can be added to MkDocs engine by installing plugins. These packages can modify the navigation behavior, or render new content types, or export the site to PDF documents. Plugins also can be modified easily as they are written in Python. Read more in MkDocs plugins .","title":"4. MkDocs plugins"},{"location":"blog/setup-blog/#5-customize-theme","text":"A personal website should look different to others to make it unique and standout. I prefer a simple look which goes straight to the content, and pages should be clear to be printed on papers. Therefore, I modified styles for some elements, also bring must-have elements of a blog like tag cloud, tag page, list of posts. Read more in Customize theme .","title":"5. Customize theme"},{"location":"blog/setup-blog/#6-print-to-pdf","text":"For printing or offline reading, the document should be exported to PDF format. A manual method is to print each post by the user browser. There is a plugin to automatically export all site\u2019s posts to PDF during the build time, but it needs some configuration to work as I expected. Generated PDF files can be downloaded by clicking on the download button at the beginning of each page. Read more in Print to PDF . https://en.wikipedia.org/wiki/Serif \u21a9 https://en.wikipedia.org/wiki/Slashed_zero \u21a9","title":"6. Print to PDF"},{"location":"blog/setup-blog/customize-theme/","text":"1. The post\u2019s title \u2693\ufe0e By using the Awesome Pages plugin and the Section index plugin, the navigation sidebar can show a good structure of posts. However, each entry is displaying the post\u2019s title with long text, this make the navigation bar look a bit messy. It is easy to add a full title into a post by using the Metadata section . For example: --- title : Customize theme title_full : Customize the theme with personal styles description : A personal website should look different to others ... --- However, the content of each post will also display the short title. To fix this, I am going to override the main template. Before do it, I will add tags in the Metadata section also. 2. The post\u2019s tags \u2693\ufe0e A tag is a word or a phrase that describes one main point of a blog post\u2019s content. They are an easy way to attach labels to the content and link similar posts together. The tags of a post are defined in the Metadata section , then they are gathered and processed in templates later. --- title : title description : description tags : - python - mkdocs --- 3. The Tags page \u2693\ufe0e The tag page is the place to list all tags, and list all pages that have a common tag. A new page will be created at docs\\tags\\index.md . There is a method to use MkDocs Macros in Markdown template, but it is quite complicated. I use Jinja syntax to create the content of the Tags page, therefore, create a new file at overrides\\tags.html and use it as the template for the Tags page: docs\\tags\\index.md --- title : Tags description : Tags and list of pages template : tags.html hide : - disqus --- # Tags The tags.html template to include 2 parts: tag-cloud.html : make a tag cloud to see how many pages are associated with a tag tag-list-pages.html : for each tag, list all pages having that tag to show similar articles together overrides\\tags.html {% extends \"main.html\" %} {% block page_content %} <style> .tag-cloud-toc { display: none; } </style> {% include \"partials/tag-cloud.html\" %} {% include \"partials/tag-page-list.html\" %} {% endblock %} Tags will have random colors, to easily disguise them to each other. A helper random_color() macro that returns a random color looks like: overrides\\partials\\random-colors.html {% - macro random_color () - %} {{ - [ \"DarkRed\" , \"DarkGoldenrod\" , \"DarkGreen\" , \"DarkOliveGreen\" , \"DarkCyan\" , \"DarkTurquoise\" , \"DarkBlue\" , \"DarkMagenta\" , \"DarkViolet\" , \"DarkSlateBlue\" , \"DarkOrchid\" , \"DarkSlateGray\" ] | random - }} {% - endmacro - %} Then it can be imported as: {% from \"partials/random-colors.html\" import random_color %} 3.1. The tag cloud \u2693\ufe0e The tag cloud shows all tags in different size and color. The bigger a tag is, the more pages mention that tag. Steps to make a tag cloud: Scan all pages and create a list of pairs (tag, pages[]) {% set tags =[] %} {# scan all pages #} {% for p in pages %} {% if p.page.meta.tags %} {# extract tags if available #} {% for tag in p.page.meta.tags %} {% if tags | length %} {% set ns = namespace ( found = False ) %} {# read more about scope at https://jinja.palletsprojects.com/en/2.11.x/templates/#assignments #} {# check if tag exists, append to its page list #} {% for item in tags %} {% set t , ps = item %} {% if tag == t %} {% set ns.found = True %} {{ ps.append ( p.page ) or \"\" }} {# use (or \"\") to not print} #} {% endif %} {% endfor %} {# if tag doesn't exist, create new page list#} {% if not ns.found %} {{ tags.append (( tag , [ p.page ])) or \"\" }} {% endif %} {% else %} {{ tags.append (( tag , [ p.page ])) or \"\" }} {% endif %} {% endfor %} {% endif %} {% endfor %} Count the number of pages for each tag then show each tag with different text size and color using font-size and color attributes <p class=\"md-nav\"> <label class=\"md-nav__title\">Tag cloud</label> </p> <div class=\"tag-cloud-content\"> {% if tags | count %} {% for item in tags %} {% set tag , ps = item %} {# create a link with tag name #} {# font size is based on the page count #} <a class=\"tag\" href=\" {{ config.site_url }} tags/# {{ tag }} \"> <span class=\"tag-name\" style=\" font-size: {{ 0.6 + ps | count * 0.1 }} rem; color: {{ random_color () }} ; \"> {{ - tag - }} </span> <sup class=\"tag-count\"> {{ - ps | count - }} </sup> </a> {% endfor %} {% else %} <div> <h3>No tag found!</h3> </div> {% endif %} </div> 3.2. List pages of a tag \u2693\ufe0e This section is simple as it just needs to loop through the list of pairs (tag, pages[]) and create a link to each page. Steps to take that: Scan all pages and create a list of pairs (tag, pages[]) see above section Show each tag with the list of pages in a collapsible <details> block <div class=\"tag-page-list\"> {% for item in tags %} {% set tag , ps = item %} <details class=\"note\" id= {{ tag }} > <summary> {{ - tag }} ( {{ - ps | count - }} ) <a class=\"headerlink\" href=\"# {{ tag }} \">\u2693\ufe0e</a> </summary> <ol> {% for p in ps %} <li> <a href=\" {{ page.canonical_url }} \"> {% - if p.meta and p.meta.title_full - %} {{ - p.meta.title_full - }} {% - elif p.meta and p.meta.title - %} {{ - p.meta.title - }} {% - else - %} {{ - p.title - }} ` {% - endif - %} </a> </li> {% endfor %} </ol> </details> {% endfor %} </div> Only one tag block is open at a time to easily follow the selected tag. To do this, I added a callback of the toggle event on all tag blocks. Whenever a block is opened, this script will close all others [... document . getElementsByTagName ( \"details\" )]. forEach (( D , _ , A ) => { D . open = false ; D . addEventListener ( \"toggle\" , ( E ) => D . open && A . forEach (( d ) => d != E . target && ( d . open = false )) ); }); A tag block can be opened via URL with hash being the selected tag var hash = window . location . hash . substr ( 1 ); if ( hash ) { document . getElementById ( hash ). open = true ; } Visit the Tags to see the result. 4. The recent blog posts \u2693\ufe0e There should be a page showing the recent posts to help users see what is new and updated. With the Revision Date plugin, it is able to use two new meta-data fields: git_revision_date_localized , and git_creation_date_localized if the option enable_creation_date is true . Create new index.md file inside the blog folder. When using the Section Index plugin, this index file will be merged to the Blog section, therefore, when user selects the Blog label, there is a list of recent posts will be shown. This page will use the blog.html template in which it scans all posts and check the creation date to make a list of posts. Each post should be displayed in a container and be formatted to show the title, the description (at most 250 character using the truncate filter), the creation date, and its tags. Need to check the page\u2019s path to filter blog posts. In my code, I use the abs_url and its length to check if a page is in the blog directory. Here is the code to sort all pages in order of creation date, and then filter all blog posts to save into the array blog_pages which will be used to generate content. {% set blog_pages =[] %} {% for p in pages | sort ( attribute = 'page.meta.git_creation_date_localized' , reverse = True ) %} {% set pg = p.page %} {% if pg.abs_url.startswith ( '/blog/' ) and pg.abs_url | length > 6 %} {{ blog_pages.append ( pg ) or \"\" }} {% endif %} {% endfor %} <div class=\"pages\"> ... create list from blog_pages ... </div> 4.1. Create the pagination \u2693\ufe0e When the number of posts goes bigger, the recent post list becomes longer. It\u2019s time to brake the long list into pages \u2014 the user can click on the page number to see its children posts. This is called \u201cPagination\u201d. How to implement it? Jinja template has the slice filter to divide a list into sub-lists. Here, I\u2019d like to have maximum of 10 posts on each page. {% set page_num = ( blog_pages | count / 10 )| int %} {% if page_num == 0 %} {% set page_num = 1 %} {% endif %} <div class=\"pages\"> {% for pg_group in blog_pages | slice ( page_num ) %} <div class=\"page\" id=\"page {{ loop .index }} \"> {% for pg in pg_group %} <div class=\"post\"> ... create post layout and content ... </div> {% endfor %} </div> {% endfor %} </div> 4.2. Create a post-entry \u2693\ufe0e Each post is wrapped inside a < div class = \"post\" > and its elements are marked with different classes, such as post-title , post-description , etc. for applying styles later. <div class=\"post\"> <h3 class=\"post-title\"> <a class=\"link\" href=\" {{ pg.canonical_url }} \"> {{ title }} </a> </h3> <p class=\"post-description\"> {% if pg.meta.description %} {{ pg.meta.description | truncate }} {% endif %} </p> <div class=\"post-extra\"> <span class=\"post-timestamp\"> {% if pg.meta and pg.meta.git_revision_date_localized %} <span class=\"post-timestamp-update\"> Updated: {{ pg.meta.git_revision_date_localized - }} </span> {% endif %} </span> <span class=\"post-tags\"> {% if pg.meta.tags %} {% for tag in pg.meta.tags %} <a class=\"tag\" href=\" {{ config.site_url }} tags/# {{ tag }} \"> <span class=\"tag-name\" style=\"color: {{ random_color () }} ;\"> # {{ tag }} </span> </a> {% endfor %} {% endif %} </span> </div> <hr /> </div> Here is a simple style to make each post display necessary basic information: . md-typeset . post : first-of-type h3 { margin-top : 0 ; } . md-typeset . post-title { margin-bottom : 0 ; } . md-typeset . post-extra { color : gray ; } . md-typeset . post-tags { float : right ; } 4.3. Create active page \u2693\ufe0e To show the current active page, I use pure CSS and JavaScript. The idea is to use the URL hash to detect which page is activated, such as #page1 . <div class=\"center\"> <div class=\"pagination\" id=\"pagination\"> <a href=\"#\">&laquo;</a> {% for pg_group in blog_pages | slice ( page_num ) %} <a class=\"page-number {% if loop .index == 1 %} active {% endif %} \" href=\"#page {{ loop .index }} \"> {{ loop .index }} </a> {% endfor %} <a href=\"#\">&raquo;</a> </div> </div> Then add some styles to the pagination block and its children links: CSS Styles : Use target keyword to select the selected page ID , then show only the target element. assets\\extra.css . md-typeset . pages > . page : target ~ . page : last-child , . md-typeset . pages > . page { display : none ; } . md-typeset . pages > : last-child , . md-typeset . pages > . page : target { display : block ; } JavaScript When the page is loaded, a script will run to get all pagination\u2019s links, and then add a callback function for click event, that remove active class from last activated element and then assign active class to the event\u2019s source element. Note that the first page is activated by default when the page is loaded. assets\\extra.js var pagination = document . getElementById ( \"pagination\" ); var links = pagination . getElementsByClassName ( \"page-number\" ); if ( links . length ) { for ( var i = 0 ; i < links . length ; i ++ ) { links [ i ]. addEventListener ( \"click\" , function () { var current = pagination . getElementsByClassName ( \"active\" ); console . log ( current ); if ( current . length ) { current [ 0 ]. className = current [ 0 ]. className . replace ( \" active\" , \"\" ); } this . className += \" active\" ; }); } links [ 0 ]. click (); } 5. The main template \u2693\ufe0e The main.html file, extending the base.html template, will be used for all markdown pages, and it is the starting point to add custom template. To override it, add the main.html file in the overrides folder. Here are things I\u2019m going to do to add more content into a blog post: Extract metadata to get title , title_full , description , tags , and other information {% set title = config.site_name %} {% if page and page.meta and page.meta.title_full %} {% set title = page.meta.title_full %} {% elif page and page.meta and page.meta.title %} {% set title = page.meta.title %} {% elif page and page.title %} {% set title = page.title %} {% endif %} {% set description = config.site_description %} {% if page and page.meta and page.meta.description %} {% set description = page.meta.description %} {% endif %} {% if page and page.meta and page.meta.banner %} {% set image = page.meta.banner %} {% endif %} {% if page and page.meta and page.meta.tags %} {% set tags = page.meta.tags %} {% endif %} Add block to use the Open Graph protocol to show the page\u2019s information when a user shares a page on a social network {% block htmltitle %} <title> {{ title | striptags }} - {{ config.site_name }} </title> {% endblock %} {% block extrahead %} <meta property=\"og:type\" content=\"website\" /> <meta property=\"og:title\" content=\" {{ - title | striptags ~ ' - ' ~ config.site_name - }} \"/> <meta property=\"og:description\" content=\" {{ description }} \" /> <meta property=\"og:url\" content=\" {{ page.canonical_url }} \" /> <meta property=\"og:image\" content=\" {% - if image is defined - %} {{ page.canonical_url ~ image }} {% - else - %} {{ config.site_url ~ 'assets/banner.jpg' }} {% - endif - %} \" /> <meta property=\"og:site_name\" content=\" {{ config.site_name }} \" /> <meta name=\"twitter:card\" content=\"summary\" /> {% endblock %} The page content should have a cover section which displays the title , description and tags on all pages, except the home page. {% block content %} {% if not page.is_homepage %} <div class=\"cover\"> <h1 class=\"page-title\"> {{ title | d ( config.site_name , true ) }} </h1> <p class=\"page-description\"> {{ description }} </p> {% if tags is defined %} <p class=\"page-tags\"> {% for tag in tags %} <a class=\"tag\" href=\" {{ config.site_url }} tags/# {{ tag }} \"> <span class=\"tag-name\"> # {{ tag }} </span> </a> {% endfor %} </p> {% endif %} </div> {% endif %} {{ page.content }} {% endblock %} The tag cloud should show in the sidebars based on the page\u2019s width {% block site_nav %} {% if nav %} {% if page and page.meta and page.meta.hide %} {% set hidden = \"hidden\" if \"navigation\" in page.meta.hide %} {% endif %} <div class=\"md-sidebar md-sidebar--primary\" data-md-component=\"sidebar\" data-md-type=\"navigation\" {{ hidden }} > <div class=\"md-sidebar__scrollwrap\"> <div class=\"md-sidebar__inner\"> {% include \"partials/nav.html\" %} <div class=\"tag-cloud-nav\"> {% include \"partials/tag-cloud.html\" %} </div> </div> </div> </div> {% endif %} {% if page.toc and not \"toc.integrate\" in features %} {% if page and page.meta and page.meta.hide %} {% set hidden = \"hidden\" if \"toc\" in page.meta.hide %} {% endif %} <div class=\"md-sidebar md-sidebar--secondary\" data-md-component=\"sidebar\" data-md-type=\"toc\" {{ hidden }} > <div class=\"md-sidebar__scrollwrap\"> <div class=\"md-sidebar__inner\"> {% include \"partials/toc.html\" %} <div class=\"tag-cloud-toc\"> {% include \"partials/tag-cloud.html\" %} </div> </div> </div> </div> {% endif %} {% endblock %} 6. Zoom-in Images \u2693\ufe0e As mentioned in the Images section, view-bigimg library helps to zoom and pan images. It\u2019s useful when the image is in high resolution and resized to fit site\u2019s width. Download view-bigimg.css and view-bigimg.js files from the view-bigimg repo, then add them into the addition assets configs in mkdocs.yml : mkdocs.yml extra_css : - assets/view-bigimg.css extra_javascript : - assets/view-bigimg.js When click on the image, this library will create a new layer and show the image in a bigger size. However, it must be clicked on the close button to go back to the page\u2019s content. I want to simplify this step by just click on the image. Panning still is activated by press and hold. Therefore, I write a function to detect mousedown and mousemove event, then only close the image if it is a simple click: assets\\extra.js var dragged = false ; document . addEventListener ( \"mousedown\" , () => ( dragged = false )); document . addEventListener ( \"mousemove\" , () => ( dragged = true )); var viewer = new ViewBigimg (); var figures = document . querySelectorAll ( \"img\" ); for ( var i = 0 ; i < figures . length ; i ++ ) { figures [ i ]. onclick = ( e ) => { if ( e . target . nodeName === \"IMG\" ) { viewer . show ( e . target . src ); } }; } var containers = document . querySelectorAll ( \"#iv-container .iv-image-view\" ); for ( var i = 0 ; i < containers . length ; i ++ ) { containers [ i ]. onclick = () => { if ( ! dragged ) { viewer . hide (); } }; } 7. Open external links \u2693\ufe0e When following links, to remain the blog page opened, external links should be shown in new tabs without any tracking information. To do that, I write some lines of code to get all external links in the page, then set target = \"_blank\" and add attribute rel = \"noopener noreferrer\" to them. assets\\extra.js /* open external links in new tab */ var links = document . links ; for ( var i = 0 , linksLength = links . length ; i < linksLength ; i ++ ) { if ( links [ i ]. hostname != window . location . hostname ) { links [ i ]. target = \"_blank\" ; links [ i ]. setAttribute ( \"rel\" , \"noopener noreferrer\" ); links [ i ]. className += \" externalLink\" ; } else { links [ i ]. className += \" localLink\" ; } } 8. Custom styles \u2693\ufe0e After all extensions and plugins are installed, some extra pages and elements are added, this is the time to tweak the whole site\u2019s styles. 8.1. Colors \u2693\ufe0e Here are some small additional styles to make the theme look a bit harmonious with the selected theme color Logo and headers should be in orange to be highlighted, and active links can be in dark blue: . md-logo , . md-typeset h1 { color : orangered ; } . md-typeset h2 , . md-typeset h3 , . md-typeset h4 , . md-tabs__link . md-tabs__link--active , . md-nav__link . md-nav__link--active { color : darkblue ; } Search input should have white background color: . md-search__input { background-color : white !important ; } Non-highlighted code needs stand out a bit in dark red in white background: . md-typeset code { color : darkred ; background-color : rgba ( 0 , 0 , 0 , 0.01 ); } Normal paragraph should be fully justified: . md-typeset p { text-align : justify ; } Emphasized text should be in dark magenta: . md-typeset em { color : darkmagenta ; } Footer should look smaller by changing the background color: . md-footer { color : unset ; background-color : unset ; } . md-footer-meta { background-color : black ; } The highlight color should not be too yellowish, I\u2019d like to reduce its opacity: : root > * { --md-code-hl-color : rgba ( 255 , 255 , 0 , 0.1 ); --md-typeset-mark-color : var ( --md-code-hl-color ); } 8.2. Admonition \u2693\ufe0e I want to make admonitions look more harmonious to the theme, so I decided to remove border and shadow box, then add a light background color which is the title background color of each type. The font and the margin also need modified a bit to make admonitions look consistent to the main content. First, icon should be bigger: . md-typeset . admonition-title : before , . md-typeset summary : before { height : 1.2 rem ; width : 1.2 rem ; } Remove border, shadow box, and increase font size: . md-typeset . admonition , . md-typeset details { border : none ; box-shadow : none ; font-size : 0.95 em ; margin-top : 0 ; } Remove background color in the title, step it back to the right, due to the increased icon size: . md-typeset . admonition > . admonition-title , . md-typeset details > summary { background-color : transparent !important ; border-left : 0.2 rem solid transparent !important ; padding-left : 3 em ; } Fill background color for different admonition types: . md-typeset . admonition . note , . md-typeset details . note { background-color : rgba ( 68 , 138 , 255 , 0.05 ); } . md-typeset . admonition . abstract , . md-typeset . admonition . summary , . md-typeset . admonition . tldr , . md-typeset details . abstract , . md-typeset details . summary , . md-typeset details . tldr { background-color : rgba ( 0 , 176 , 255 , 0.05 ); } . md-typeset . admonition . info , . md-typeset . admonition . todo , . md-typeset details . info , . md-typeset details . todo { background-color : rgba ( 0 , 184 , 212 , 0.05 ); } . md-typeset . admonition . hint , . md-typeset . admonition . important , . md-typeset . admonition . tip , . md-typeset details . hint , . md-typeset details . important , . md-typeset details . tip { background-color : rgba ( 0 , 191 , 165 , 0.05 ); } . md-typeset . admonition . check , . md-typeset . admonition . done , . md-typeset . admonition . success , . md-typeset details . check , . md-typeset details . done , . md-typeset details . success { background-color : rgba ( 0 , 200 , 83 , 0.05 ); } . md-typeset . admonition . faq , . md-typeset . admonition . help , . md-typeset . admonition . question , . md-typeset details . faq , . md-typeset details . help , . md-typeset details . question { background-color : rgba ( 100 , 221 , 23 , 0.05 ); } . md-typeset . admonition . attention , . md-typeset . admonition . caution , . md-typeset . admonition . warning , . md-typeset details . attention , . md-typeset details . caution , . md-typeset details . warning { background-color : rgba ( 255 , 145 , 0 , 0.05 ); } . md-typeset . admonition . fail , . md-typeset . admonition . failure , . md-typeset . admonition . missing , . md-typeset details . fail , . md-typeset details . failure , . md-typeset details . missing { background-color : rgba ( 255 , 82 , 82 , 0.05 ); } . md-typeset . admonition . danger , . md-typeset . admonition . error , . md-typeset details . danger , . md-typeset details . error { background-color : rgba ( 255 , 23 , 68 , 0.05 ); } . md-typeset . admonition . bug , . md-typeset details . bug { background-color : rgba ( 245 , 0 , 87 , 0.05 ); } . md-typeset . admonition . example , . md-typeset details . example { background-color : rgba ( 124 , 77 , 255 , 0.05 ); } . md-typeset . admonition . cite , . md-typeset . admonition . quote , . md-typeset details . cite , . md-typeset details . quote { background-color : hsla ( 0 , 0 % , 62 % , 0.05 ); } Make the content close to the title a bit: . md-typeset . admonition > . admonition-title + *, . md-typeset details > summary + * { margin-top : 0 ; } Change admonition style And tweak the style to show admonitions which has icon but do not have title. The trick is to add left padding to the first letter in the content paragraph, and move the content up by applying a negative top margin: . md-typeset . admonition . no-title > . admonition-title + p :: first-letter , . md-typeset details . no-title > summary + p :: first-letter { padding-left : 2.2 em ; } . md-typeset . admonition . no-title > . admonition-title + *, . md-typeset details . no-title > summary + * { margin-top : -2.1 em ; } Use these additional styles, with .no-title class and an empty title (use \"&nbsp;\" or \"\\ \" ): !!! info no-title \"\\ \" This admonition has an icon as an inline element with the content !!! info Default title !!! info \"New title\" Content of the admonition is indented !!! info \"\" There is no title and no icon This admonition has an icon as an inline element with the content Info Default title New title Content of the admonition There is no title and no icon 8.3. Quotes \u2693\ufe0e Quote is used to provide additional data, so I changed its style a bit to not make it confusing with the main text. . md-typeset blockquote { color : unset ; border-left-width : 2 px ; opacity : 0.7 ; } . md-typeset blockquote : first-child { margin-top : 0.25 em ; } . md-typeset blockquote : last-child { margin-bottom : 0.25 em ; } Admonition also has quote and cite type which are used as cited content. 8.4. Code block \u2693\ufe0e It is better to show the line number inline with its line of code: markdown_extensions : - meta - pymdownx.superfences - pymdownx.highlight : linenums_style : pymdownx-inline And then increase the font size to get make them easy to read: . md-typeset code , . md-typeset kbd { font-size : 1 em ; word-break : keep-all !important ; } . md-typeset pre code { white-space : pre-wrap ; font-size : 0.9 em ; } Then the line number should be dimmed to not distract the main code: . md-typeset . highlight [ data-linenos ] : before { background-color : transparent ; box-shadow : none ; color : lightgray ; } #include <stdio.h> int main ( void ) { printf ( \"Hello world! \\n \" ); return 0 ; } 8.5. Tables \u2693\ufe0e Table should show cell border and use a full width to make the content clear. . md-typeset__scrollwrap { margin : unset ; } . md-typeset__table { padding : 0 ; display : block ; } . md-typeset table : not ([ class ]) { font-size : 0.9 em ; box-shadow : none ; display : table ; border-collapse : collapse ; } . md-typeset table : not ([ class ]) th , . md-typeset table : not ([ class ]) td { padding : 0.5 em ; border : 1 px solid #f0f0f0 ; min-width : unset ; } Syntax Description Test Text Left align Center align Right align A text Another text More texts 8.6. Tabs \u2693\ufe0e Tab\u2019s content should show some intent to visualize its structure. The label is tweaked a bit to look consisted with its content at the left margin. Note that in printing, all tabs will be expanded to show all of its content. . md-typeset . tabbed-content { box-shadow : none ; border-top : 1 px solid var ( --md-default-fg-color--lightest ); } . md-typeset . tabbed-content > . tabbed-set { padding-left : 2 em ; } . md-typeset . tabbed-set > label { font-size : 0.9 em ; padding : 0 margin-right : 1.25 em ; } Tab 1 Some texts Tab A Text A Tab B Text B Tab 2 Some other texts 8.7. Buttons \u2693\ufe0e When using white primary color, the default button class md-button has issues to display correctly. Here are the fix for those buttons: change the margin to make them smaller change the border, and text color change the size of the icon . md-typeset . md-button { font-size : small ; font-weight : unset ; padding : 0.25 em 0.5 em ; border : 1 px solid ; color : orangered ; } . md-typeset . md-button . twemoji { font-size : large ; } Click here 8.8. Image caption \u2693\ufe0e The caption should not have restricted width, and its bottom margin should be smaller. . md-typeset figcaption { max-width : unset ; margin : 1 em auto ; } A photo from https://picsum.photos 8.9. Sidebar scrolls \u2693\ufe0e Only show the scrollbar when hovering to make sidebar look clear. . md-sidebar__scrollwrap { overflow : hidden ; } . md-sidebar__scrollwrap : hover { overflow-y : auto ; } 8.10. Spaces \u2693\ufe0e This part modifies some small space gap and margins to make the overall layout look better. Remove some space gaps. . md-main__inner { margin-top : 0 ; } md-typeset dd { margin : 0 em 0 1 em 1.875 em ; } . md-typeset dd > * { margin-top : 0 ; } . md-typeset p : empty { display : none ; } . md-typeset . admonition + *, . md-typeset details + * { margin-top : 0 ; } /* .md-typeset blockquote, */ . md-typeset dl , . md-typeset figure , . md-typeset ol , . md-typeset pre , . md-typeset ul { margin-top : 0 ; margin-bottom : 0 ; } 8.11. Tags \u2693\ufe0e Add styles to have a space between tags. . tag { white-space : nowrap ; margin-right : 0.25 em ; } Then the tag cloud should have some indent: . tag-cloud-content { padding : 0 0.6 rem ; margin-bottom : 1 em ; } 8.12. New elements \u2693\ufe0e 8.12.1. New span \u2693\ufe0e Class .ns is used in a new span to clear font-style of the target element, when using attribute list on it. . md-typeset . ns { font-style : unset ; } An example of adding .ns class to an emphasized word: _without new span: italic style_ \\ _with new span: normal style thanks to `.ns` class_ {.ns} without new span: italic style with new span: normal style thanks to .ns class 8.12.2. Row and Column \u2693\ufe0e With Custom Blocks extension, I can make column layout with class .row and .col . Here are the style to make column layout in a row, and set column\u2019s margins: . md-typeset . row { display : flex ; flex-direction : row ; } . md-typeset . row . col { display : flex ; flex-direction : column ; width : 100 % ; margin : 0 0.25 em ; } . md-typeset . row . col : first-of-type { margin-left : 0 ; } . md-typeset . row . col : last-of-type { margin-right : 0 ; } A column will try to fit 100% of the page width. To set a percentage, use the class .wXX for the width of XX% . These classes can be applied to other elements too. And here is an example to create 2 columns, a big one is 80% page width: ::: row ::: col w80 style=\"background-color: lightyellow;\" A big column using 80% of page width ::: col w20 style=\"background-color: lightblue;\" A small column A big column using 80% of page width A small column","title":"Customize theme"},{"location":"blog/setup-blog/customize-theme/#1-the-posts-title","text":"By using the Awesome Pages plugin and the Section index plugin, the navigation sidebar can show a good structure of posts. However, each entry is displaying the post\u2019s title with long text, this make the navigation bar look a bit messy. It is easy to add a full title into a post by using the Metadata section . For example: --- title : Customize theme title_full : Customize the theme with personal styles description : A personal website should look different to others ... --- However, the content of each post will also display the short title. To fix this, I am going to override the main template. Before do it, I will add tags in the Metadata section also.","title":"1. The post's title"},{"location":"blog/setup-blog/customize-theme/#2-the-posts-tags","text":"A tag is a word or a phrase that describes one main point of a blog post\u2019s content. They are an easy way to attach labels to the content and link similar posts together. The tags of a post are defined in the Metadata section , then they are gathered and processed in templates later. --- title : title description : description tags : - python - mkdocs ---","title":"2. The post's tags"},{"location":"blog/setup-blog/customize-theme/#3-the-tags-page","text":"The tag page is the place to list all tags, and list all pages that have a common tag. A new page will be created at docs\\tags\\index.md . There is a method to use MkDocs Macros in Markdown template, but it is quite complicated. I use Jinja syntax to create the content of the Tags page, therefore, create a new file at overrides\\tags.html and use it as the template for the Tags page: docs\\tags\\index.md --- title : Tags description : Tags and list of pages template : tags.html hide : - disqus --- # Tags The tags.html template to include 2 parts: tag-cloud.html : make a tag cloud to see how many pages are associated with a tag tag-list-pages.html : for each tag, list all pages having that tag to show similar articles together overrides\\tags.html {% extends \"main.html\" %} {% block page_content %} <style> .tag-cloud-toc { display: none; } </style> {% include \"partials/tag-cloud.html\" %} {% include \"partials/tag-page-list.html\" %} {% endblock %} Tags will have random colors, to easily disguise them to each other. A helper random_color() macro that returns a random color looks like: overrides\\partials\\random-colors.html {% - macro random_color () - %} {{ - [ \"DarkRed\" , \"DarkGoldenrod\" , \"DarkGreen\" , \"DarkOliveGreen\" , \"DarkCyan\" , \"DarkTurquoise\" , \"DarkBlue\" , \"DarkMagenta\" , \"DarkViolet\" , \"DarkSlateBlue\" , \"DarkOrchid\" , \"DarkSlateGray\" ] | random - }} {% - endmacro - %} Then it can be imported as: {% from \"partials/random-colors.html\" import random_color %}","title":"3. The Tags page"},{"location":"blog/setup-blog/customize-theme/#31-the-tag-cloud","text":"The tag cloud shows all tags in different size and color. The bigger a tag is, the more pages mention that tag. Steps to make a tag cloud: Scan all pages and create a list of pairs (tag, pages[]) {% set tags =[] %} {# scan all pages #} {% for p in pages %} {% if p.page.meta.tags %} {# extract tags if available #} {% for tag in p.page.meta.tags %} {% if tags | length %} {% set ns = namespace ( found = False ) %} {# read more about scope at https://jinja.palletsprojects.com/en/2.11.x/templates/#assignments #} {# check if tag exists, append to its page list #} {% for item in tags %} {% set t , ps = item %} {% if tag == t %} {% set ns.found = True %} {{ ps.append ( p.page ) or \"\" }} {# use (or \"\") to not print} #} {% endif %} {% endfor %} {# if tag doesn't exist, create new page list#} {% if not ns.found %} {{ tags.append (( tag , [ p.page ])) or \"\" }} {% endif %} {% else %} {{ tags.append (( tag , [ p.page ])) or \"\" }} {% endif %} {% endfor %} {% endif %} {% endfor %} Count the number of pages for each tag then show each tag with different text size and color using font-size and color attributes <p class=\"md-nav\"> <label class=\"md-nav__title\">Tag cloud</label> </p> <div class=\"tag-cloud-content\"> {% if tags | count %} {% for item in tags %} {% set tag , ps = item %} {# create a link with tag name #} {# font size is based on the page count #} <a class=\"tag\" href=\" {{ config.site_url }} tags/# {{ tag }} \"> <span class=\"tag-name\" style=\" font-size: {{ 0.6 + ps | count * 0.1 }} rem; color: {{ random_color () }} ; \"> {{ - tag - }} </span> <sup class=\"tag-count\"> {{ - ps | count - }} </sup> </a> {% endfor %} {% else %} <div> <h3>No tag found!</h3> </div> {% endif %} </div>","title":"3.1. The tag cloud"},{"location":"blog/setup-blog/customize-theme/#32-list-pages-of-a-tag","text":"This section is simple as it just needs to loop through the list of pairs (tag, pages[]) and create a link to each page. Steps to take that: Scan all pages and create a list of pairs (tag, pages[]) see above section Show each tag with the list of pages in a collapsible <details> block <div class=\"tag-page-list\"> {% for item in tags %} {% set tag , ps = item %} <details class=\"note\" id= {{ tag }} > <summary> {{ - tag }} ( {{ - ps | count - }} ) <a class=\"headerlink\" href=\"# {{ tag }} \">\u2693\ufe0e</a> </summary> <ol> {% for p in ps %} <li> <a href=\" {{ page.canonical_url }} \"> {% - if p.meta and p.meta.title_full - %} {{ - p.meta.title_full - }} {% - elif p.meta and p.meta.title - %} {{ - p.meta.title - }} {% - else - %} {{ - p.title - }} ` {% - endif - %} </a> </li> {% endfor %} </ol> </details> {% endfor %} </div> Only one tag block is open at a time to easily follow the selected tag. To do this, I added a callback of the toggle event on all tag blocks. Whenever a block is opened, this script will close all others [... document . getElementsByTagName ( \"details\" )]. forEach (( D , _ , A ) => { D . open = false ; D . addEventListener ( \"toggle\" , ( E ) => D . open && A . forEach (( d ) => d != E . target && ( d . open = false )) ); }); A tag block can be opened via URL with hash being the selected tag var hash = window . location . hash . substr ( 1 ); if ( hash ) { document . getElementById ( hash ). open = true ; } Visit the Tags to see the result.","title":"3.2. List pages of a tag"},{"location":"blog/setup-blog/customize-theme/#4-the-recent-blog-posts","text":"There should be a page showing the recent posts to help users see what is new and updated. With the Revision Date plugin, it is able to use two new meta-data fields: git_revision_date_localized , and git_creation_date_localized if the option enable_creation_date is true . Create new index.md file inside the blog folder. When using the Section Index plugin, this index file will be merged to the Blog section, therefore, when user selects the Blog label, there is a list of recent posts will be shown. This page will use the blog.html template in which it scans all posts and check the creation date to make a list of posts. Each post should be displayed in a container and be formatted to show the title, the description (at most 250 character using the truncate filter), the creation date, and its tags. Need to check the page\u2019s path to filter blog posts. In my code, I use the abs_url and its length to check if a page is in the blog directory. Here is the code to sort all pages in order of creation date, and then filter all blog posts to save into the array blog_pages which will be used to generate content. {% set blog_pages =[] %} {% for p in pages | sort ( attribute = 'page.meta.git_creation_date_localized' , reverse = True ) %} {% set pg = p.page %} {% if pg.abs_url.startswith ( '/blog/' ) and pg.abs_url | length > 6 %} {{ blog_pages.append ( pg ) or \"\" }} {% endif %} {% endfor %} <div class=\"pages\"> ... create list from blog_pages ... </div>","title":"4. The recent blog posts"},{"location":"blog/setup-blog/customize-theme/#41-create-the-pagination","text":"When the number of posts goes bigger, the recent post list becomes longer. It\u2019s time to brake the long list into pages \u2014 the user can click on the page number to see its children posts. This is called \u201cPagination\u201d. How to implement it? Jinja template has the slice filter to divide a list into sub-lists. Here, I\u2019d like to have maximum of 10 posts on each page. {% set page_num = ( blog_pages | count / 10 )| int %} {% if page_num == 0 %} {% set page_num = 1 %} {% endif %} <div class=\"pages\"> {% for pg_group in blog_pages | slice ( page_num ) %} <div class=\"page\" id=\"page {{ loop .index }} \"> {% for pg in pg_group %} <div class=\"post\"> ... create post layout and content ... </div> {% endfor %} </div> {% endfor %} </div>","title":"4.1. Create the pagination"},{"location":"blog/setup-blog/customize-theme/#42-create-a-post-entry","text":"Each post is wrapped inside a < div class = \"post\" > and its elements are marked with different classes, such as post-title , post-description , etc. for applying styles later. <div class=\"post\"> <h3 class=\"post-title\"> <a class=\"link\" href=\" {{ pg.canonical_url }} \"> {{ title }} </a> </h3> <p class=\"post-description\"> {% if pg.meta.description %} {{ pg.meta.description | truncate }} {% endif %} </p> <div class=\"post-extra\"> <span class=\"post-timestamp\"> {% if pg.meta and pg.meta.git_revision_date_localized %} <span class=\"post-timestamp-update\"> Updated: {{ pg.meta.git_revision_date_localized - }} </span> {% endif %} </span> <span class=\"post-tags\"> {% if pg.meta.tags %} {% for tag in pg.meta.tags %} <a class=\"tag\" href=\" {{ config.site_url }} tags/# {{ tag }} \"> <span class=\"tag-name\" style=\"color: {{ random_color () }} ;\"> # {{ tag }} </span> </a> {% endfor %} {% endif %} </span> </div> <hr /> </div> Here is a simple style to make each post display necessary basic information: . md-typeset . post : first-of-type h3 { margin-top : 0 ; } . md-typeset . post-title { margin-bottom : 0 ; } . md-typeset . post-extra { color : gray ; } . md-typeset . post-tags { float : right ; }","title":"4.2. Create a post-entry"},{"location":"blog/setup-blog/customize-theme/#43-create-active-page","text":"To show the current active page, I use pure CSS and JavaScript. The idea is to use the URL hash to detect which page is activated, such as #page1 . <div class=\"center\"> <div class=\"pagination\" id=\"pagination\"> <a href=\"#\">&laquo;</a> {% for pg_group in blog_pages | slice ( page_num ) %} <a class=\"page-number {% if loop .index == 1 %} active {% endif %} \" href=\"#page {{ loop .index }} \"> {{ loop .index }} </a> {% endfor %} <a href=\"#\">&raquo;</a> </div> </div> Then add some styles to the pagination block and its children links: CSS Styles : Use target keyword to select the selected page ID , then show only the target element. assets\\extra.css . md-typeset . pages > . page : target ~ . page : last-child , . md-typeset . pages > . page { display : none ; } . md-typeset . pages > : last-child , . md-typeset . pages > . page : target { display : block ; } JavaScript When the page is loaded, a script will run to get all pagination\u2019s links, and then add a callback function for click event, that remove active class from last activated element and then assign active class to the event\u2019s source element. Note that the first page is activated by default when the page is loaded. assets\\extra.js var pagination = document . getElementById ( \"pagination\" ); var links = pagination . getElementsByClassName ( \"page-number\" ); if ( links . length ) { for ( var i = 0 ; i < links . length ; i ++ ) { links [ i ]. addEventListener ( \"click\" , function () { var current = pagination . getElementsByClassName ( \"active\" ); console . log ( current ); if ( current . length ) { current [ 0 ]. className = current [ 0 ]. className . replace ( \" active\" , \"\" ); } this . className += \" active\" ; }); } links [ 0 ]. click (); }","title":"4.3. Create active page"},{"location":"blog/setup-blog/customize-theme/#5-the-main-template","text":"The main.html file, extending the base.html template, will be used for all markdown pages, and it is the starting point to add custom template. To override it, add the main.html file in the overrides folder. Here are things I\u2019m going to do to add more content into a blog post: Extract metadata to get title , title_full , description , tags , and other information {% set title = config.site_name %} {% if page and page.meta and page.meta.title_full %} {% set title = page.meta.title_full %} {% elif page and page.meta and page.meta.title %} {% set title = page.meta.title %} {% elif page and page.title %} {% set title = page.title %} {% endif %} {% set description = config.site_description %} {% if page and page.meta and page.meta.description %} {% set description = page.meta.description %} {% endif %} {% if page and page.meta and page.meta.banner %} {% set image = page.meta.banner %} {% endif %} {% if page and page.meta and page.meta.tags %} {% set tags = page.meta.tags %} {% endif %} Add block to use the Open Graph protocol to show the page\u2019s information when a user shares a page on a social network {% block htmltitle %} <title> {{ title | striptags }} - {{ config.site_name }} </title> {% endblock %} {% block extrahead %} <meta property=\"og:type\" content=\"website\" /> <meta property=\"og:title\" content=\" {{ - title | striptags ~ ' - ' ~ config.site_name - }} \"/> <meta property=\"og:description\" content=\" {{ description }} \" /> <meta property=\"og:url\" content=\" {{ page.canonical_url }} \" /> <meta property=\"og:image\" content=\" {% - if image is defined - %} {{ page.canonical_url ~ image }} {% - else - %} {{ config.site_url ~ 'assets/banner.jpg' }} {% - endif - %} \" /> <meta property=\"og:site_name\" content=\" {{ config.site_name }} \" /> <meta name=\"twitter:card\" content=\"summary\" /> {% endblock %} The page content should have a cover section which displays the title , description and tags on all pages, except the home page. {% block content %} {% if not page.is_homepage %} <div class=\"cover\"> <h1 class=\"page-title\"> {{ title | d ( config.site_name , true ) }} </h1> <p class=\"page-description\"> {{ description }} </p> {% if tags is defined %} <p class=\"page-tags\"> {% for tag in tags %} <a class=\"tag\" href=\" {{ config.site_url }} tags/# {{ tag }} \"> <span class=\"tag-name\"> # {{ tag }} </span> </a> {% endfor %} </p> {% endif %} </div> {% endif %} {{ page.content }} {% endblock %} The tag cloud should show in the sidebars based on the page\u2019s width {% block site_nav %} {% if nav %} {% if page and page.meta and page.meta.hide %} {% set hidden = \"hidden\" if \"navigation\" in page.meta.hide %} {% endif %} <div class=\"md-sidebar md-sidebar--primary\" data-md-component=\"sidebar\" data-md-type=\"navigation\" {{ hidden }} > <div class=\"md-sidebar__scrollwrap\"> <div class=\"md-sidebar__inner\"> {% include \"partials/nav.html\" %} <div class=\"tag-cloud-nav\"> {% include \"partials/tag-cloud.html\" %} </div> </div> </div> </div> {% endif %} {% if page.toc and not \"toc.integrate\" in features %} {% if page and page.meta and page.meta.hide %} {% set hidden = \"hidden\" if \"toc\" in page.meta.hide %} {% endif %} <div class=\"md-sidebar md-sidebar--secondary\" data-md-component=\"sidebar\" data-md-type=\"toc\" {{ hidden }} > <div class=\"md-sidebar__scrollwrap\"> <div class=\"md-sidebar__inner\"> {% include \"partials/toc.html\" %} <div class=\"tag-cloud-toc\"> {% include \"partials/tag-cloud.html\" %} </div> </div> </div> </div> {% endif %} {% endblock %}","title":"5. The main template"},{"location":"blog/setup-blog/customize-theme/#6-zoom-in-images","text":"As mentioned in the Images section, view-bigimg library helps to zoom and pan images. It\u2019s useful when the image is in high resolution and resized to fit site\u2019s width. Download view-bigimg.css and view-bigimg.js files from the view-bigimg repo, then add them into the addition assets configs in mkdocs.yml : mkdocs.yml extra_css : - assets/view-bigimg.css extra_javascript : - assets/view-bigimg.js When click on the image, this library will create a new layer and show the image in a bigger size. However, it must be clicked on the close button to go back to the page\u2019s content. I want to simplify this step by just click on the image. Panning still is activated by press and hold. Therefore, I write a function to detect mousedown and mousemove event, then only close the image if it is a simple click: assets\\extra.js var dragged = false ; document . addEventListener ( \"mousedown\" , () => ( dragged = false )); document . addEventListener ( \"mousemove\" , () => ( dragged = true )); var viewer = new ViewBigimg (); var figures = document . querySelectorAll ( \"img\" ); for ( var i = 0 ; i < figures . length ; i ++ ) { figures [ i ]. onclick = ( e ) => { if ( e . target . nodeName === \"IMG\" ) { viewer . show ( e . target . src ); } }; } var containers = document . querySelectorAll ( \"#iv-container .iv-image-view\" ); for ( var i = 0 ; i < containers . length ; i ++ ) { containers [ i ]. onclick = () => { if ( ! dragged ) { viewer . hide (); } }; }","title":"6. Zoom-in Images"},{"location":"blog/setup-blog/customize-theme/#7-open-external-links","text":"When following links, to remain the blog page opened, external links should be shown in new tabs without any tracking information. To do that, I write some lines of code to get all external links in the page, then set target = \"_blank\" and add attribute rel = \"noopener noreferrer\" to them. assets\\extra.js /* open external links in new tab */ var links = document . links ; for ( var i = 0 , linksLength = links . length ; i < linksLength ; i ++ ) { if ( links [ i ]. hostname != window . location . hostname ) { links [ i ]. target = \"_blank\" ; links [ i ]. setAttribute ( \"rel\" , \"noopener noreferrer\" ); links [ i ]. className += \" externalLink\" ; } else { links [ i ]. className += \" localLink\" ; } }","title":"7. Open external links"},{"location":"blog/setup-blog/customize-theme/#8-custom-styles","text":"After all extensions and plugins are installed, some extra pages and elements are added, this is the time to tweak the whole site\u2019s styles.","title":"8. Custom styles"},{"location":"blog/setup-blog/customize-theme/#81-colors","text":"Here are some small additional styles to make the theme look a bit harmonious with the selected theme color Logo and headers should be in orange to be highlighted, and active links can be in dark blue: . md-logo , . md-typeset h1 { color : orangered ; } . md-typeset h2 , . md-typeset h3 , . md-typeset h4 , . md-tabs__link . md-tabs__link--active , . md-nav__link . md-nav__link--active { color : darkblue ; } Search input should have white background color: . md-search__input { background-color : white !important ; } Non-highlighted code needs stand out a bit in dark red in white background: . md-typeset code { color : darkred ; background-color : rgba ( 0 , 0 , 0 , 0.01 ); } Normal paragraph should be fully justified: . md-typeset p { text-align : justify ; } Emphasized text should be in dark magenta: . md-typeset em { color : darkmagenta ; } Footer should look smaller by changing the background color: . md-footer { color : unset ; background-color : unset ; } . md-footer-meta { background-color : black ; } The highlight color should not be too yellowish, I\u2019d like to reduce its opacity: : root > * { --md-code-hl-color : rgba ( 255 , 255 , 0 , 0.1 ); --md-typeset-mark-color : var ( --md-code-hl-color ); }","title":"8.1. Colors"},{"location":"blog/setup-blog/customize-theme/#82-admonition","text":"I want to make admonitions look more harmonious to the theme, so I decided to remove border and shadow box, then add a light background color which is the title background color of each type. The font and the margin also need modified a bit to make admonitions look consistent to the main content. First, icon should be bigger: . md-typeset . admonition-title : before , . md-typeset summary : before { height : 1.2 rem ; width : 1.2 rem ; } Remove border, shadow box, and increase font size: . md-typeset . admonition , . md-typeset details { border : none ; box-shadow : none ; font-size : 0.95 em ; margin-top : 0 ; } Remove background color in the title, step it back to the right, due to the increased icon size: . md-typeset . admonition > . admonition-title , . md-typeset details > summary { background-color : transparent !important ; border-left : 0.2 rem solid transparent !important ; padding-left : 3 em ; } Fill background color for different admonition types: . md-typeset . admonition . note , . md-typeset details . note { background-color : rgba ( 68 , 138 , 255 , 0.05 ); } . md-typeset . admonition . abstract , . md-typeset . admonition . summary , . md-typeset . admonition . tldr , . md-typeset details . abstract , . md-typeset details . summary , . md-typeset details . tldr { background-color : rgba ( 0 , 176 , 255 , 0.05 ); } . md-typeset . admonition . info , . md-typeset . admonition . todo , . md-typeset details . info , . md-typeset details . todo { background-color : rgba ( 0 , 184 , 212 , 0.05 ); } . md-typeset . admonition . hint , . md-typeset . admonition . important , . md-typeset . admonition . tip , . md-typeset details . hint , . md-typeset details . important , . md-typeset details . tip { background-color : rgba ( 0 , 191 , 165 , 0.05 ); } . md-typeset . admonition . check , . md-typeset . admonition . done , . md-typeset . admonition . success , . md-typeset details . check , . md-typeset details . done , . md-typeset details . success { background-color : rgba ( 0 , 200 , 83 , 0.05 ); } . md-typeset . admonition . faq , . md-typeset . admonition . help , . md-typeset . admonition . question , . md-typeset details . faq , . md-typeset details . help , . md-typeset details . question { background-color : rgba ( 100 , 221 , 23 , 0.05 ); } . md-typeset . admonition . attention , . md-typeset . admonition . caution , . md-typeset . admonition . warning , . md-typeset details . attention , . md-typeset details . caution , . md-typeset details . warning { background-color : rgba ( 255 , 145 , 0 , 0.05 ); } . md-typeset . admonition . fail , . md-typeset . admonition . failure , . md-typeset . admonition . missing , . md-typeset details . fail , . md-typeset details . failure , . md-typeset details . missing { background-color : rgba ( 255 , 82 , 82 , 0.05 ); } . md-typeset . admonition . danger , . md-typeset . admonition . error , . md-typeset details . danger , . md-typeset details . error { background-color : rgba ( 255 , 23 , 68 , 0.05 ); } . md-typeset . admonition . bug , . md-typeset details . bug { background-color : rgba ( 245 , 0 , 87 , 0.05 ); } . md-typeset . admonition . example , . md-typeset details . example { background-color : rgba ( 124 , 77 , 255 , 0.05 ); } . md-typeset . admonition . cite , . md-typeset . admonition . quote , . md-typeset details . cite , . md-typeset details . quote { background-color : hsla ( 0 , 0 % , 62 % , 0.05 ); } Make the content close to the title a bit: . md-typeset . admonition > . admonition-title + *, . md-typeset details > summary + * { margin-top : 0 ; } Change admonition style And tweak the style to show admonitions which has icon but do not have title. The trick is to add left padding to the first letter in the content paragraph, and move the content up by applying a negative top margin: . md-typeset . admonition . no-title > . admonition-title + p :: first-letter , . md-typeset details . no-title > summary + p :: first-letter { padding-left : 2.2 em ; } . md-typeset . admonition . no-title > . admonition-title + *, . md-typeset details . no-title > summary + * { margin-top : -2.1 em ; } Use these additional styles, with .no-title class and an empty title (use \"&nbsp;\" or \"\\ \" ): !!! info no-title \"\\ \" This admonition has an icon as an inline element with the content !!! info Default title !!! info \"New title\" Content of the admonition is indented !!! info \"\" There is no title and no icon This admonition has an icon as an inline element with the content Info Default title New title Content of the admonition There is no title and no icon","title":"8.2. Admonition"},{"location":"blog/setup-blog/customize-theme/#83-quotes","text":"Quote is used to provide additional data, so I changed its style a bit to not make it confusing with the main text. . md-typeset blockquote { color : unset ; border-left-width : 2 px ; opacity : 0.7 ; } . md-typeset blockquote : first-child { margin-top : 0.25 em ; } . md-typeset blockquote : last-child { margin-bottom : 0.25 em ; } Admonition also has quote and cite type which are used as cited content.","title":"8.3. Quotes"},{"location":"blog/setup-blog/customize-theme/#84-code-block","text":"It is better to show the line number inline with its line of code: markdown_extensions : - meta - pymdownx.superfences - pymdownx.highlight : linenums_style : pymdownx-inline And then increase the font size to get make them easy to read: . md-typeset code , . md-typeset kbd { font-size : 1 em ; word-break : keep-all !important ; } . md-typeset pre code { white-space : pre-wrap ; font-size : 0.9 em ; } Then the line number should be dimmed to not distract the main code: . md-typeset . highlight [ data-linenos ] : before { background-color : transparent ; box-shadow : none ; color : lightgray ; } #include <stdio.h> int main ( void ) { printf ( \"Hello world! \\n \" ); return 0 ; }","title":"8.4. Code block"},{"location":"blog/setup-blog/customize-theme/#85-tables","text":"Table should show cell border and use a full width to make the content clear. . md-typeset__scrollwrap { margin : unset ; } . md-typeset__table { padding : 0 ; display : block ; } . md-typeset table : not ([ class ]) { font-size : 0.9 em ; box-shadow : none ; display : table ; border-collapse : collapse ; } . md-typeset table : not ([ class ]) th , . md-typeset table : not ([ class ]) td { padding : 0.5 em ; border : 1 px solid #f0f0f0 ; min-width : unset ; } Syntax Description Test Text Left align Center align Right align A text Another text More texts","title":"8.5. Tables"},{"location":"blog/setup-blog/customize-theme/#86-tabs","text":"Tab\u2019s content should show some intent to visualize its structure. The label is tweaked a bit to look consisted with its content at the left margin. Note that in printing, all tabs will be expanded to show all of its content. . md-typeset . tabbed-content { box-shadow : none ; border-top : 1 px solid var ( --md-default-fg-color--lightest ); } . md-typeset . tabbed-content > . tabbed-set { padding-left : 2 em ; } . md-typeset . tabbed-set > label { font-size : 0.9 em ; padding : 0 margin-right : 1.25 em ; } Tab 1 Some texts Tab A Text A Tab B Text B Tab 2 Some other texts","title":"8.6. Tabs"},{"location":"blog/setup-blog/customize-theme/#87-buttons","text":"When using white primary color, the default button class md-button has issues to display correctly. Here are the fix for those buttons: change the margin to make them smaller change the border, and text color change the size of the icon . md-typeset . md-button { font-size : small ; font-weight : unset ; padding : 0.25 em 0.5 em ; border : 1 px solid ; color : orangered ; } . md-typeset . md-button . twemoji { font-size : large ; } Click here","title":"8.7. Buttons"},{"location":"blog/setup-blog/customize-theme/#88-image-caption","text":"The caption should not have restricted width, and its bottom margin should be smaller. . md-typeset figcaption { max-width : unset ; margin : 1 em auto ; } A photo from https://picsum.photos","title":"8.8. Image caption"},{"location":"blog/setup-blog/customize-theme/#89-sidebar-scrolls","text":"Only show the scrollbar when hovering to make sidebar look clear. . md-sidebar__scrollwrap { overflow : hidden ; } . md-sidebar__scrollwrap : hover { overflow-y : auto ; }","title":"8.9. Sidebar scrolls"},{"location":"blog/setup-blog/customize-theme/#810-spaces","text":"This part modifies some small space gap and margins to make the overall layout look better. Remove some space gaps. . md-main__inner { margin-top : 0 ; } md-typeset dd { margin : 0 em 0 1 em 1.875 em ; } . md-typeset dd > * { margin-top : 0 ; } . md-typeset p : empty { display : none ; } . md-typeset . admonition + *, . md-typeset details + * { margin-top : 0 ; } /* .md-typeset blockquote, */ . md-typeset dl , . md-typeset figure , . md-typeset ol , . md-typeset pre , . md-typeset ul { margin-top : 0 ; margin-bottom : 0 ; }","title":"8.10. Spaces"},{"location":"blog/setup-blog/customize-theme/#811-tags","text":"Add styles to have a space between tags. . tag { white-space : nowrap ; margin-right : 0.25 em ; } Then the tag cloud should have some indent: . tag-cloud-content { padding : 0 0.6 rem ; margin-bottom : 1 em ; }","title":"8.11. Tags"},{"location":"blog/setup-blog/customize-theme/#812-new-elements","text":"","title":"8.12. New elements"},{"location":"blog/setup-blog/customize-theme/#8121-new-span","text":"Class .ns is used in a new span to clear font-style of the target element, when using attribute list on it. . md-typeset . ns { font-style : unset ; } An example of adding .ns class to an emphasized word: _without new span: italic style_ \\ _with new span: normal style thanks to `.ns` class_ {.ns} without new span: italic style with new span: normal style thanks to .ns class","title":"8.12.1. New span"},{"location":"blog/setup-blog/customize-theme/#8122-row-and-column","text":"With Custom Blocks extension, I can make column layout with class .row and .col . Here are the style to make column layout in a row, and set column\u2019s margins: . md-typeset . row { display : flex ; flex-direction : row ; } . md-typeset . row . col { display : flex ; flex-direction : column ; width : 100 % ; margin : 0 0.25 em ; } . md-typeset . row . col : first-of-type { margin-left : 0 ; } . md-typeset . row . col : last-of-type { margin-right : 0 ; } A column will try to fit 100% of the page width. To set a percentage, use the class .wXX for the width of XX% . These classes can be applied to other elements too. And here is an example to create 2 columns, a big one is 80% page width: ::: row ::: col w80 style=\"background-color: lightyellow;\" A big column using 80% of page width ::: col w20 style=\"background-color: lightblue;\" A small column A big column using 80% of page width A small column","title":"8.12.2. Row and Column"},{"location":"blog/setup-blog/fix-ajax-issue/","text":"1. Instant loading \u2693\ufe0e As mentioned in the Material for MkDocs guide, this theme supports Instant Loading feature which intercepts internal links and load content via XHR request without fully reloading the page. The resulting page is parsed and injected and all event handlers and components are rebound automatically. This means that the site behaves like a Single Page Application, which is especially useful for large documentation sites that come with a massive search index, as the search index will now remain intact in-between document switches. However, using XHR in an AJAX site leads to a problem. Dynamic JavaScript-enabled elements do not work after AJAX content is loaded. After an AJAX request is done, the old content is replaced with the new content, causing dynamic content and handlers are destroyed, such as items were selected by javascript query, Mermaid code blocks, disqus comments, registered event for clicking, etc. Here are problems I get after click in an internal link: Zoom-in Images function does not work External links is not opened in a new tab Disqus section does not load new thread comments The solution is to detect internal navigation, and then re-register all dynamic elements. 2. Detect internal navigation \u2693\ufe0e When the site fetches new page content, it will change the URL location too, therefore there are some methods to detect an internal navigation: Detect URL change: A while loop to check if URL is changed every 1s, or A handler that listens to browser history change Detect content change: Observe an element and detect its content is changed 2.1. Detect URL change \u2693\ufe0e Here is a fix using URL detection approach, but the handler will be called multiple time causing bad performance, e.g. when a page has a lot of images. This method redefines the handler which calls the old handler ( f in lambda) and fires new events using window.dispatchEvent function: assets\\extra.js function reactivateElements () { /* do something here */ } history . pushState = (( f ) => function pushState () { var ret = f . apply ( this , arguments ); window . dispatchEvent ( new Event ( \"pushstate\" )); window . dispatchEvent ( new Event ( \"locationchange\" )); return ret ; })( history . pushState ); history . replaceState = (( f ) => function replaceState () { var ret = f . apply ( this , arguments ); window . dispatchEvent ( new Event ( \"replacestate\" )); window . dispatchEvent ( new Event ( \"locationchange\" )); return ret ; })( history . replaceState ); window . addEventListener ( \"popstate\" , () => { window . dispatchEvent ( new Event ( \"locationchange\" )); }); window . addEventListener ( \"locationchange\" , () => { // can check actual change of URL but the content may not loaded console . log ( \"locationchange\" ); reactivateElements (); }); 2.2. Detect content change \u2693\ufe0e Another method uses an observer to watch the <HEAD> tag, because whenever a new page is loaded, the title and page\u2019s information will be changed inside the <HEAD> tag. Just need to monitor the children state of this tag. assets\\extra.js var currentLocation = document . location . href ; function reactivateElements () { /* do something here */ } const observer = new MutationObserver (() => { if ( currentLocation !== document . location . href ) { console . log ( \"URL changed!\" ); currentLocation = document . location . href ; reactivateElements (); } }); observer . observe ( document . getElementsByTagName ( \"HEAD\" )[ 0 ], { childList : true }); I chose this method. 3. Activate dynamic elements \u2693\ufe0e This step is to wrap all actions that need to be run: when the page is fully loaded at the first time; and when the content of the page is loaded after an XHR request 3.1. Re-direct external links \u2693\ufe0e External link should be shown in a new tab, without any tracking information. To do that, I write a function to get all external links in the page, then set target = \"_blank\" and add attribute rel = \"noopener noreferrer\" . assets\\extra.js function activateExternalLinks () { /* open external links in new tab */ var links = document . links ; for ( var i = 0 , linksLength = links . length ; i < linksLength ; i ++ ) { if ( links [ i ]. hostname != window . location . hostname ) { links [ i ]. target = \"_blank\" ; links [ i ]. setAttribute ( \"rel\" , \"noopener noreferrer\" ); links [ i ]. className += \" externalLink\" ; } else { links [ i ]. className += \" localLink\" ; } } } Finally, add this function to the re-activation chain: assets\\extra.js function reactivateElements () { activateExternalLinks (); } 3.2. Re-register images \u2693\ufe0e Firstly, wrap the handler in a function which will be re-called. Note that, ViewBigimg object will be created once as a constant object. assets\\extra.js var viewer = new ViewBigimg (); function activateBigImg () { /* enable zoom-in */ var figures = document . querySelectorAll ( \"img\" ); for ( var i = 0 ; i < figures . length ; i ++ ) { figures [ i ]. onclick = ( e ) => { if ( e . target . nodeName === \"IMG\" ) { viewer . show ( e . target . src ); } }; } /* click to close zoomed image */ var containers = document . querySelectorAll ( \"#iv-container .iv-image-view\" ); for ( var i = 0 ; i < containers . length ; i ++ ) { containers [ i ]. onclick = () => { if ( ! dragged ) { viewer . hide (); } }; } } Then add this function to the re-activation chain: assets\\extra.js function reactivateElements () { activateExternalLinks (); activateBigImg (); } 3.3. Re-register pagination links \u2693\ufe0e Do the same step as described above to make a wrapped function to add into the re-activation chain: assets\\extra.js function activatePaginationLinks () { var pagination = document . getElementById ( \"pagination\" ); var links = pagination . getElementsByClassName ( \"page-number\" ); if ( links . length ) { for ( var i = 0 ; i < links . length ; i ++ ) { links [ i ]. addEventListener ( \"click\" , function () { var current = pagination . getElementsByClassName ( \"active\" ); console . log ( current ); if ( current . length ) { current [ 0 ]. className = current [ 0 ]. className . replace ( \" active\" , \"\" ); } this . className += \" active\" ; }); } links [ 0 ]. click (); } } function reactivateElements () { activateExternalLinks (); activateBigImg (); activatePaginationLinks (); } 3.4. Re-enable Disqus \u2693\ufe0e Disqus can not see the URL changed by itself, and it provides an API to reset the Disqus section. There is a guide on Using Disqus on AJAX sites showing a snippet to reload Disqus thread: DISQUS . reset ({ reload : true , config : function () { this . page . identifier = \"newidentifier\" ; this . page . url = \"http://example.com/#!newthread\" ; }, }); Checking the template of Material in partials\\integrations\\disqus.html , it gets page ID and page URL using Jinja template: <h2 id=\"__comments\"> {{ lang.t ( \"meta.comments\" ) }} </h2> <div id=\"disqus_thread\"></div> <script> var disqus_config = function() { this.page.url = \" {{ page.canonical_url }} \", this.page.identifier = \" {{ page.canonical_url | replace ( config.site_url , '' ) }} \" }; window.addEventListener(\"load\",function() { var e = document, i = e.createElement(\"script\"); i.src = \"// {{ disqus }} .disqus.com/embed.js\", i.setAttribute(\"data-timestamp\", +new Date), (e.head||e.body).appendChild(i) }); </script> Therefore, I can get this information in the same way by adding two <div> with data being the page ID and page URL in the main.html template: main.html {{ page.content }} <div id=\"page_url\" data-value=\" {{ page.canonical_url }} \"> </div> <div id=\"page_identifier\" data-value=\" {{ page.canonical_url | replace ( config.site_url , '' ) }} \"> </div> Then, I created a function to reset Disqus which extracts page ID and page URL from above elements, and call to DISQUS.reset() : assets\\extra.js function resetDisqusPlugin () { var page_url = document . getElementById ( \"page_url\" ); var page_identifier = document . getElementById ( \"page_identifier\" ); if ( page_url && page_identifier ) { page_url = page_url . dataset . value + \"#!newthread\" ; console . log ( page_url ); page_identifier = page_identifier . dataset . value ; console . log ( page_identifier ); try { DISQUS_RECOMMENDATIONS . reset (); DISQUS . reset ({ reload : true , config : function () { this . page . identifier = page_identifier ; this . page . url = page_url ; }, }); } catch ( e ) { console . log ( e ); } } } However, there is still a problem: Disqus is not initialized in some pages The Disqus section is controlled by: setting in mkdocs.yml file the page.is_homepage variable the field disqus in page\u2019s meta-data If an user visits the first page with no disqus activated, the next page even with disqus included still fails to load disqus as the script //{{ disqus }}.disqus.com/embed.js is not loaded. The solution is enabled Disqus on all pages, then hide the section on some specific pages. How to do it? Here are steps: Remove default Disqus block by extending it with empty content: {% block disqus %} {% endblock %} Wrap the page content inside a new block page_content : {% block page_content %} ... {{ page.content }} {% endblock %} Append the customized Disqus block after the page_content : {% block content %} {% block page_content %} ... {{ page.content }} {% endblock %} <div id=\"page_url\" data-value=\" {{ page.canonical_url }} \"> </div> <div id=\"page_identifier\" data-value=\" {{ page.canonical_url | replace ( config.site_url , '' ) }} \"> </div> {% set disqus = config.extra.disqus %} {% if disqus %} {% if page and page.meta and page.meta.hide %} {% set hidden = \"hidden\" if \"disqus\" in page.meta.hide %} {% endif %} <div {{ hidden }} > {% set disqus = config.extra.disqus %} <h2 id=\"__comments\"> {{ lang.t ( \"meta.comments\" ) }} </h2> <div id=\"disqus_thread\"></div> <script>var disqus_config = function () { this.page.url = \" {{ page.canonical_url }} \", this.page.identifier = \" {{ page.canonical_url | replace ( config.site_url , '' ) }} \" }; window.addEventListener(\"load\", function () { var e = document, i = e.createElement(\"script\"); i.src = \"// {{ disqus }} .disqus.com/embed.js\", i.setAttribute(\"data-timestamp\", +new Date), (e.head || e.body).appendChild(i) })</script> </div> {% endif %} {% endblock %} {% block disqus %} {% endblock %} All other templates which extend the main.html template have to extend the page_content block, not the content block. Finally, in the page where I don\u2019t want to see Disqus section, just add disqus to the hide attribute in the meta-data section: --- title: Recent updated posts description: Latest news and recent posts template: blog.html hide: - disqus ---","title":"Fix AJAX issue"},{"location":"blog/setup-blog/fix-ajax-issue/#1-instant-loading","text":"As mentioned in the Material for MkDocs guide, this theme supports Instant Loading feature which intercepts internal links and load content via XHR request without fully reloading the page. The resulting page is parsed and injected and all event handlers and components are rebound automatically. This means that the site behaves like a Single Page Application, which is especially useful for large documentation sites that come with a massive search index, as the search index will now remain intact in-between document switches. However, using XHR in an AJAX site leads to a problem. Dynamic JavaScript-enabled elements do not work after AJAX content is loaded. After an AJAX request is done, the old content is replaced with the new content, causing dynamic content and handlers are destroyed, such as items were selected by javascript query, Mermaid code blocks, disqus comments, registered event for clicking, etc. Here are problems I get after click in an internal link: Zoom-in Images function does not work External links is not opened in a new tab Disqus section does not load new thread comments The solution is to detect internal navigation, and then re-register all dynamic elements.","title":"1. Instant loading"},{"location":"blog/setup-blog/fix-ajax-issue/#2-detect-internal-navigation","text":"When the site fetches new page content, it will change the URL location too, therefore there are some methods to detect an internal navigation: Detect URL change: A while loop to check if URL is changed every 1s, or A handler that listens to browser history change Detect content change: Observe an element and detect its content is changed","title":"2. Detect internal navigation"},{"location":"blog/setup-blog/fix-ajax-issue/#21-detect-url-change","text":"Here is a fix using URL detection approach, but the handler will be called multiple time causing bad performance, e.g. when a page has a lot of images. This method redefines the handler which calls the old handler ( f in lambda) and fires new events using window.dispatchEvent function: assets\\extra.js function reactivateElements () { /* do something here */ } history . pushState = (( f ) => function pushState () { var ret = f . apply ( this , arguments ); window . dispatchEvent ( new Event ( \"pushstate\" )); window . dispatchEvent ( new Event ( \"locationchange\" )); return ret ; })( history . pushState ); history . replaceState = (( f ) => function replaceState () { var ret = f . apply ( this , arguments ); window . dispatchEvent ( new Event ( \"replacestate\" )); window . dispatchEvent ( new Event ( \"locationchange\" )); return ret ; })( history . replaceState ); window . addEventListener ( \"popstate\" , () => { window . dispatchEvent ( new Event ( \"locationchange\" )); }); window . addEventListener ( \"locationchange\" , () => { // can check actual change of URL but the content may not loaded console . log ( \"locationchange\" ); reactivateElements (); });","title":"2.1. Detect URL change"},{"location":"blog/setup-blog/fix-ajax-issue/#22-detect-content-change","text":"Another method uses an observer to watch the <HEAD> tag, because whenever a new page is loaded, the title and page\u2019s information will be changed inside the <HEAD> tag. Just need to monitor the children state of this tag. assets\\extra.js var currentLocation = document . location . href ; function reactivateElements () { /* do something here */ } const observer = new MutationObserver (() => { if ( currentLocation !== document . location . href ) { console . log ( \"URL changed!\" ); currentLocation = document . location . href ; reactivateElements (); } }); observer . observe ( document . getElementsByTagName ( \"HEAD\" )[ 0 ], { childList : true }); I chose this method.","title":"2.2. Detect content change"},{"location":"blog/setup-blog/fix-ajax-issue/#3-activate-dynamic-elements","text":"This step is to wrap all actions that need to be run: when the page is fully loaded at the first time; and when the content of the page is loaded after an XHR request","title":"3. Activate dynamic elements"},{"location":"blog/setup-blog/fix-ajax-issue/#31-re-direct-external-links","text":"External link should be shown in a new tab, without any tracking information. To do that, I write a function to get all external links in the page, then set target = \"_blank\" and add attribute rel = \"noopener noreferrer\" . assets\\extra.js function activateExternalLinks () { /* open external links in new tab */ var links = document . links ; for ( var i = 0 , linksLength = links . length ; i < linksLength ; i ++ ) { if ( links [ i ]. hostname != window . location . hostname ) { links [ i ]. target = \"_blank\" ; links [ i ]. setAttribute ( \"rel\" , \"noopener noreferrer\" ); links [ i ]. className += \" externalLink\" ; } else { links [ i ]. className += \" localLink\" ; } } } Finally, add this function to the re-activation chain: assets\\extra.js function reactivateElements () { activateExternalLinks (); }","title":"3.1. Re-direct external links"},{"location":"blog/setup-blog/fix-ajax-issue/#32-re-register-images","text":"Firstly, wrap the handler in a function which will be re-called. Note that, ViewBigimg object will be created once as a constant object. assets\\extra.js var viewer = new ViewBigimg (); function activateBigImg () { /* enable zoom-in */ var figures = document . querySelectorAll ( \"img\" ); for ( var i = 0 ; i < figures . length ; i ++ ) { figures [ i ]. onclick = ( e ) => { if ( e . target . nodeName === \"IMG\" ) { viewer . show ( e . target . src ); } }; } /* click to close zoomed image */ var containers = document . querySelectorAll ( \"#iv-container .iv-image-view\" ); for ( var i = 0 ; i < containers . length ; i ++ ) { containers [ i ]. onclick = () => { if ( ! dragged ) { viewer . hide (); } }; } } Then add this function to the re-activation chain: assets\\extra.js function reactivateElements () { activateExternalLinks (); activateBigImg (); }","title":"3.2. Re-register images"},{"location":"blog/setup-blog/fix-ajax-issue/#33-re-register-pagination-links","text":"Do the same step as described above to make a wrapped function to add into the re-activation chain: assets\\extra.js function activatePaginationLinks () { var pagination = document . getElementById ( \"pagination\" ); var links = pagination . getElementsByClassName ( \"page-number\" ); if ( links . length ) { for ( var i = 0 ; i < links . length ; i ++ ) { links [ i ]. addEventListener ( \"click\" , function () { var current = pagination . getElementsByClassName ( \"active\" ); console . log ( current ); if ( current . length ) { current [ 0 ]. className = current [ 0 ]. className . replace ( \" active\" , \"\" ); } this . className += \" active\" ; }); } links [ 0 ]. click (); } } function reactivateElements () { activateExternalLinks (); activateBigImg (); activatePaginationLinks (); }","title":"3.3. Re-register pagination links"},{"location":"blog/setup-blog/fix-ajax-issue/#34-re-enable-disqus","text":"Disqus can not see the URL changed by itself, and it provides an API to reset the Disqus section. There is a guide on Using Disqus on AJAX sites showing a snippet to reload Disqus thread: DISQUS . reset ({ reload : true , config : function () { this . page . identifier = \"newidentifier\" ; this . page . url = \"http://example.com/#!newthread\" ; }, }); Checking the template of Material in partials\\integrations\\disqus.html , it gets page ID and page URL using Jinja template: <h2 id=\"__comments\"> {{ lang.t ( \"meta.comments\" ) }} </h2> <div id=\"disqus_thread\"></div> <script> var disqus_config = function() { this.page.url = \" {{ page.canonical_url }} \", this.page.identifier = \" {{ page.canonical_url | replace ( config.site_url , '' ) }} \" }; window.addEventListener(\"load\",function() { var e = document, i = e.createElement(\"script\"); i.src = \"// {{ disqus }} .disqus.com/embed.js\", i.setAttribute(\"data-timestamp\", +new Date), (e.head||e.body).appendChild(i) }); </script> Therefore, I can get this information in the same way by adding two <div> with data being the page ID and page URL in the main.html template: main.html {{ page.content }} <div id=\"page_url\" data-value=\" {{ page.canonical_url }} \"> </div> <div id=\"page_identifier\" data-value=\" {{ page.canonical_url | replace ( config.site_url , '' ) }} \"> </div> Then, I created a function to reset Disqus which extracts page ID and page URL from above elements, and call to DISQUS.reset() : assets\\extra.js function resetDisqusPlugin () { var page_url = document . getElementById ( \"page_url\" ); var page_identifier = document . getElementById ( \"page_identifier\" ); if ( page_url && page_identifier ) { page_url = page_url . dataset . value + \"#!newthread\" ; console . log ( page_url ); page_identifier = page_identifier . dataset . value ; console . log ( page_identifier ); try { DISQUS_RECOMMENDATIONS . reset (); DISQUS . reset ({ reload : true , config : function () { this . page . identifier = page_identifier ; this . page . url = page_url ; }, }); } catch ( e ) { console . log ( e ); } } } However, there is still a problem: Disqus is not initialized in some pages The Disqus section is controlled by: setting in mkdocs.yml file the page.is_homepage variable the field disqus in page\u2019s meta-data If an user visits the first page with no disqus activated, the next page even with disqus included still fails to load disqus as the script //{{ disqus }}.disqus.com/embed.js is not loaded. The solution is enabled Disqus on all pages, then hide the section on some specific pages. How to do it? Here are steps: Remove default Disqus block by extending it with empty content: {% block disqus %} {% endblock %} Wrap the page content inside a new block page_content : {% block page_content %} ... {{ page.content }} {% endblock %} Append the customized Disqus block after the page_content : {% block content %} {% block page_content %} ... {{ page.content }} {% endblock %} <div id=\"page_url\" data-value=\" {{ page.canonical_url }} \"> </div> <div id=\"page_identifier\" data-value=\" {{ page.canonical_url | replace ( config.site_url , '' ) }} \"> </div> {% set disqus = config.extra.disqus %} {% if disqus %} {% if page and page.meta and page.meta.hide %} {% set hidden = \"hidden\" if \"disqus\" in page.meta.hide %} {% endif %} <div {{ hidden }} > {% set disqus = config.extra.disqus %} <h2 id=\"__comments\"> {{ lang.t ( \"meta.comments\" ) }} </h2> <div id=\"disqus_thread\"></div> <script>var disqus_config = function () { this.page.url = \" {{ page.canonical_url }} \", this.page.identifier = \" {{ page.canonical_url | replace ( config.site_url , '' ) }} \" }; window.addEventListener(\"load\", function () { var e = document, i = e.createElement(\"script\"); i.src = \"// {{ disqus }} .disqus.com/embed.js\", i.setAttribute(\"data-timestamp\", +new Date), (e.head || e.body).appendChild(i) })</script> </div> {% endif %} {% endblock %} {% block disqus %} {% endblock %} All other templates which extend the main.html template have to extend the page_content block, not the content block. Finally, in the page where I don\u2019t want to see Disqus section, just add disqus to the hide attribute in the meta-data section: --- title: Recent updated posts description: Latest news and recent posts template: blog.html hide: - disqus ---","title":"3.4. Re-enable Disqus"},{"location":"blog/setup-blog/markdown-syntax/","text":"For basic markdown syntax, refer to Markdown Guide . 1. Meta-data \u2693\ufe0e The Meta-Data extension adds a syntax for defining meta-data of a document. It is inspired by and follows the syntax of MultiMarkdown . Meta-data is the additional information that can be used to briefly describe the content of a post, such as the title, the short description, tags, and sometimes the banner image. Enable the extension: markdown_extensions : - meta Meta-data consists of a series of keywords and values defined at the beginning of a Markdown document like this: title : The page title description : The summary of the page content Alternatively, meta-data can be written in YAML style, using two triple-dash --- tags to mark the start and the end of the meta-data section: --- title : The page title description : The summary of the page content --- The metadata can be used in the template and the page content 1 . In Jinja syntax, each page is represented as a page object, then the meta-data field {{ page.meta.title }} will be replaced by the string The page title . MkDocs uses the title of each post to show in the navigation sidebar. In case the title is long, it can make the side look a bit messy. A solution is to use a short title on navigation, and a long title on the post. Read more in Customize theme . 2. Code blocks \u2693\ufe0e The SuperFences extension provides a number of features including allowing the nesting of fences, and ability to specify custom fences to provide features like flowcharts, sequence diagrams, or other custom blocks. Highlighting can be further controlled via the Highlight extension . Enable the extension: markdown_extensions : - pymdownx.superfences - pymdownx.highlight The standard format which supports to add id , class or custom key=value is as below: ```{ .language #id .class key=\"value\" linenums=\"n\" hl_lines=\"x y-z\"} codeblock content ``` or in a simple syntax: ```language linenums=\"n\" hl_lines=\"x y-z\" codeblock content ``` Option linenums = \"n\" creates line numbers starting from n . Option hl_lines = \"x y-z\" highlights the x-th line and lines in the range from y-th to z-th . Line numbers are always referenced starting at 1 ignoring what the line number is started labeling at the number set by the option linenums = \"n\" . Example: ```cpp linenums=\"2\" hl_lines=\"1 4-5\" #include <stdio.h> int main(void) { printf(\"Hello world!\\n\"); return 0; } ``` #include <stdio.h> int main ( void ) { printf ( \"Hello world! \\n \" ); return 0 ; } Some styles will be added to the code blocks to make it look a bit bigger and wrap long lines. Read more in Customize theme . 3. Inline code \u2693\ufe0e The InlineHilite extension is an inline code highlighter inspired by CodeHilite . Enable the extension: markdown_extensions : - pymdownx.inlinehilite Borrowing from CodeHilite\u2019s existing syntax, InlineHilite utilizes the following syntax to insert inline highlighted code: `:::language my code` or `#!language my code` . This will render this line `#!python [x for x in range(1, 10) if x % 2]` to a fully colored inline Python code: [ x for x in range ( 1 , 10 ) if x % 2 ] . 4. Admonition \u2693\ufe0e The Admonition extension adds rST-style admonitions to Markdown documents. This block displays its content in a block, with or without a title. Enable the extension: markdown_extensions : - admonition Admonitions are created using the following syntax. The title is optional, use an empty string to remove the title: .md-typeset .admonition.type, .md-typeset details.type { background-color: rgba(68, 138, 255, 0.05); } !!! type \"Title\" Content of the admonition is indented !!! type \"\" There is no title Title Content of the admonition is indented There is no title Other types note, seealso Content of the admonition is indented abstract, summary, tldr Content of the admonition is indented info, todo Content of the admonition is indented tip, hint, important Content of the admonition is indented success, check, done Content of the admonition is indented question, help, faq Content of the admonition is indented warning, caution, attention Content of the admonition is indented failure, fail, missing Content of the admonition is indented danger, error Content of the admonition is indented bug Content of the admonition is indented example Content of the admonition is indented quote, cite Content of the admonition is indented With some additional styles, it is possible to create an admonition without title but still has icon, by using .no-title class and an empty title (use \"&nbsp;\" , or \"\\ \" if Escape All extension is used). Read more in Customize theme . !!! info no-title \"&nbsp;\" This admonition has icon as an inline element with the content This admonition has icon as an inline element with the content 5. Attribute list \u2693\ufe0e The Attribute Lists extension adds a syntax to add attributes on the various HTML elements in Markdown\u2019s output. Enable the extension: markdown_extensions : - attr_list An example of using attribute list might look like this: { #id .class key='value' } 5.1. Block attribute \u2693\ufe0e To define attributes for a block level element, the attribute list should be defined on the last line of the block by itself. This is a paragraph colored in **teal** by using a block attribute. {style=\"color: teal;\"} This is a paragraph colored in teal by using a block attribute. 5.2. Element attribute \u2693\ufe0e To define attributes on inline elements, the attribute list should be defined immediately after an inline element generated by Markdown with no white space. This is a _green_ {style=\"color:green\"} word.\\ This is a <span>non-markdown span</span>{style=\"color:green\"} word therefore the attribute is not parsed. This is a green word. This is a non-markdown span {style=\u201dcolor:green\u201d} word therefore the attribute is not parsed. 6. Lists \u2693\ufe0e Markdown supports Ordered and Unordered lists. Extensions provide 2 more kinds of list as Tasks and Definitions . The Sane Lists extension alters the behavior of the Markdown List syntax to be less surprising. Sane Lists do not allow the mixing of list types. In other words, an ordered list will not continue when an unordered list item is encountered and vice versa. Enable the extension: markdown_extensions : - pymdownx.tasklist : custom_checkbox : true - def_list - sane_lists Some styles need to be added to show lists in a better view. Read more in Customize theme . 6.1. Ordered list \u2693\ufe0e 1. Ordered item 1 1. Child 1 2. Child 2 2. Ordered item 2 Ordered item 1 Child 1 Child 2 Ordered item 2 6.2. Unordered list \u2693\ufe0e - Unordered item 1 - Child 1 - Child 2 - Unordered item 2 Unordered item 1 Child 1 Child 2 Unordered item 2 6.3. Task list \u2693\ufe0e - [x] item 1 - [x] item a - [ ] item b - [ ] item 2 item 1 item a item b item 2 6.4. Definition \u2693\ufe0e Roses : are red Violets : are blue Roses are red Violets are blue 6.5. Sane list \u2693\ufe0e 1. Ordered item 1 2. Ordered item 2 - Unordered item 1 - Unordered item 2 Ordered item 1 Ordered item 2 Unordered item 1 Unordered item 2 7. Images \u2693\ufe0e There are some extensions to add a caption to an image. After testing, markdown-captions is a good one that uses the alternate text to make caption, accepts markdown in the alternate text. Install the extension: pip install -U markdown-captions then enable it in the config file: markdown_extensions : - markdown_captions Some images have big size that does not show the detail, therefore, it\u2019s better to zoom in by clicking on them, and pan the image on the screen. The view-bigimg library can do that requirement well. Read more in Customize theme to learn how to enable that library. ![ A photo from <https://picsum.photos> ]( https://picsum.photos/320/240 ) A photo from https://picsum.photos 8. Tabs \u2693\ufe0e Tabbed extension provides a syntax to easily add tabbed Markdown content. Enable the extension: markdown_extensions : - pymdownx.tabbed Tabs start with === to signify a tab followed by a quoted title. Consecutive tabs are grouped into a tab set. === \"Tab 1\" Some texts === \"Tab A\" Text A === \"Tab B\" Text B === \"Tab 2\" Some other texts Tab 1 Some texts Tab A Text A Tab B Text B Tab 2 Some other texts Styles for tabs need to change a little to have left margin in tab\u2019s content. Read more in Customize theme . 9. Tables \u2693\ufe0e The Tables extension adds the ability to create tables in Markdown documents. Enable the extension: markdown_extensions : - tables Markdown Tables are written in pipe-line format: row is on one line, cell is inline text only. The 1 st line contains the column headers. The 2 nd line is to control text alignment in a column: :--- , :---: and ---: are left, center, and right alignment. Styles for table need to change a little to show cell border. Read more in Customize theme . | Syntax | Description | Test Text | | :--------- | :----------: | ----------: | | Left align | Center align | Right align | | A text | Another text | More texts | Syntax Description Test Text Left align Center align Right align A text Another text More texts 10. Formatting \u2693\ufe0e Some texts may have special formats, and here are extensions that can help to add some styles. 10.1. Caret \u2693\ufe0e Caret optionally adds two different features which are syntactically built around the ^ character. Enable the extension: markdown_extensions : - pymdownx.caret The double carets ^^ inserts <ins></ins> tags, and the single caret ^ inserts <sup></sup> tags. ^^Insert^^ the energy E=mc^2^ Insert the energy E=mc 2 10.2. Mark \u2693\ufe0e Mark adds the ability to insert <mark></mark> tags. Enable the extension: markdown_extensions : - pymdownx.mark The syntax requires the text to be surrounded by double equal signs == . ==mark me== and ==mark==me==all== mark me and mark==me==all 10.3. Tildes \u2693\ufe0e Tildes optionally adds two different features which are syntactically built around the ~ character: delete using double tildes ~~ which inserts <del></del> tags and subscript using single tilde ~ which inserts <sub></sub> tags. Enable the extension: markdown_extensions : - pymdownx.tilde For example: ~~Delete~~ the existence of CH~3~CH~2~OH Delete the existence of CH 3 CH 2 OH 10.4. Critic \u2693\ufe0e Critic is an extension that adds handling and support of Critic Markup which uses a special syntax to represent edits to a Markdown document. This extension runs before all other extensions to parse the critic edits. Enable the extension: markdown_extensions : - pymdownx.critic Critic Markup uses special markup to insert, delete, substitute, highlight, and comment. To insert or remove text, use {\u200b++insert me++} and {\u200b--remove me--}.\\ Denote a substitution with {\u200b~~substitute this~>with this~~}. Highlight specific text with {\u200b==highlight me==}.\\ Or even add {\u200b>>a comment<<}. To insert or remove text, use insert me and remove me . Denote a substitution with substitute this with this . Highlight specific text with highlight me . Or even add a comment . 11. HTML block \u2693\ufe0e The Markdown in HTML extension that parses Markdown inside of HTML block tags. Enable the extension: markdown_extensions : - md_in_html By default, Markdown ignores any content within a raw HTML block-level element. With this extension enabled, the content of a raw HTML block-level element can be parsed as Markdown by including a markdown attribute on the opening tag. <div> This is __not parsed word__ by Markdown. </div> <div markdown=\"1\"> This is a __bold__ word parsed by Markdown. </div> This is __not parsed word__ by Markdown. This is a bold word parsed by Markdown. 12. Icons & Emojis \u2693\ufe0e The Emoji extension adds support for inserting emoji via simple short names enclosed within colons :short_name: . This is accomplished by using a short name index to map easy-to-remember names to the corresponding emoji characters. Enable the extension: markdown_extensions : - pymdownx.emoji : emoji_index : !!python/name:materialx.emoji.twemoji emoji_generator : !!python/name:materialx.emoji.to_svg 12.1. Emojis \u2693\ufe0e Emojis can be written by putting the short-code of the emoji between two colons. Look up the short-codes at Emojipedia . :smile: :heart: 12.2. Icons \u2693\ufe0e Icons can be used similarly to emojis, by referencing a valid path to any icon bundled with the theme, which are located in the .icons directory, and replacing / with - . For example: The short-code :material-account-circle: will be converted to an SVG image element with the path .icons/material/account-circle.svg which eventually shows the icon on the webpage. 12.3. Use in template \u2693\ufe0e Using include function of Jinja to add an icon wrapped in a twemoji class: <span class=\"twemoji\"> {% include \".icons/fontawesome/brands/twitter.svg\" %} </span> To show the Twitter icon . 13. Escape All \u2693\ufe0e The Escape All extension makes the backslash \\ character escape everything after it, except things in code blocks of any kind. Enable the extension: markdown_extensions : - pymdownx.escapeall : hardbreak : true nbsp : true There are two special escapes among all of these escapes though: escaping space characters and escaping newline characters: Enable nbsp to convert an escaped space into a non-breaking space: &nbsp; . Enable hardbreak to convert an escaped newline to a hard break <br> . The advantage of hard break is that the backslash is visually seen in the document, opposed to the Markdown\u2019s default method of two spaces at the end of a line. For example: This is a line with one space.\\ This is a new line with some \\ \\ \\ \\ \\ spaces. This is a line with one space. This is a new line with some spaces. 14. Sane Headers \u2693\ufe0e The Sane Headers is an extension that alters the default hashed headers extension to require headers to have spaces after the hashes # in order to be recognized as headers. This allows for other extension syntaxes to use # in their syntaxes as long as no spaces follow the # at the beginning of a line. Enable the extension: markdown_extensions : - pymdownx.saneheaders In default, both of these are treated as headers: ## Header ##Also a Header With Sane Headers, only the first is a header: ## Header ##Not a Header 15. Special characters \u2693\ufe0e The Smarty Pants extension converts ASCII dashes, quotes and ellipses to their HTML entity equivalents. The Smart Symbols adds syntax for creating special characters such as trademarks, arrows, fractions, etc. Enable the extension: markdown_extensions : - smarty : smart_angled_quotes : true - pymdownx.smartsymbols 15.1. Smarty Pants \u2693\ufe0e 'single quote' \"double quote\" <<angle quote>> ellipses ... N-dash -- M-dash --- \u2018single quote\u2019 \u201cdouble quote\u201d \u00abangle quote\u00bb ellipses \u2026 N-dash \u2013 M-dash \u2014 15.2. Smart Symbols \u2693\ufe0e trademark (tm) copyright (c) registered (r) in care of c/o plus or minus +/- arrows --> <-- <--> not equal =/= fractions 1/4 ordinal numbers 1st 2nd 3rd 4th 5th trademark \u2122 copyright \u00a9 registered \u00ae in care of \u2105 plus or minus \u00b1 arrows \u2192 \u2190 \u2194 not equal \u2260 fractions \u00bc \u00bd \u00be ordinal numbers 1 st 2 nd 3 rd 4 th 5 th 16. Snippets \u2693\ufe0e The Snippets insert the content of a file into the Markdown document. It is great for situations where there is a content that needs to be inserted into multiple documents. Snippets is run as a preprocessor, so if a snippet is found in a fenced code block etc., it will still get processed. Enable the extension: markdown_extensions : - pymdownx.snippets There are two modes of inserting snippets: single line and block. Single line mode accepts a single file name, and block accepts multiple files. Single line format is done by placing the following markup for the single line notation: -\u200b-8<-- \"filename.ext\" In block format, it is important to note that empty lines are preserved for formatting. -\u200b-8<-- filename.md the below empty line is preserved.log filename.log -\u200b-8<-- To temporarily ignore a file, comment it out by pre-pending the path with semicolon ; and a space. This works for both single line and block format: -\u200b-8<-- \"; skip.md\" -\u200b-8<-- include.md ; skip.md -\u200b-8<-- 17. Custom block \u2693\ufe0e The Custom Blocks extension defines a common markup to create parameter-supported and nested custom blocks. Install the extension: pip install -U markdown-customblocks Enable the extension: markdown_extensions : - customblocks This extension parses markup structures like this one: ::: type class param=value Indented content Example usage Add the filename of a code block, to show where it belongs. Syntax: ::: file main.c ```cpp int main ( void ) { return 0 ; } ``` with style: . md-typeset . file + p { font-size : 0.9 em ; color : gray ; margin-bottom : -1.2 em ; } will generate: main.c int main ( void ) { return 0 ; } There are some more custom block created with new layout and style, such as row and col . Read more in Customize theme . 18. Footnotes \u2693\ufe0e The Footnotes extension adds syntax for defining footnotes in Markdown documents. Enable the extension: markdown_extensions : - footnotes And use the following syntax: Footnotes[^1] have a label[^fn] and the footnote's content. [ ^1 ]: This is a footnote content. [ ^fn ]: A footnote on the label `fn`. Footnotes 2 have a label 3 and the footnote\u2019s content. 19. Tips \u2693\ufe0e There are some tips when writing document in Markdown which help to format the content in a good layout. 19.1. Small headers \u2693\ufe0e At small header levels <h5> and <h6> , the header text is smaller than the body text, and the header is transformed to all capitalized characters. Use a hard break and a bold text instead. This make text clear to be read, and have a good space to the previous paragraph. \\ **Item** 19.2. Ignore formatting \u2693\ufe0e When using Prettier extension to format the documents, some block can be ignored from formatting by adding directives. Refer to the Prettier \u2014 Ignore Code . Note the extension only format the markdown file, and when it is rendered to HTML, it will be displayed in HTML rendered visual. In Markdown, use block directive before a block that needs to be preserved: <!-- prettier-ignore --> Do not format this In case of a big block or multiple blocks, use the range directive: <!-- prettier-ignore-start --> | MY | AWESOME | AUTO-GENERATED | TABLE | |-|-|-|-| | a | b | c | d | <!-- prettier-ignore-end --> 19.3. Look up an icon or emoji \u2693\ufe0e Material for MkDocs provides a tool to look up an icon or an emoji by searching a name. It has fast copy to clipboard when selecting on the wanted icon. Please go there https://squidfunk.github.io/mkdocs-material/reference/icons-emojis/ . Use mkdocs-macros plugin to use Jinja template directly in the Markdown content. \u21a9 This is a footnote content. \u21a9 A footnote on the label fn . \u21a9","title":"Markdown syntax"},{"location":"blog/setup-blog/markdown-syntax/#1-meta-data","text":"The Meta-Data extension adds a syntax for defining meta-data of a document. It is inspired by and follows the syntax of MultiMarkdown . Meta-data is the additional information that can be used to briefly describe the content of a post, such as the title, the short description, tags, and sometimes the banner image. Enable the extension: markdown_extensions : - meta Meta-data consists of a series of keywords and values defined at the beginning of a Markdown document like this: title : The page title description : The summary of the page content Alternatively, meta-data can be written in YAML style, using two triple-dash --- tags to mark the start and the end of the meta-data section: --- title : The page title description : The summary of the page content --- The metadata can be used in the template and the page content 1 . In Jinja syntax, each page is represented as a page object, then the meta-data field {{ page.meta.title }} will be replaced by the string The page title . MkDocs uses the title of each post to show in the navigation sidebar. In case the title is long, it can make the side look a bit messy. A solution is to use a short title on navigation, and a long title on the post. Read more in Customize theme .","title":"1. Meta-data"},{"location":"blog/setup-blog/markdown-syntax/#2-code-blocks","text":"The SuperFences extension provides a number of features including allowing the nesting of fences, and ability to specify custom fences to provide features like flowcharts, sequence diagrams, or other custom blocks. Highlighting can be further controlled via the Highlight extension . Enable the extension: markdown_extensions : - pymdownx.superfences - pymdownx.highlight The standard format which supports to add id , class or custom key=value is as below: ```{ .language #id .class key=\"value\" linenums=\"n\" hl_lines=\"x y-z\"} codeblock content ``` or in a simple syntax: ```language linenums=\"n\" hl_lines=\"x y-z\" codeblock content ``` Option linenums = \"n\" creates line numbers starting from n . Option hl_lines = \"x y-z\" highlights the x-th line and lines in the range from y-th to z-th . Line numbers are always referenced starting at 1 ignoring what the line number is started labeling at the number set by the option linenums = \"n\" . Example: ```cpp linenums=\"2\" hl_lines=\"1 4-5\" #include <stdio.h> int main(void) { printf(\"Hello world!\\n\"); return 0; } ``` #include <stdio.h> int main ( void ) { printf ( \"Hello world! \\n \" ); return 0 ; } Some styles will be added to the code blocks to make it look a bit bigger and wrap long lines. Read more in Customize theme .","title":"2. Code blocks"},{"location":"blog/setup-blog/markdown-syntax/#3-inline-code","text":"The InlineHilite extension is an inline code highlighter inspired by CodeHilite . Enable the extension: markdown_extensions : - pymdownx.inlinehilite Borrowing from CodeHilite\u2019s existing syntax, InlineHilite utilizes the following syntax to insert inline highlighted code: `:::language my code` or `#!language my code` . This will render this line `#!python [x for x in range(1, 10) if x % 2]` to a fully colored inline Python code: [ x for x in range ( 1 , 10 ) if x % 2 ] .","title":"3. Inline code"},{"location":"blog/setup-blog/markdown-syntax/#4-admonition","text":"The Admonition extension adds rST-style admonitions to Markdown documents. This block displays its content in a block, with or without a title. Enable the extension: markdown_extensions : - admonition Admonitions are created using the following syntax. The title is optional, use an empty string to remove the title: .md-typeset .admonition.type, .md-typeset details.type { background-color: rgba(68, 138, 255, 0.05); } !!! type \"Title\" Content of the admonition is indented !!! type \"\" There is no title Title Content of the admonition is indented There is no title Other types note, seealso Content of the admonition is indented abstract, summary, tldr Content of the admonition is indented info, todo Content of the admonition is indented tip, hint, important Content of the admonition is indented success, check, done Content of the admonition is indented question, help, faq Content of the admonition is indented warning, caution, attention Content of the admonition is indented failure, fail, missing Content of the admonition is indented danger, error Content of the admonition is indented bug Content of the admonition is indented example Content of the admonition is indented quote, cite Content of the admonition is indented With some additional styles, it is possible to create an admonition without title but still has icon, by using .no-title class and an empty title (use \"&nbsp;\" , or \"\\ \" if Escape All extension is used). Read more in Customize theme . !!! info no-title \"&nbsp;\" This admonition has icon as an inline element with the content This admonition has icon as an inline element with the content","title":"4. Admonition"},{"location":"blog/setup-blog/markdown-syntax/#5-attribute-list","text":"The Attribute Lists extension adds a syntax to add attributes on the various HTML elements in Markdown\u2019s output. Enable the extension: markdown_extensions : - attr_list An example of using attribute list might look like this: { #id .class key='value' }","title":"5. Attribute list"},{"location":"blog/setup-blog/markdown-syntax/#51-block-attribute","text":"To define attributes for a block level element, the attribute list should be defined on the last line of the block by itself. This is a paragraph colored in **teal** by using a block attribute. {style=\"color: teal;\"} This is a paragraph colored in teal by using a block attribute.","title":"5.1. Block attribute"},{"location":"blog/setup-blog/markdown-syntax/#52-element-attribute","text":"To define attributes on inline elements, the attribute list should be defined immediately after an inline element generated by Markdown with no white space. This is a _green_ {style=\"color:green\"} word.\\ This is a <span>non-markdown span</span>{style=\"color:green\"} word therefore the attribute is not parsed. This is a green word. This is a non-markdown span {style=\u201dcolor:green\u201d} word therefore the attribute is not parsed.","title":"5.2. Element attribute"},{"location":"blog/setup-blog/markdown-syntax/#6-lists","text":"Markdown supports Ordered and Unordered lists. Extensions provide 2 more kinds of list as Tasks and Definitions . The Sane Lists extension alters the behavior of the Markdown List syntax to be less surprising. Sane Lists do not allow the mixing of list types. In other words, an ordered list will not continue when an unordered list item is encountered and vice versa. Enable the extension: markdown_extensions : - pymdownx.tasklist : custom_checkbox : true - def_list - sane_lists Some styles need to be added to show lists in a better view. Read more in Customize theme .","title":"6. Lists"},{"location":"blog/setup-blog/markdown-syntax/#61-ordered-list","text":"1. Ordered item 1 1. Child 1 2. Child 2 2. Ordered item 2 Ordered item 1 Child 1 Child 2 Ordered item 2","title":"6.1. Ordered list"},{"location":"blog/setup-blog/markdown-syntax/#62-unordered-list","text":"- Unordered item 1 - Child 1 - Child 2 - Unordered item 2 Unordered item 1 Child 1 Child 2 Unordered item 2","title":"6.2. Unordered list"},{"location":"blog/setup-blog/markdown-syntax/#63-task-list","text":"- [x] item 1 - [x] item a - [ ] item b - [ ] item 2 item 1 item a item b item 2","title":"6.3. Task list"},{"location":"blog/setup-blog/markdown-syntax/#64-definition","text":"Roses : are red Violets : are blue Roses are red Violets are blue","title":"6.4. Definition"},{"location":"blog/setup-blog/markdown-syntax/#65-sane-list","text":"1. Ordered item 1 2. Ordered item 2 - Unordered item 1 - Unordered item 2 Ordered item 1 Ordered item 2 Unordered item 1 Unordered item 2","title":"6.5. Sane list"},{"location":"blog/setup-blog/markdown-syntax/#7-images","text":"There are some extensions to add a caption to an image. After testing, markdown-captions is a good one that uses the alternate text to make caption, accepts markdown in the alternate text. Install the extension: pip install -U markdown-captions then enable it in the config file: markdown_extensions : - markdown_captions Some images have big size that does not show the detail, therefore, it\u2019s better to zoom in by clicking on them, and pan the image on the screen. The view-bigimg library can do that requirement well. Read more in Customize theme to learn how to enable that library. ![ A photo from <https://picsum.photos> ]( https://picsum.photos/320/240 ) A photo from https://picsum.photos","title":"7. Images"},{"location":"blog/setup-blog/markdown-syntax/#8-tabs","text":"Tabbed extension provides a syntax to easily add tabbed Markdown content. Enable the extension: markdown_extensions : - pymdownx.tabbed Tabs start with === to signify a tab followed by a quoted title. Consecutive tabs are grouped into a tab set. === \"Tab 1\" Some texts === \"Tab A\" Text A === \"Tab B\" Text B === \"Tab 2\" Some other texts Tab 1 Some texts Tab A Text A Tab B Text B Tab 2 Some other texts Styles for tabs need to change a little to have left margin in tab\u2019s content. Read more in Customize theme .","title":"8. Tabs"},{"location":"blog/setup-blog/markdown-syntax/#9-tables","text":"The Tables extension adds the ability to create tables in Markdown documents. Enable the extension: markdown_extensions : - tables Markdown Tables are written in pipe-line format: row is on one line, cell is inline text only. The 1 st line contains the column headers. The 2 nd line is to control text alignment in a column: :--- , :---: and ---: are left, center, and right alignment. Styles for table need to change a little to show cell border. Read more in Customize theme . | Syntax | Description | Test Text | | :--------- | :----------: | ----------: | | Left align | Center align | Right align | | A text | Another text | More texts | Syntax Description Test Text Left align Center align Right align A text Another text More texts","title":"9. Tables"},{"location":"blog/setup-blog/markdown-syntax/#10-formatting","text":"Some texts may have special formats, and here are extensions that can help to add some styles.","title":"10. Formatting"},{"location":"blog/setup-blog/markdown-syntax/#101-caret","text":"Caret optionally adds two different features which are syntactically built around the ^ character. Enable the extension: markdown_extensions : - pymdownx.caret The double carets ^^ inserts <ins></ins> tags, and the single caret ^ inserts <sup></sup> tags. ^^Insert^^ the energy E=mc^2^ Insert the energy E=mc 2","title":"10.1. Caret"},{"location":"blog/setup-blog/markdown-syntax/#102-mark","text":"Mark adds the ability to insert <mark></mark> tags. Enable the extension: markdown_extensions : - pymdownx.mark The syntax requires the text to be surrounded by double equal signs == . ==mark me== and ==mark==me==all== mark me and mark==me==all","title":"10.2. Mark"},{"location":"blog/setup-blog/markdown-syntax/#103-tildes","text":"Tildes optionally adds two different features which are syntactically built around the ~ character: delete using double tildes ~~ which inserts <del></del> tags and subscript using single tilde ~ which inserts <sub></sub> tags. Enable the extension: markdown_extensions : - pymdownx.tilde For example: ~~Delete~~ the existence of CH~3~CH~2~OH Delete the existence of CH 3 CH 2 OH","title":"10.3. Tildes"},{"location":"blog/setup-blog/markdown-syntax/#104-critic","text":"Critic is an extension that adds handling and support of Critic Markup which uses a special syntax to represent edits to a Markdown document. This extension runs before all other extensions to parse the critic edits. Enable the extension: markdown_extensions : - pymdownx.critic Critic Markup uses special markup to insert, delete, substitute, highlight, and comment. To insert or remove text, use {\u200b++insert me++} and {\u200b--remove me--}.\\ Denote a substitution with {\u200b~~substitute this~>with this~~}. Highlight specific text with {\u200b==highlight me==}.\\ Or even add {\u200b>>a comment<<}. To insert or remove text, use insert me and remove me . Denote a substitution with substitute this with this . Highlight specific text with highlight me . Or even add a comment .","title":"10.4. Critic"},{"location":"blog/setup-blog/markdown-syntax/#11-html-block","text":"The Markdown in HTML extension that parses Markdown inside of HTML block tags. Enable the extension: markdown_extensions : - md_in_html By default, Markdown ignores any content within a raw HTML block-level element. With this extension enabled, the content of a raw HTML block-level element can be parsed as Markdown by including a markdown attribute on the opening tag. <div> This is __not parsed word__ by Markdown. </div> <div markdown=\"1\"> This is a __bold__ word parsed by Markdown. </div> This is __not parsed word__ by Markdown. This is a bold word parsed by Markdown.","title":"11. HTML block"},{"location":"blog/setup-blog/markdown-syntax/#12-icons--emojis","text":"The Emoji extension adds support for inserting emoji via simple short names enclosed within colons :short_name: . This is accomplished by using a short name index to map easy-to-remember names to the corresponding emoji characters. Enable the extension: markdown_extensions : - pymdownx.emoji : emoji_index : !!python/name:materialx.emoji.twemoji emoji_generator : !!python/name:materialx.emoji.to_svg","title":"12. Icons &amp; Emojis"},{"location":"blog/setup-blog/markdown-syntax/#121-emojis","text":"Emojis can be written by putting the short-code of the emoji between two colons. Look up the short-codes at Emojipedia . :smile: :heart:","title":"12.1. Emojis"},{"location":"blog/setup-blog/markdown-syntax/#122-icons","text":"Icons can be used similarly to emojis, by referencing a valid path to any icon bundled with the theme, which are located in the .icons directory, and replacing / with - . For example: The short-code :material-account-circle: will be converted to an SVG image element with the path .icons/material/account-circle.svg which eventually shows the icon on the webpage.","title":"12.2. Icons"},{"location":"blog/setup-blog/markdown-syntax/#123-use-in-template","text":"Using include function of Jinja to add an icon wrapped in a twemoji class: <span class=\"twemoji\"> {% include \".icons/fontawesome/brands/twitter.svg\" %} </span> To show the Twitter icon .","title":"12.3. Use in template"},{"location":"blog/setup-blog/markdown-syntax/#13-escape-all","text":"The Escape All extension makes the backslash \\ character escape everything after it, except things in code blocks of any kind. Enable the extension: markdown_extensions : - pymdownx.escapeall : hardbreak : true nbsp : true There are two special escapes among all of these escapes though: escaping space characters and escaping newline characters: Enable nbsp to convert an escaped space into a non-breaking space: &nbsp; . Enable hardbreak to convert an escaped newline to a hard break <br> . The advantage of hard break is that the backslash is visually seen in the document, opposed to the Markdown\u2019s default method of two spaces at the end of a line. For example: This is a line with one space.\\ This is a new line with some \\ \\ \\ \\ \\ spaces. This is a line with one space. This is a new line with some spaces.","title":"13. Escape All"},{"location":"blog/setup-blog/markdown-syntax/#14-sane-headers","text":"The Sane Headers is an extension that alters the default hashed headers extension to require headers to have spaces after the hashes # in order to be recognized as headers. This allows for other extension syntaxes to use # in their syntaxes as long as no spaces follow the # at the beginning of a line. Enable the extension: markdown_extensions : - pymdownx.saneheaders In default, both of these are treated as headers: ## Header ##Also a Header With Sane Headers, only the first is a header: ## Header ##Not a Header","title":"14. Sane Headers"},{"location":"blog/setup-blog/markdown-syntax/#15-special-characters","text":"The Smarty Pants extension converts ASCII dashes, quotes and ellipses to their HTML entity equivalents. The Smart Symbols adds syntax for creating special characters such as trademarks, arrows, fractions, etc. Enable the extension: markdown_extensions : - smarty : smart_angled_quotes : true - pymdownx.smartsymbols","title":"15. Special characters"},{"location":"blog/setup-blog/markdown-syntax/#151-smarty-pants","text":"'single quote' \"double quote\" <<angle quote>> ellipses ... N-dash -- M-dash --- \u2018single quote\u2019 \u201cdouble quote\u201d \u00abangle quote\u00bb ellipses \u2026 N-dash \u2013 M-dash \u2014","title":"15.1. Smarty Pants"},{"location":"blog/setup-blog/markdown-syntax/#152-smart-symbols","text":"trademark (tm) copyright (c) registered (r) in care of c/o plus or minus +/- arrows --> <-- <--> not equal =/= fractions 1/4 ordinal numbers 1st 2nd 3rd 4th 5th trademark \u2122 copyright \u00a9 registered \u00ae in care of \u2105 plus or minus \u00b1 arrows \u2192 \u2190 \u2194 not equal \u2260 fractions \u00bc \u00bd \u00be ordinal numbers 1 st 2 nd 3 rd 4 th 5 th","title":"15.2. Smart Symbols"},{"location":"blog/setup-blog/markdown-syntax/#16-snippets","text":"The Snippets insert the content of a file into the Markdown document. It is great for situations where there is a content that needs to be inserted into multiple documents. Snippets is run as a preprocessor, so if a snippet is found in a fenced code block etc., it will still get processed. Enable the extension: markdown_extensions : - pymdownx.snippets There are two modes of inserting snippets: single line and block. Single line mode accepts a single file name, and block accepts multiple files. Single line format is done by placing the following markup for the single line notation: -\u200b-8<-- \"filename.ext\" In block format, it is important to note that empty lines are preserved for formatting. -\u200b-8<-- filename.md the below empty line is preserved.log filename.log -\u200b-8<-- To temporarily ignore a file, comment it out by pre-pending the path with semicolon ; and a space. This works for both single line and block format: -\u200b-8<-- \"; skip.md\" -\u200b-8<-- include.md ; skip.md -\u200b-8<--","title":"16. Snippets"},{"location":"blog/setup-blog/markdown-syntax/#17-custom-block","text":"The Custom Blocks extension defines a common markup to create parameter-supported and nested custom blocks. Install the extension: pip install -U markdown-customblocks Enable the extension: markdown_extensions : - customblocks This extension parses markup structures like this one: ::: type class param=value Indented content Example usage Add the filename of a code block, to show where it belongs. Syntax: ::: file main.c ```cpp int main ( void ) { return 0 ; } ``` with style: . md-typeset . file + p { font-size : 0.9 em ; color : gray ; margin-bottom : -1.2 em ; } will generate: main.c int main ( void ) { return 0 ; } There are some more custom block created with new layout and style, such as row and col . Read more in Customize theme .","title":"17. Custom block"},{"location":"blog/setup-blog/markdown-syntax/#18-footnotes","text":"The Footnotes extension adds syntax for defining footnotes in Markdown documents. Enable the extension: markdown_extensions : - footnotes And use the following syntax: Footnotes[^1] have a label[^fn] and the footnote's content. [ ^1 ]: This is a footnote content. [ ^fn ]: A footnote on the label `fn`. Footnotes 2 have a label 3 and the footnote\u2019s content.","title":"18. Footnotes"},{"location":"blog/setup-blog/markdown-syntax/#19-tips","text":"There are some tips when writing document in Markdown which help to format the content in a good layout.","title":"19. Tips"},{"location":"blog/setup-blog/markdown-syntax/#191-small-headers","text":"At small header levels <h5> and <h6> , the header text is smaller than the body text, and the header is transformed to all capitalized characters. Use a hard break and a bold text instead. This make text clear to be read, and have a good space to the previous paragraph. \\ **Item**","title":"19.1. Small headers"},{"location":"blog/setup-blog/markdown-syntax/#192-ignore-formatting","text":"When using Prettier extension to format the documents, some block can be ignored from formatting by adding directives. Refer to the Prettier \u2014 Ignore Code . Note the extension only format the markdown file, and when it is rendered to HTML, it will be displayed in HTML rendered visual. In Markdown, use block directive before a block that needs to be preserved: <!-- prettier-ignore --> Do not format this In case of a big block or multiple blocks, use the range directive: <!-- prettier-ignore-start --> | MY | AWESOME | AUTO-GENERATED | TABLE | |-|-|-|-| | a | b | c | d | <!-- prettier-ignore-end -->","title":"19.2. Ignore formatting"},{"location":"blog/setup-blog/markdown-syntax/#193-look-up-an-icon-or-emoji","text":"Material for MkDocs provides a tool to look up an icon or an emoji by searching a name. It has fast copy to clipboard when selecting on the wanted icon. Please go there https://squidfunk.github.io/mkdocs-material/reference/icons-emojis/ . Use mkdocs-macros plugin to use Jinja template directly in the Markdown content. \u21a9 This is a footnote content. \u21a9 A footnote on the label fn . \u21a9","title":"19.3. Look up an icon or emoji"},{"location":"blog/setup-blog/mkdocs-plugins/","text":"1. Awesome Pages \u2693\ufe0e MkDocs Awesome Pages plugin simplifies configuring page titles and their entries order. Install the plugin: pip install -U mkdocs-awesome-pages-plugin Enable it in the config file: plugins : - search # built-in search must be always activated - awesome-pages It overrides the nav sections in the site config file mkdocs.yml , and provides some more extra configs: Create a YAML file named .pages in a directory and use the nav attribute to customize the navigation on that level. List the files and subdirectories in the order that they should appear in the navigation. A 3-dots ... entry is used to specify where all remaining items should be inserted. It can filter the remaining items using glob patterns or regular expressions. For example: .pages nav : - ... | introduction-*.md - ... - summary.md The pattern is checked against the basename of remaining items - not their whole path, so it can be used to filter files in sub-folders. Hide directory by setting the hide attribute to true . Optionally set the directory title using the title attribute. Optionally specify a title for the navigation entry before its document path. For example: .pages title : New section nav : - First page : page1.md - Link Title : https://example.com Collapse single nested pages by setting collapse_single_pages attribute to true . Using collapse_single_pages only, before and after applying 2. Section index \u2693\ufe0e MkDocs Section Index is a plug that change the navigation sidebar to turn section name to a link that show the index page that section. Install the plugin: pip install -U mkdocs-section-index Enable it in the config file: plugins : - search # built-in search must be always activated - awesome-pages - section-index # must be after awesome-pages In MkDocs, each directory will become a section, and by default, section only contains its children. There is no page associated to a section. This plugin will merge the index.md page in the directory to its section label. However, the merge section page show the section\u2019s title from directory name , not the page\u2019s title. Using the Section Index plugin only, before and after applying This result is different from using collapse_single_pages: true option in the Awesome Pages plugin. If you use single page collapsing, Awesome Pages plugin replace the section which has only one child by its child page. Therefore, a directory with index.md and some sub-folders will not be processed to merge the index.md to the section label of that directory. Use both Awesome Pages collapse_single_pages option and Section Index will make a better result because both page and title are merged to the section. 3. Revision date \u2693\ufe0e To keep tracking the last modified date of a post, git-revision-date plugin can be used. A better alternative plugin is git-revision-date-localized which provides more types of date format (even in time-ago format), and the creation date. Install the plugin: pip install -U mkdocs-git-revision-date-localized-plugin Enable it in the config file: plugins : - search # built-in search must be always activated - git-revision-date-localized : enable_creation_date : true type : iso_date This plugin creates new field in the post\u2019s meta-data which content the creation and update date. This information is used to sort the posts by revision date to get recently updated items, as shown in the Blog page. Read more in the Customize theme . 4. Print to PDF \u2693\ufe0e To export the posts on this blog, there are plugins which can do it. However, most of them depend on Weasy Print which in turn depends on many other packages. There is one plugin that does print in an easy and simple way: use browser to print page by sending print command (like press Ctrl + S ). More detail of installation and configuration the MkDocs PDF with JS plugin for printing to PDF can be read in Print to PDF . 5. Macros \u2693\ufe0e This plugin is no longer used in this site! MkDocs Macros is a plugin/framework that makes it easy to produce richer and more beautiful pages. It can do two things: Transform the markdown pages into a Jinja2 templates that can use variables, macros and filters. Replace MkDocs plugins for a wide range of tasks: e.g. manipulating the navigation, adding files after the HTML pages have already been generated etc. Install the plugin: pip install -U mkdocs-macros-plugin Enable it in the config file: plugins : - search # built-in search must be always activated - macros Incomplete data in macro The macro {{ navigation.pages }} contains a list of all pages, but the data of each page maybe not complete, such as title or meta-data. This issue happens when rendering a the content of the first page, but it needs to know the content of the second page which has not been parsed already as it is waiting for the first page getting done. 6. DrawIO Exporter \u2693\ufe0e This plugin is no longer used in this site! DrawIO Exporter is a great plugin that exports the .drawio diagrams to images at build time and insert them to the document. This plugin can replace the Mermaid plugin, and it is faster thanks to no JavaScript needed at runtime. It also helps to enable instant navigation mode of the Material theme. Install the plugin: pip install -U mkdocs-drawio-exporter Enable it in the config file: plugins : - search # built-in search must be always activated - drawio-exporter To create end edit .drawio diagram, download and install the diagrams.net application. To import a diagram, just use the syntax for inserting an image: ![ My alt text ]( my-diagram.drawio ) The plugin will generate an SVG image to a cache folder (default in docs\\drawio-exporter ), and then modify the image source attribute to the generated image. If the diagram is a multi-page documents, append the index of the page as an anchor in the URL: ![ Page 1 ]( my-diagram.drawio#0 ) A draw.io diagram A limitation Using Draw.io Integration extension in Visual Studio Code, I can save a DrawIO diagram as a .drawio.svg file, then use that file directly in the page as an usual image. However this method will not support multiple pages in the drawing: ![ My alt text ]( my-diagram.drawio.svg ) // work ![ My alt text ]( my-diagram.drawio.svg#1 ) // does not work 7. Mermaid \u2693\ufe0e This plugin is no longer used in this site! MkDocs Mermaid2 is a plugin to render textual graph description into Mermaid graphs (flow charts, sequence diagrams, pie charts, etc.). Install the plugin: pip install -U mkdocs-mermaid2-plugin Enable it in the config file: plugins : - search # built-in search must be always activated - mermaid2 And configure the code block parser for mermaid2 blocks: markdown_extensions : - pymdownx.superfences : custom_fences : - name : mermaid class : mermaid format : !!python/name:mermaid2.fence_mermaid Example: ```mermaid graph LR A[Start] --> B{Error?}; B -->|Yes| C[Hmm...]; C --> D[Debug]; D --> B; B ---->|No| E[Yay!]; ``` will render as: A diagram generated by Mermaid","title":"MkDocs plugins"},{"location":"blog/setup-blog/mkdocs-plugins/#1-awesome-pages","text":"MkDocs Awesome Pages plugin simplifies configuring page titles and their entries order. Install the plugin: pip install -U mkdocs-awesome-pages-plugin Enable it in the config file: plugins : - search # built-in search must be always activated - awesome-pages It overrides the nav sections in the site config file mkdocs.yml , and provides some more extra configs: Create a YAML file named .pages in a directory and use the nav attribute to customize the navigation on that level. List the files and subdirectories in the order that they should appear in the navigation. A 3-dots ... entry is used to specify where all remaining items should be inserted. It can filter the remaining items using glob patterns or regular expressions. For example: .pages nav : - ... | introduction-*.md - ... - summary.md The pattern is checked against the basename of remaining items - not their whole path, so it can be used to filter files in sub-folders. Hide directory by setting the hide attribute to true . Optionally set the directory title using the title attribute. Optionally specify a title for the navigation entry before its document path. For example: .pages title : New section nav : - First page : page1.md - Link Title : https://example.com Collapse single nested pages by setting collapse_single_pages attribute to true . Using collapse_single_pages only, before and after applying","title":"1. Awesome Pages"},{"location":"blog/setup-blog/mkdocs-plugins/#2-section-index","text":"MkDocs Section Index is a plug that change the navigation sidebar to turn section name to a link that show the index page that section. Install the plugin: pip install -U mkdocs-section-index Enable it in the config file: plugins : - search # built-in search must be always activated - awesome-pages - section-index # must be after awesome-pages In MkDocs, each directory will become a section, and by default, section only contains its children. There is no page associated to a section. This plugin will merge the index.md page in the directory to its section label. However, the merge section page show the section\u2019s title from directory name , not the page\u2019s title. Using the Section Index plugin only, before and after applying This result is different from using collapse_single_pages: true option in the Awesome Pages plugin. If you use single page collapsing, Awesome Pages plugin replace the section which has only one child by its child page. Therefore, a directory with index.md and some sub-folders will not be processed to merge the index.md to the section label of that directory. Use both Awesome Pages collapse_single_pages option and Section Index will make a better result because both page and title are merged to the section.","title":"2. Section index"},{"location":"blog/setup-blog/mkdocs-plugins/#3-revision-date","text":"To keep tracking the last modified date of a post, git-revision-date plugin can be used. A better alternative plugin is git-revision-date-localized which provides more types of date format (even in time-ago format), and the creation date. Install the plugin: pip install -U mkdocs-git-revision-date-localized-plugin Enable it in the config file: plugins : - search # built-in search must be always activated - git-revision-date-localized : enable_creation_date : true type : iso_date This plugin creates new field in the post\u2019s meta-data which content the creation and update date. This information is used to sort the posts by revision date to get recently updated items, as shown in the Blog page. Read more in the Customize theme .","title":"3. Revision date"},{"location":"blog/setup-blog/mkdocs-plugins/#4-print-to-pdf","text":"To export the posts on this blog, there are plugins which can do it. However, most of them depend on Weasy Print which in turn depends on many other packages. There is one plugin that does print in an easy and simple way: use browser to print page by sending print command (like press Ctrl + S ). More detail of installation and configuration the MkDocs PDF with JS plugin for printing to PDF can be read in Print to PDF .","title":"4. Print to PDF"},{"location":"blog/setup-blog/mkdocs-plugins/#5-macros","text":"This plugin is no longer used in this site! MkDocs Macros is a plugin/framework that makes it easy to produce richer and more beautiful pages. It can do two things: Transform the markdown pages into a Jinja2 templates that can use variables, macros and filters. Replace MkDocs plugins for a wide range of tasks: e.g. manipulating the navigation, adding files after the HTML pages have already been generated etc. Install the plugin: pip install -U mkdocs-macros-plugin Enable it in the config file: plugins : - search # built-in search must be always activated - macros Incomplete data in macro The macro {{ navigation.pages }} contains a list of all pages, but the data of each page maybe not complete, such as title or meta-data. This issue happens when rendering a the content of the first page, but it needs to know the content of the second page which has not been parsed already as it is waiting for the first page getting done.","title":"5. Macros"},{"location":"blog/setup-blog/mkdocs-plugins/#6-drawio-exporter","text":"This plugin is no longer used in this site! DrawIO Exporter is a great plugin that exports the .drawio diagrams to images at build time and insert them to the document. This plugin can replace the Mermaid plugin, and it is faster thanks to no JavaScript needed at runtime. It also helps to enable instant navigation mode of the Material theme. Install the plugin: pip install -U mkdocs-drawio-exporter Enable it in the config file: plugins : - search # built-in search must be always activated - drawio-exporter To create end edit .drawio diagram, download and install the diagrams.net application. To import a diagram, just use the syntax for inserting an image: ![ My alt text ]( my-diagram.drawio ) The plugin will generate an SVG image to a cache folder (default in docs\\drawio-exporter ), and then modify the image source attribute to the generated image. If the diagram is a multi-page documents, append the index of the page as an anchor in the URL: ![ Page 1 ]( my-diagram.drawio#0 ) A draw.io diagram A limitation Using Draw.io Integration extension in Visual Studio Code, I can save a DrawIO diagram as a .drawio.svg file, then use that file directly in the page as an usual image. However this method will not support multiple pages in the drawing: ![ My alt text ]( my-diagram.drawio.svg ) // work ![ My alt text ]( my-diagram.drawio.svg#1 ) // does not work","title":"6. DrawIO Exporter"},{"location":"blog/setup-blog/mkdocs-plugins/#7-mermaid","text":"This plugin is no longer used in this site! MkDocs Mermaid2 is a plugin to render textual graph description into Mermaid graphs (flow charts, sequence diagrams, pie charts, etc.). Install the plugin: pip install -U mkdocs-mermaid2-plugin Enable it in the config file: plugins : - search # built-in search must be always activated - mermaid2 And configure the code block parser for mermaid2 blocks: markdown_extensions : - pymdownx.superfences : custom_fences : - name : mermaid class : mermaid format : !!python/name:mermaid2.fence_mermaid Example: ```mermaid graph LR A[Start] --> B{Error?}; B -->|Yes| C[Hmm...]; C --> D[Debug]; D --> B; B ---->|No| E[Yay!]; ``` will render as: A diagram generated by Mermaid","title":"7. Mermaid"},{"location":"blog/setup-blog/print-to-pdf/","text":"1. The cover page \u2693\ufe0e When printing to a PDF file, the first page should show the post title and its short description. This page is called the cover page which will be created only in printing mode. Create an element with class cover in the main.html template to wrap the cover section. In print mode, this element should cover the full height (100%) of the first paper and align its content vertically. After the line of tags, the updated date will be shown to easily check the latest version of the document: overrides\\main.html <style> @media print { .md-typeset .cover { height: 100vh; display: flex; flex-direction: column; justify-content: center; } } </style> <div class=\"cover\"> <h1 class=\"page-title\"> {{ title | d ( config.site_name , true ) }} </h1> <p class=\"page-description\"> {{ description }} </p> {% if tags is defined %} <p class=\"page-tags\"> {% for tag in tags %} <a class=\"tag\" href=\" {{ config.site_url }} tags/# {{ tag }} \"> <span class=\"tag-name\"> # {{ tag }} </span> </a> {% endfor %} </p> {% endif %} {% if page.meta.git_revision_date_localized %} {% import \"partials/language.html\" as lang with context %} <p class=\"md-source-date\"> <hr style=\"margin-bottom: .5em;\"> <small> {{ lang.t ( \"source.revision.date\" ) }} : {{ page.meta.git_revision_date_localized }} </small> </p> {% endif %} </div> 2. The Table of Content page \u2693\ufe0e When displaying on a screen, the Table of Content is displayed in the right sidebar. In printed pages, there should be a page to display the table of content too. This page is also only visible in printing. The base Material for MkDocs theme has a partial block for Table of Content section, so I just need to include it in the modified main.html template, between the cover page and the main content. {% block content %} <div class=\"cover\"> ... </div> <div class=\"toc\"> <h2>Table of Content</h2> {% include \"partials/toc.html\" %} </div> {{ page.content }} {% endblock %} There are some styles applied for this section: Hide the default label and add a new <h2> header Remove list-style to make a clear list When printing, remove color effect on link items . md-typeset . toc { display : none ; } . md-typeset . toc label { display : none ; } . md-typeset . toc . md-nav { font-size : unset ; line-height : 1.6 ; } . md-typeset . toc . md-nav--secondary { margin-left : -2 em ; } . md-typeset . toc . md-nav__list { margin : 0 ; } . md-typeset . toc ul { list-style : none ; } @ media print { . md-typeset . toc { display : block ; page-break-after : always ; } . md-typeset . toc . md-nav__link { color : var ( --md-typeset-a-color ); } . md-typeset . toc . md-nav__link . md-nav__link--active { font-weight : unset ; } } Preview of the printed document 3. Printing styles \u2693\ufe0e There are some more additional styles need to be applied on the page when printing. I preview the printed version using Save to PDF option in the Chrome browser. Set the paper size and printing margins: @ page { size : a4 portrait ; margin : 25mm 15mm 25mm 20mm ; } Some elements only show in printing version, add media query type to display them: . md-typeset . print-only { display : none ; } @ media print { . md-typeset . print-only { display : block ; } . md-typeset . screen-only { display : none ; } } Tabs labels should be marked in printing as they are selected: . md-typeset . tabbed-set > label { border-color : var ( --md-accent-fg-color ); color : var ( --md-accent-fg-color ); } The Disqus section also needs to be hidden in printing: @ media print { . md-typeset # __comments , . md-typeset # disqus_recommendations , . md-typeset # disqus_thread { display : none ; } } Class .new-page is used for force break page in printing: . md-typeset . new-page { page-break-after : always ; } it is good to used with a custom block: ::: new-page Some elements do not keep the top margin in printing: @ media print { . md-typeset . new-page + *, . md-typeset . toc + *, . md-typeset . btn-actions + * { margin-top : 0 ; } } Image and its caption should be displayed in the same page: @ media print { . md-typeset figure { page-break-inside : avoid ; } } Admonition can be printed on multiple pages: @ media print { . md-typeset . admonition , . md-typeset details { page-break-inside : auto ; } } 4. Print to PDF plugin \u2693\ufe0e The MkDocs PDF with JS Plugin 1 exports documentation in PDF format with rendered JavaScript content. This is very useful if documents have mermaid diagrams. A download button will be added to the top of the page, and it is hidden in the PDF files. For executing the JavaScript code, ChromeDriver is used, so it is necessary to: Install Chrome Download ChromeDriver Add the ChromeDriver to OS user\u2019s PATH environment After that, install the plugin: pip install -U git+https://github.com/vuquangtrong/mkdocs-pdf-with-js-plugin.git Install the original plugin with pip install mkdocs-pdf-with-js-plugin if don\u2019t need a customized version. The following features are not implemented in the original version. Enable the plugin: plugins : - search # built-in search must be always activated - pdf-with-js While building mkdocs build or serving mkdocs serve the documentation, the PDF files will be generated. They are stored in the site\\pdfs folder. 4.1. Add the download button \u2693\ufe0e Create an element to contain the download button at the beginning of the document content in the base.html template. This element should be hidden in printing mode. The plugin will find the < div class = \"btn-actions\" > element to insert a button. If there is no such existing element, the plugin will create a new element and insert to the page content. def _add_link ( self , soup , page_paths ): icon = BeautifulSoup ( '' '<span class=\"twemoji\">' '<svg viewBox=\"0 0 24 24\" xmlns=\"http://www.w3.org/2000/svg\">' '<path d=\"M5 20h14v-2H5m14-9h-4V3H9v6H5l7 7 7-7z\"></path>' '</svg>' '</span>' , 'html.parser' ) text = \"PDF\" btn = soup . new_tag ( \"a\" , href = page_paths [ \"relpath\" ]) btn . append ( icon ) btn . append ( text ) btn [ 'class' ] = 'md-button' bar = soup . find ( \"div\" , { \"class\" : \"btn-actions\" }) if bar : bar . p . insert ( 0 , btn ) else : toc = soup . find ( \"div\" , { \"class\" : \"toc\" }) if toc : div = BeautifulSoup ( '' '<div class=\"btn-actions screen-only\">' '<p></p>' '</div>' , 'html.parser' ) div . p . insert ( 0 , btn ) toc . insert_after ( div ) return soup 4.2. Add header and footer \u2693\ufe0e The command sent to ChromeDriver to print a page is Page.printToPDF , read more at Chrome DevTools Protocol \u2014 printToPDF . This command needs some parameters to control the printing, which include: landscape : boolean Paper orientation. Defaults to false. displayHeaderFooter : boolean Display header and footer. Defaults to false. headerTemplate : string HTML template for the print header. Should be valid HTML markup with following classes used to inject printing values into them: date : formatted print date title : document title url : document location pageNumber : current page number totalPages : total pages in the document For example, < span class = title ></ span > would generate a span containing the title . footerTemplate : string HTML template for the print footer. Should use the same format as the headerTemplate . Those parameters are initialized in the __init__ function: def __init__ ( self ): self . displayHeaderFooter = True self . headerTemplate = \\ '<div style=\"font-size:8px; margin:auto;\">' \\ '<span class=title></span>' \\ '</div>' self . footerTemplate = \\ '<div style=\"font-size:8px; margin:auto;\">' \\ 'Page <span class=\"pageNumber\"></span> of ' \\ '<span class=\"totalPages\"></span>' \\ '</div>' and they are used to creating print options in a dictionary variable: def _get_print_options ( self ): return { 'landscape' : False , 'displayHeaderFooter' : self . displayHeaderFooter , 'footerTemplate' : self . footerTemplate , 'headerTemplate' : self . headerTemplate , 'printBackground' : True , 'preferCSSPageSize' : True , } Finally, the print options are used in the print command: def print_to_pdf ( self , driver , page ): driver . get ( page [ \"url\" ]) result = self . _send_devtools_command ( driver , \"Page.printToPDF\" , self . _get_print_options () ) self . _write_file ( result [ 'data' ], page [ \"pdf_file\" ]) 4.3. Add plugin config options \u2693\ufe0e To allow user to change the print options in the project config file mkdocs.yml , add the config fields into the plugin.py file. class PdfWithJS ( BasePlugin ): config_scheme = ( ( 'enable' , config_options . Type ( bool , default = True )), ( 'display_header_footer' , config_options . Type ( bool , default = False )), ( 'header_template' , config_options . Type ( str , default = '' )), ( 'footer_template' , config_options . Type ( str , default = '' )), ) When the MkDocs engine calls to on_config() function in this plugin, save the user\u2019s configs as below: def on_config ( self , config , ** kwargs ): self . enabled = self . config [ 'enable' ] self . printer . set_config ( self . config [ 'display_header_footer' ], self . config [ 'header_template' ], self . config [ 'footer_template' ] ) return config By doing this, users can add their parameters to the pdf-with-js entry under the plugins field in the config file mkdocs.yml : plugins : - search # built-in search must be always activated - pdf-with-js : enable : true display_header_footer : true header_template : >- <div style=\"font-size:8px; margin:auto; color:lightgray;\"> <span class=title></span> </div> footer_template : >- <div style=\"font-size:8px; margin:auto; color:lightgray;\"> Page <span class=\"pageNumber\"></span> of <span class=\"totalPages\"></span> </div> That\u2019s it. When all blog posts now have a download button for users to get a PDF version. originally developed by smaxtec \u21a9","title":"Print to PDF"},{"location":"blog/setup-blog/print-to-pdf/#1-the-cover-page","text":"When printing to a PDF file, the first page should show the post title and its short description. This page is called the cover page which will be created only in printing mode. Create an element with class cover in the main.html template to wrap the cover section. In print mode, this element should cover the full height (100%) of the first paper and align its content vertically. After the line of tags, the updated date will be shown to easily check the latest version of the document: overrides\\main.html <style> @media print { .md-typeset .cover { height: 100vh; display: flex; flex-direction: column; justify-content: center; } } </style> <div class=\"cover\"> <h1 class=\"page-title\"> {{ title | d ( config.site_name , true ) }} </h1> <p class=\"page-description\"> {{ description }} </p> {% if tags is defined %} <p class=\"page-tags\"> {% for tag in tags %} <a class=\"tag\" href=\" {{ config.site_url }} tags/# {{ tag }} \"> <span class=\"tag-name\"> # {{ tag }} </span> </a> {% endfor %} </p> {% endif %} {% if page.meta.git_revision_date_localized %} {% import \"partials/language.html\" as lang with context %} <p class=\"md-source-date\"> <hr style=\"margin-bottom: .5em;\"> <small> {{ lang.t ( \"source.revision.date\" ) }} : {{ page.meta.git_revision_date_localized }} </small> </p> {% endif %} </div>","title":"1. The cover page"},{"location":"blog/setup-blog/print-to-pdf/#2-the-table-of-content-page","text":"When displaying on a screen, the Table of Content is displayed in the right sidebar. In printed pages, there should be a page to display the table of content too. This page is also only visible in printing. The base Material for MkDocs theme has a partial block for Table of Content section, so I just need to include it in the modified main.html template, between the cover page and the main content. {% block content %} <div class=\"cover\"> ... </div> <div class=\"toc\"> <h2>Table of Content</h2> {% include \"partials/toc.html\" %} </div> {{ page.content }} {% endblock %} There are some styles applied for this section: Hide the default label and add a new <h2> header Remove list-style to make a clear list When printing, remove color effect on link items . md-typeset . toc { display : none ; } . md-typeset . toc label { display : none ; } . md-typeset . toc . md-nav { font-size : unset ; line-height : 1.6 ; } . md-typeset . toc . md-nav--secondary { margin-left : -2 em ; } . md-typeset . toc . md-nav__list { margin : 0 ; } . md-typeset . toc ul { list-style : none ; } @ media print { . md-typeset . toc { display : block ; page-break-after : always ; } . md-typeset . toc . md-nav__link { color : var ( --md-typeset-a-color ); } . md-typeset . toc . md-nav__link . md-nav__link--active { font-weight : unset ; } } Preview of the printed document","title":"2. The Table of Content page"},{"location":"blog/setup-blog/print-to-pdf/#3-printing-styles","text":"There are some more additional styles need to be applied on the page when printing. I preview the printed version using Save to PDF option in the Chrome browser. Set the paper size and printing margins: @ page { size : a4 portrait ; margin : 25mm 15mm 25mm 20mm ; } Some elements only show in printing version, add media query type to display them: . md-typeset . print-only { display : none ; } @ media print { . md-typeset . print-only { display : block ; } . md-typeset . screen-only { display : none ; } } Tabs labels should be marked in printing as they are selected: . md-typeset . tabbed-set > label { border-color : var ( --md-accent-fg-color ); color : var ( --md-accent-fg-color ); } The Disqus section also needs to be hidden in printing: @ media print { . md-typeset # __comments , . md-typeset # disqus_recommendations , . md-typeset # disqus_thread { display : none ; } } Class .new-page is used for force break page in printing: . md-typeset . new-page { page-break-after : always ; } it is good to used with a custom block: ::: new-page Some elements do not keep the top margin in printing: @ media print { . md-typeset . new-page + *, . md-typeset . toc + *, . md-typeset . btn-actions + * { margin-top : 0 ; } } Image and its caption should be displayed in the same page: @ media print { . md-typeset figure { page-break-inside : avoid ; } } Admonition can be printed on multiple pages: @ media print { . md-typeset . admonition , . md-typeset details { page-break-inside : auto ; } }","title":"3. Printing styles"},{"location":"blog/setup-blog/print-to-pdf/#4-print-to-pdf-plugin","text":"The MkDocs PDF with JS Plugin 1 exports documentation in PDF format with rendered JavaScript content. This is very useful if documents have mermaid diagrams. A download button will be added to the top of the page, and it is hidden in the PDF files. For executing the JavaScript code, ChromeDriver is used, so it is necessary to: Install Chrome Download ChromeDriver Add the ChromeDriver to OS user\u2019s PATH environment After that, install the plugin: pip install -U git+https://github.com/vuquangtrong/mkdocs-pdf-with-js-plugin.git Install the original plugin with pip install mkdocs-pdf-with-js-plugin if don\u2019t need a customized version. The following features are not implemented in the original version. Enable the plugin: plugins : - search # built-in search must be always activated - pdf-with-js While building mkdocs build or serving mkdocs serve the documentation, the PDF files will be generated. They are stored in the site\\pdfs folder.","title":"4. Print to PDF plugin"},{"location":"blog/setup-blog/print-to-pdf/#41-add-the-download-button","text":"Create an element to contain the download button at the beginning of the document content in the base.html template. This element should be hidden in printing mode. The plugin will find the < div class = \"btn-actions\" > element to insert a button. If there is no such existing element, the plugin will create a new element and insert to the page content. def _add_link ( self , soup , page_paths ): icon = BeautifulSoup ( '' '<span class=\"twemoji\">' '<svg viewBox=\"0 0 24 24\" xmlns=\"http://www.w3.org/2000/svg\">' '<path d=\"M5 20h14v-2H5m14-9h-4V3H9v6H5l7 7 7-7z\"></path>' '</svg>' '</span>' , 'html.parser' ) text = \"PDF\" btn = soup . new_tag ( \"a\" , href = page_paths [ \"relpath\" ]) btn . append ( icon ) btn . append ( text ) btn [ 'class' ] = 'md-button' bar = soup . find ( \"div\" , { \"class\" : \"btn-actions\" }) if bar : bar . p . insert ( 0 , btn ) else : toc = soup . find ( \"div\" , { \"class\" : \"toc\" }) if toc : div = BeautifulSoup ( '' '<div class=\"btn-actions screen-only\">' '<p></p>' '</div>' , 'html.parser' ) div . p . insert ( 0 , btn ) toc . insert_after ( div ) return soup","title":"4.1. Add the download button"},{"location":"blog/setup-blog/print-to-pdf/#42-add-header-and-footer","text":"The command sent to ChromeDriver to print a page is Page.printToPDF , read more at Chrome DevTools Protocol \u2014 printToPDF . This command needs some parameters to control the printing, which include: landscape : boolean Paper orientation. Defaults to false. displayHeaderFooter : boolean Display header and footer. Defaults to false. headerTemplate : string HTML template for the print header. Should be valid HTML markup with following classes used to inject printing values into them: date : formatted print date title : document title url : document location pageNumber : current page number totalPages : total pages in the document For example, < span class = title ></ span > would generate a span containing the title . footerTemplate : string HTML template for the print footer. Should use the same format as the headerTemplate . Those parameters are initialized in the __init__ function: def __init__ ( self ): self . displayHeaderFooter = True self . headerTemplate = \\ '<div style=\"font-size:8px; margin:auto;\">' \\ '<span class=title></span>' \\ '</div>' self . footerTemplate = \\ '<div style=\"font-size:8px; margin:auto;\">' \\ 'Page <span class=\"pageNumber\"></span> of ' \\ '<span class=\"totalPages\"></span>' \\ '</div>' and they are used to creating print options in a dictionary variable: def _get_print_options ( self ): return { 'landscape' : False , 'displayHeaderFooter' : self . displayHeaderFooter , 'footerTemplate' : self . footerTemplate , 'headerTemplate' : self . headerTemplate , 'printBackground' : True , 'preferCSSPageSize' : True , } Finally, the print options are used in the print command: def print_to_pdf ( self , driver , page ): driver . get ( page [ \"url\" ]) result = self . _send_devtools_command ( driver , \"Page.printToPDF\" , self . _get_print_options () ) self . _write_file ( result [ 'data' ], page [ \"pdf_file\" ])","title":"4.2. Add header and footer"},{"location":"blog/setup-blog/print-to-pdf/#43-add-plugin-config-options","text":"To allow user to change the print options in the project config file mkdocs.yml , add the config fields into the plugin.py file. class PdfWithJS ( BasePlugin ): config_scheme = ( ( 'enable' , config_options . Type ( bool , default = True )), ( 'display_header_footer' , config_options . Type ( bool , default = False )), ( 'header_template' , config_options . Type ( str , default = '' )), ( 'footer_template' , config_options . Type ( str , default = '' )), ) When the MkDocs engine calls to on_config() function in this plugin, save the user\u2019s configs as below: def on_config ( self , config , ** kwargs ): self . enabled = self . config [ 'enable' ] self . printer . set_config ( self . config [ 'display_header_footer' ], self . config [ 'header_template' ], self . config [ 'footer_template' ] ) return config By doing this, users can add their parameters to the pdf-with-js entry under the plugins field in the config file mkdocs.yml : plugins : - search # built-in search must be always activated - pdf-with-js : enable : true display_header_footer : true header_template : >- <div style=\"font-size:8px; margin:auto; color:lightgray;\"> <span class=title></span> </div> footer_template : >- <div style=\"font-size:8px; margin:auto; color:lightgray;\"> Page <span class=\"pageNumber\"></span> of <span class=\"totalPages\"></span> </div> That\u2019s it. When all blog posts now have a download button for users to get a PDF version. originally developed by smaxtec \u21a9","title":"4.3. Add plugin config options"},{"location":"blog/stm32/","text":"STM32 Nucleo boards Topics \u2693\ufe0e In this blog, I\u2019ll try to write posts in an easy-to-follow order, so that beginners can understand them well. There are also some advanced topics for debugging or programming with more complex techniques or projects. Communities \u2693\ufe0e Official Homepage: https://www.st.com/ ST\u2019s Education center: https://www.st.com/content/st_com/en/support/learning/stm32-education.html The Education Center has a lot of materials and documents arranged into groups: basics, tools, product lines, application, tips & tricks. ST\u2019s Forum: https://community.st.com/s/ ST\u2019s Wiki page: https://wiki.st.com/stm32mcu OpenSTM32 Forum: https://www.openstm32.org/forums STM32Duino: https://www.stm32duino.com/ Content \u2693\ufe0e The content of each post is based on my experience, but it\u2019s hard to write down all of them. Since I also taught some embedded courses in my company for freshers, I would like to keep the content as simple as possible to help beginners feel easy to follow. The guides and tutorials given here can be applied to different types of STM32 MCUs, as I will try to use the internal peripherals of the microcontroller and some popular external ones. I am also in the process of learning, therefore, some posts I shared may have a mistake or be out-of-date, so please give me a comment and feedback to help me improve this series. I hope you can find something interesting and helpful here. References \u2693\ufe0e While learning, I\u2019ve read a lot of resource on books and on the internet. I could not re-draw or rephrase all the information pieces, so I will use include them in my posts. In those cases, the credit belong to the original authors. Here are the reference list: The book \u201cMastering STM32\u201d by Carmine Noviello The tutorials on DeepBlue MBedded","title":"STM32"},{"location":"blog/stm32/#topics","text":"In this blog, I\u2019ll try to write posts in an easy-to-follow order, so that beginners can understand them well. There are also some advanced topics for debugging or programming with more complex techniques or projects.","title":"Topics"},{"location":"blog/stm32/#communities","text":"Official Homepage: https://www.st.com/ ST\u2019s Education center: https://www.st.com/content/st_com/en/support/learning/stm32-education.html The Education Center has a lot of materials and documents arranged into groups: basics, tools, product lines, application, tips & tricks. ST\u2019s Forum: https://community.st.com/s/ ST\u2019s Wiki page: https://wiki.st.com/stm32mcu OpenSTM32 Forum: https://www.openstm32.org/forums STM32Duino: https://www.stm32duino.com/","title":"Communities"},{"location":"blog/stm32/#content","text":"The content of each post is based on my experience, but it\u2019s hard to write down all of them. Since I also taught some embedded courses in my company for freshers, I would like to keep the content as simple as possible to help beginners feel easy to follow. The guides and tutorials given here can be applied to different types of STM32 MCUs, as I will try to use the internal peripherals of the microcontroller and some popular external ones. I am also in the process of learning, therefore, some posts I shared may have a mistake or be out-of-date, so please give me a comment and feedback to help me improve this series. I hope you can find something interesting and helpful here.","title":"Content"},{"location":"blog/stm32/#references","text":"While learning, I\u2019ve read a lot of resource on books and on the internet. I could not re-draw or rephrase all the information pieces, so I will use include them in my posts. In those cases, the credit belong to the original authors. Here are the reference list: The book \u201cMastering STM32\u201d by Carmine Noviello The tutorials on DeepBlue MBedded","title":"References"},{"location":"blog/stm32/adc/","text":"Joystick with F051 1. Analog to Digital Converter \u2693\ufe0e An Analog-to-Digital Converter (ADC) is able to acquire input voltage level and convert it to a number. The input voltage is compared against a well known and fixed voltage, also known as reference voltage. This reference voltage can be either derived from the V DDA domain or, in MCUs with high pin count, supplied by an external and fixed reference voltage generator V REF+ . The majority of STM32 MCUs provide a 12-bit ADC. Some of them from the STM32F3 portfolio even a 16-bit ADC. In almost all STM32 microcontrollers, the ADC is implemented as a Successive Approximation Register ADC . MCUs usually have more than ten channels, allowing to measure signals from external sources. Moreover, some internal channels are also available: a channel for internal temperature sensor (V SENSE ), one for internal reference voltage (V REFINT ), one for monitoring external V BAT power supply and a channel for monitoring LCD voltage in those MCUs providing a native monochrome passive LCD controller (for example, the STM32L053). ADCs implemented in STM32F3 and in the majority of STM32L4 MCUs are also capable of converting fully differential inputs. A/D conversion of the various channels can be performed in single, continuous, scan, or discontinuous mode. The result of the ADC is stored in a left- or right-aligned 16-bit data register. Moreover, the ADC also implements the analog watchdog feature, which allows the application to detect if the input voltage goes outside the user-defined higher or lower thresholds: if this happens, a dedicated IRQ fires. A simplified structure of an ADC An input selection and scan control unit performs the selection of the input source to the ADC. Depending on the conversion mode (single, scan or continuous mode), this unit automatically switches among the input channels, so that every one can be sampled periodically. The output from this unit feeds the ADC. The start and stop control unit is to control the A/D conversion process, and it can be triggered by software or by a variable number of input sources. Moreover, it is internally connected to the TRGO line of some timers so that time-driven conversions can be automatically performed in DMA mode. The internal structure of a SAR ADC The input signal goes through the Sample-and-Hold (SHA) unit, a feature available in all ADCs, to keep the input signal constant during the conversion cycle. To keep the voltage level of the input constant, the SHA is implemented with a network of capacitors: this ensures that source signal is kept at a certain level during the A/D conversion, which is a procedure that requires a given amount of time, depending on the conversion frequency chosen. The output from the SHA module feeds a comparator that compares it with another signal generated by an internal DAC. The result of comparison is sent to the logic unit, which computes the numerical representation of the input signal according a well-characterized algorithm. This algorithm is what distinguishes SAR ADC from other A/D converters. The Successive Approximation algorithm computes the voltage of the input signal by comparing it with the one generated by the internal DAC, which is a fraction of the V REF voltage: if the input signal is higher than this internal reference voltage, then this is further increased until the input signal is lower . The final result will correspond to a number ranging from zero to the maximum 12-bit unsigned integer. The SAR algorithm essentially performs a search in a binary tree. The great advantage of this algorithm is that the conversion is performed in N-cycles, where N corresponds to the ADC resolution. So a 12-bit ADC requires twelve cycles to perform a conversion. 2. Calibration \u2693\ufe0e The ADC has a calibration feature. During the procedure, the ADC calculates a calibration factor which is internally applied to the ADC until the next ADC power-off. The application must not use the ADC during calibration and must wait until it is complete. Calibration should be performed before starting A/D conversion. It removes the offset error which may vary from chip to chip due to process variation. The calibration is initiated by software by setting bit ADCAL=1 . Calibration can only be initiated when the ADC is disabled (when ADEN=0 ). ADCAL bit stays at 1 during all the calibration sequence. It is then cleared by hardware as soon the calibration completes. After this, the calibration factor can be read from the ADC_DR register (from bits 6 to 0). 3. Conversion clock \u2693\ufe0e The ADC clock mainly is derived from the APB clock, however it may have a dual clock-domain architecture on some MCU line: The ADC clock can be a specific clock source, named \u201cADC asynchronous clock\u201d which is independent and asynchronous with the APB clock. It has the advantage of reaching the maximum ADC clock frequency whatever the APB clock scheme selected. The ADC clock can be derived from the APB clock of the ADC bus interface, divided by a programmable factor (2/4/n) and it must not exceed 14 MHz . This has the advantage of bypassing the clock domain re-synchronizations. This can be useful when the ADC is triggered by a timer and if the application requires that the ADC is precisely triggered without any uncertainty. 4. Conversion Modes \u2693\ufe0e ADCs implemented in STM32 MCUs provide several conversion modes useful to deal with different application scenarios. 4.1. Single-Channel, Single Conversion Mode \u2693\ufe0e In this mode, the ADC performs the single conversion (single sample) of a single channel, then stops when conversion is finished. 4.2. Multiple-channel, Single Conversion Mode \u2693\ufe0e It\u2019s also known as Scan Single Conversion Mode. A sequence can have up-to 16 channels, in a custom order. ADC module do not need to stop for CPU to configure the next channel, therefore, it saves CPU load can run in background. DMA is used to store converted data. 4.3. Single-Channel, Continuous Conversion Mode \u2693\ufe0e This mode converts a single channel continuously and indefinitely in regular channel conversion. The continuous mode feature allows the ADC to work in the background. The ADC converts the channels continuously without any intervention from the CPU. Additionally, the DMA can be used in circular mode, thus reducing the CPU load. 4.4. Multiple-channel, Continuous Conversion Mode \u2693\ufe0e This mode is also called multichannel continuous mode, and it can be used to convert some channels successively with the ADC in independent mode. Scan conversions are carried out in DMA mode. .small-image img { max-width: 50%; } .small-image2 img { max-width: 65%; } 1 Channel, Single Mode N-Channel, Single Mode 1-Channel, Continuous Mode N-Channel, Continuous Mode 4.5. Injected Conversion Mode \u2693\ufe0e This mode is intended for use when conversion is triggered by an external event or by software. The injected group has priority over the regular channel group. It interrupts the conversion of the current channel in the regular channel group. Injected conversion mode For example, this mode can be used to synchronize the conversion of channels to an event. It is interested in motor control applications where transistor switching generates noise that impacts ADC measurements and results in wrong conversions. Using a timer, the injected conversion mode can thus be implemented to delay the ADC measurements to after the transistor switching. 5. Channel Selection \u2693\ufe0e Depending on the STM32 family and package used, ADCs in STM32 MCUs can convert signals from a variable number of channels. 5.1. F0 and L0 families \u2693\ufe0e In F0 and L0 families the allocation of channel is fixed : the first one is always IN0, the second IN1 and so on. User can decide only if a channel is enabled or not. This means that in scan mode the first sampled channel will be always IN0, the second IN1 and so on. The sampling speed is applied to all channel in F0 and L0 families . To read 1-channel, it is needed to disable the previous configured channel. If more than 1 channel is enabled, ADC will work in N-channel modem, causing reading ADC value always returns the value of the first channel. This will be explained more in the Lab 1 which use an STM32 F0 51R8 MCU. 5.2. Other Fx and Lx families \u2693\ufe0e Other STM32 MCUs, instead, offer the notion of group . A group consists of a sequence of conversions that can be done on any channel and in any order. The reordering of channels is performed by assigning to them an index (called rank ) ranging from 1 to 16. Those MCUs offering this possibility also allow to select the sampling speed of each channel individually, differently from F0/L0 MCUs where the configuration is ADC-wide. There exist two groups for each ADC: A regular group, made of up to 16 channels, which corresponds to the sequence of sampled channels during a scan conversion. An injected group, made of up to 4 channels, which corresponds to the sequence of injected channel if an injected conversion is performed. This will be explained more in the Lab 2 which use an STM32 F4 11CE MCU. 6. Lab 1: Joystick in Polling Mode \u2693\ufe0e The PS2 joystick module shown in the figure down below is basically a couple of potentiometers (variable resistors) that moves in 2 axes. This creates a voltage difference that can be read using any ADC peripheral on two analog pins: VRX and VRY . A simple joystick Requirements Read Joystick analog pins VRX and VRY concurrently Transfer these value in raw number on UART1 A target board Any board which has STM32 MCUs. This tutorial will be using the STM32F0 Discovery board, which features an STM32F051R8 Cortex-M0 MCU. STM32F051R8 Mode External peripheral PA9 Alternate Function UART1 TX PA10 Alternate Function UART1 RX PC8 GPIO Output Blue LED PC9 GPIO Output Green LED PA1 Analog Input 1 VRX PA2 Analog Input 2 VRY 6.1. Start a new project \u2693\ufe0e Open STM32CubeIDE and create a new STM32 with STM32F051R8 MCU by selecting the target board or just the target MCU. Make sure to configure below settings: Set the HLCK to 48 MHz Set the Debug mode to Debug Serial Wire Enable USART1 with settings: 115200 bps, 8 bits, no Parity, and 1-bit stop Set the PC8 and PC9 pins to GPIO output mode 6.2. Enable ADC Peripheral \u2693\ufe0e In the ADC module under the Analog category, select below settings: Select Input Channel IN1 , and IN2 Clock Pre-scaler: If there is a dedicated HSI ADC clock source, Asynchronous clock can be selected. Otherwise, if the clock source is derived from APB clock, there is synchronous mode available there. Continuous/Discontinuous Conversion Mode are disabled by default, as ADC is not in scan mode DMA Continuous Request is disabled by default End of Conversion flag is selected to be set at End of single conversion Overrun behavior is set to Overrun Data Preserved Sampling time: base on the required conversion speed For example, select 239.5 cycles will result as 239.5 + 12 * 1/14000000 = 18 us (one conversion time), i.e. 55.5 kHz conversion rate. Setup ADC in polling mode 6.3. Generated code \u2693\ufe0e An ADC instance ADC_HandleTypeDef hadc; is created and the that ADC is initialized in the function MX_ADC_Init() in which the common settings will be applied. After that, it enables all selected channel for a converting sequence. static void MX_ADC_Init_Single_Conversion ( void ) { ADC_ChannelConfTypeDef sConfig = { 0 }; /** Configure the global features of the ADC (Clock, Resolution, Data Alignment and number of conversion) */ hadc . Instance = ADC1 ; hadc . Init . ClockPrescaler = ADC_CLOCK_ASYNC_DIV1 ; hadc . Init . Resolution = ADC_RESOLUTION_12B ; hadc . Init . DataAlign = ADC_DATAALIGN_RIGHT ; hadc . Init . ScanConvMode = ADC_SCAN_DIRECTION_FORWARD ; hadc . Init . EOCSelection = ADC_EOC_SINGLE_CONV ; hadc . Init . LowPowerAutoWait = DISABLE ; hadc . Init . LowPowerAutoPowerOff = DISABLE ; hadc . Init . ContinuousConvMode = DISABLE ; hadc . Init . DiscontinuousConvMode = DISABLE ; hadc . Init . ExternalTrigConv = ADC_SOFTWARE_START ; hadc . Init . ExternalTrigConvEdge = ADC_EXTERNALTRIGCONVEDGE_NONE ; hadc . Init . DMAContinuousRequests = DISABLE ; hadc . Init . Overrun = ADC_OVR_DATA_PRESERVED ; if ( HAL_ADC_Init ( & hadc ) != HAL_OK ) { Error_Handler (); } } 6.4. Single-Channel, Single Conversion \u2693\ufe0e To read an ADC channel, it is needed to configure one and only target channel. If there is more than one channel, ADC module will act as scan mode, and if the target channel has its number less than the first enabled channel, it will not be read. Here is the sequence to read a channel Clear all channel registered in Channel Selection CHSELR register by assigning it to 0. Enable the target channel by calling to HAL_ADC_ConfigChannel() with a config having: Channel Number, ADC_RANK_CHANNEL_NUMBER rank, and Sample Time Call to HAL_ADC_Start() Call to HAL_ADC_PollForConversion() Read the returned value with HAL_ADC_GetValue() Clear all channel registered in Channel Selection CHSELR register by assigning it to 0. void Add_ADC_Channel ( ADC_HandleTypeDef * hadc , uint32_t channel , uint32_t sampling_time ) { ADC_ChannelConfTypeDef sConfig = { 0 }; /** Configure for the selected ADC regular channel to be converted. */ sConfig . Channel = channel ; sConfig . Rank = ADC_RANK_CHANNEL_NUMBER ; sConfig . SamplingTime = sampling_time ; if ( HAL_ADC_ConfigChannel ( hadc , & sConfig ) != HAL_OK ) { Error_Handler (); } } uint32_t Read_ADC_Channel ( ADC_HandleTypeDef * hadc , uint32_t channel , uint32_t sampling_time ) { uint32_t adc_value = 0 ; // clear all channel hadc -> Instance -> CHSELR = 0 ; Add_ADC_Channel ( hadc , channel , sampling_time ); // read HAL_ADC_Start ( hadc ); HAL_ADC_PollForConversion ( hadc , HAL_MAX_DELAY ); adc_value = HAL_ADC_GetValue ( hadc ); HAL_ADC_Stop ( hadc ); // clear all channel hadc -> Instance -> CHSELR = 0 ; // return return adc_value ; } Read Joystick\u2019s position As the ADC value is an 12-bit register, Joystick has 2 channels, an array will be used to store the Joystick\u2019s position. A buffer also is used to hold the message which will be sent on UART1. uint16_t joystick [ 2 ] = { 0 }; char buffer [ 12 ] = { 0 }; // xxxx,yyyy\\r\\n It is recommended to do ADC Calibration before activating the ADC conversion. Then in the main while loop, call to Read_ADC() on ADC_CHANNEL_1 and ADC_CHANNEL_2 . The 20 ms delay will help to reduce the conversion rate to about 50 Hz. int main ( void ) { #if defined(ADC_1_CH_SINGLE_MODE) MX_ADC_Init_Single_Conversion (); HAL_ADCEx_Calibration_Start ( & hadc ); #endif while ( 1 ) { #ifdef ADC_1_CH_SINGLE_MODE HAL_GPIO_TogglePin ( LED_GPIO_Port , LED_Pin ); joystick [ JS_X ] = Read_ADC_Channel ( & hadc , ADC_CHANNEL_1 , ADC_SAMPLETIME_239CYCLES_5 ); joystick [ JS_Y ] = Read_ADC_Channel ( & hadc , ADC_CHANNEL_2 , ADC_SAMPLETIME_239CYCLES_5 ); #endif HAL_UART_Transmit ( & huart1 , ( uint8_t * ) buffer , strlen ( buffer ), HAL_MAX_DELAY ); HAL_Delay ( 20 ); } } Run the application and connect to the UART1 terminal, value of VRX and VRY will be printed out, like below: Joystick\u2019s position is printed in raw string To visualize the data, use Arduino Serial Plotter feature or Serial Plot program. Joystick\u2019s value in a timeline graph Joystick\u2019s value in a timeline graph 6.5. Multiple-Channel, Single Conversion \u2693\ufe0e In the Single Conversion mode, if multiple channels are registered, ADC module will automatically run int Multiple-Channel scan mode. F0/L0 families use the channel numbers as the scan order in Multiple-Channel mode In the Multiple-Channel mode , ADC module starts with the first activated channel which has the smallest channel number when the function HAL_ADC_Start() is called. For each subsequence call of HAL_ADC_PollForConversion() , ADC module read the channel then move to the next channel, and wait for next polling call. int main ( void ) { #if defined(ADC_1_CH_SINGLE_MODE) || defined(ADC_N_CH_SINGLE_MODE) MX_ADC_Init_Single_Conversion (); HAL_ADCEx_Calibration_Start ( & hadc ); #endif while ( 1 ) { #ifdef ADC_N_CH_SINGLE_MODE HAL_GPIO_TogglePin ( LED_GPIO_Port , LED_Pin ); HAL_ADC_Start ( & hadc ); HAL_ADC_PollForConversion ( & hadc , HAL_MAX_DELAY ); joystick [ JS_X ] = HAL_ADC_GetValue ( & hadc ); HAL_ADC_PollForConversion ( & hadc , HAL_MAX_DELAY ); joystick [ JS_Y ] = HAL_ADC_GetValue ( & hadc ); HAL_ADC_Stop ( & hadc ); #endif HAL_UART_Transmit ( & huart1 , ( uint8_t * ) buffer , strlen ( buffer ), HAL_MAX_DELAY ); HAL_Delay ( 20 ); } } 6.6. Continuous Conversion \u2693\ufe0e ADC module will not stop in this mode. When it finishes converting the last channel, it goes back to the first channel and then do conversion again. The modified points are: Continuous Conversion Mode is enabled DMA Continuous Request is enabled End of Conversion flag is selected to be set at End of sequence of conversion DMA Settings is set to Circular mode, Data increment for Memory with Half-Word width Setup ADC in continuous mode with DMA void MX_ADC_Init_Continuous_Conversion ( void ) { hadc . Instance = ADC1 ; hadc . Init . ClockPrescaler = ADC_CLOCK_ASYNC_DIV1 ; hadc . Init . Resolution = ADC_RESOLUTION_12B ; hadc . Init . DataAlign = ADC_DATAALIGN_RIGHT ; hadc . Init . ScanConvMode = ADC_SCAN_DIRECTION_FORWARD ; hadc . Init . EOCSelection = ADC_EOC_SEQ_CONV ; hadc . Init . LowPowerAutoWait = DISABLE ; hadc . Init . LowPowerAutoPowerOff = DISABLE ; hadc . Init . ContinuousConvMode = ENABLE ; hadc . Init . DiscontinuousConvMode = DISABLE ; hadc . Init . ExternalTrigConv = ADC_SOFTWARE_START ; hadc . Init . ExternalTrigConvEdge = ADC_EXTERNALTRIGCONVEDGE_NONE ; hadc . Init . DMAContinuousRequests = ENABLE ; hadc . Init . Overrun = ADC_OVR_DATA_PRESERVED ; if ( HAL_ADC_Init ( & hadc ) != HAL_OK ) { Error_Handler (); } } Then DMA module is linked to the ADC module in the function HAL_ADC_MspInit() : void HAL_ADC_MspInit ( ADC_HandleTypeDef * hadc ) { GPIO_InitTypeDef GPIO_InitStruct = { 0 }; if ( hadc -> Instance == ADC1 ) { __HAL_RCC_ADC1_CLK_ENABLE (); __HAL_RCC_GPIOA_CLK_ENABLE (); /**ADC GPIO Configuration PA1 ------> ADC_IN1 PA2 ------> ADC_IN2 */ GPIO_InitStruct . Pin = GPIO_PIN_1 | GPIO_PIN_2 ; GPIO_InitStruct . Mode = GPIO_MODE_ANALOG ; GPIO_InitStruct . Pull = GPIO_NOPULL ; HAL_GPIO_Init ( GPIOA , & GPIO_InitStruct ); /* ADC1 DMA Init */ /* ADC Init */ hdma_adc . Instance = DMA1_Channel1 ; hdma_adc . Init . Direction = DMA_PERIPH_TO_MEMORY ; hdma_adc . Init . PeriphInc = DMA_PINC_DISABLE ; hdma_adc . Init . MemInc = DMA_MINC_ENABLE ; hdma_adc . Init . PeriphDataAlignment = DMA_PDATAALIGN_HALFWORD ; hdma_adc . Init . MemDataAlignment = DMA_MDATAALIGN_HALFWORD ; hdma_adc . Init . Mode = DMA_CIRCULAR ; hdma_adc . Init . Priority = DMA_PRIORITY_LOW ; if ( HAL_DMA_Init ( & hdma_adc ) != HAL_OK ) { Error_Handler (); } __HAL_LINKDMA ( hadc , DMA_Handle , hdma_adc ); } } After that, add channel want to be read, and start the ADC in DMA mode. Make sure to set the buffer and the length for DMA. int main () { #if defined(ADC_1_CH_CONTINUOUS_MODE) Add_ADC_Channel ( & hadc , ADC_CHANNEL_1 , ADC_SAMPLETIME_239CYCLES_5 ); #endif #if defined(ADC_N_CH_SINGLE_MODE) || defined(ADC_N_CH_CONTINUOUS_MODE) Add_ADC_Channel ( & hadc , ADC_CHANNEL_1 , ADC_SAMPLETIME_239CYCLES_5 ); Add_ADC_Channel ( & hadc , ADC_CHANNEL_2 , ADC_SAMPLETIME_239CYCLES_5 ); #endif #if defined(ADC_1_CH_CONTINUOUS_MODE) HAL_ADC_Start_DMA ( & hadc , ( uint32_t * ) joystick , 1 ); #endif #if defined(ADC_N_CH_CONTINUOUS_MODE) HAL_ADC_Start_DMA ( & hadc , ( uint32_t * ) joystick , 2 ); #endif while ( 1 ) { HAL_Delay ( 20 ); } } That\u2019s all for this tutorial. The Discontinuous and Injected Scan mode will be covered in other guides.","title":"ADC"},{"location":"blog/stm32/adc/#1-analog-to-digital-converter","text":"An Analog-to-Digital Converter (ADC) is able to acquire input voltage level and convert it to a number. The input voltage is compared against a well known and fixed voltage, also known as reference voltage. This reference voltage can be either derived from the V DDA domain or, in MCUs with high pin count, supplied by an external and fixed reference voltage generator V REF+ . The majority of STM32 MCUs provide a 12-bit ADC. Some of them from the STM32F3 portfolio even a 16-bit ADC. In almost all STM32 microcontrollers, the ADC is implemented as a Successive Approximation Register ADC . MCUs usually have more than ten channels, allowing to measure signals from external sources. Moreover, some internal channels are also available: a channel for internal temperature sensor (V SENSE ), one for internal reference voltage (V REFINT ), one for monitoring external V BAT power supply and a channel for monitoring LCD voltage in those MCUs providing a native monochrome passive LCD controller (for example, the STM32L053). ADCs implemented in STM32F3 and in the majority of STM32L4 MCUs are also capable of converting fully differential inputs. A/D conversion of the various channels can be performed in single, continuous, scan, or discontinuous mode. The result of the ADC is stored in a left- or right-aligned 16-bit data register. Moreover, the ADC also implements the analog watchdog feature, which allows the application to detect if the input voltage goes outside the user-defined higher or lower thresholds: if this happens, a dedicated IRQ fires. A simplified structure of an ADC An input selection and scan control unit performs the selection of the input source to the ADC. Depending on the conversion mode (single, scan or continuous mode), this unit automatically switches among the input channels, so that every one can be sampled periodically. The output from this unit feeds the ADC. The start and stop control unit is to control the A/D conversion process, and it can be triggered by software or by a variable number of input sources. Moreover, it is internally connected to the TRGO line of some timers so that time-driven conversions can be automatically performed in DMA mode. The internal structure of a SAR ADC The input signal goes through the Sample-and-Hold (SHA) unit, a feature available in all ADCs, to keep the input signal constant during the conversion cycle. To keep the voltage level of the input constant, the SHA is implemented with a network of capacitors: this ensures that source signal is kept at a certain level during the A/D conversion, which is a procedure that requires a given amount of time, depending on the conversion frequency chosen. The output from the SHA module feeds a comparator that compares it with another signal generated by an internal DAC. The result of comparison is sent to the logic unit, which computes the numerical representation of the input signal according a well-characterized algorithm. This algorithm is what distinguishes SAR ADC from other A/D converters. The Successive Approximation algorithm computes the voltage of the input signal by comparing it with the one generated by the internal DAC, which is a fraction of the V REF voltage: if the input signal is higher than this internal reference voltage, then this is further increased until the input signal is lower . The final result will correspond to a number ranging from zero to the maximum 12-bit unsigned integer. The SAR algorithm essentially performs a search in a binary tree. The great advantage of this algorithm is that the conversion is performed in N-cycles, where N corresponds to the ADC resolution. So a 12-bit ADC requires twelve cycles to perform a conversion.","title":"1. Analog to Digital Converter"},{"location":"blog/stm32/adc/#2-calibration","text":"The ADC has a calibration feature. During the procedure, the ADC calculates a calibration factor which is internally applied to the ADC until the next ADC power-off. The application must not use the ADC during calibration and must wait until it is complete. Calibration should be performed before starting A/D conversion. It removes the offset error which may vary from chip to chip due to process variation. The calibration is initiated by software by setting bit ADCAL=1 . Calibration can only be initiated when the ADC is disabled (when ADEN=0 ). ADCAL bit stays at 1 during all the calibration sequence. It is then cleared by hardware as soon the calibration completes. After this, the calibration factor can be read from the ADC_DR register (from bits 6 to 0).","title":"2. Calibration"},{"location":"blog/stm32/adc/#3-conversion-clock","text":"The ADC clock mainly is derived from the APB clock, however it may have a dual clock-domain architecture on some MCU line: The ADC clock can be a specific clock source, named \u201cADC asynchronous clock\u201d which is independent and asynchronous with the APB clock. It has the advantage of reaching the maximum ADC clock frequency whatever the APB clock scheme selected. The ADC clock can be derived from the APB clock of the ADC bus interface, divided by a programmable factor (2/4/n) and it must not exceed 14 MHz . This has the advantage of bypassing the clock domain re-synchronizations. This can be useful when the ADC is triggered by a timer and if the application requires that the ADC is precisely triggered without any uncertainty.","title":"3. Conversion clock"},{"location":"blog/stm32/adc/#4-conversion-modes","text":"ADCs implemented in STM32 MCUs provide several conversion modes useful to deal with different application scenarios.","title":"4. Conversion Modes"},{"location":"blog/stm32/adc/#41-single-channel-single-conversion-mode","text":"In this mode, the ADC performs the single conversion (single sample) of a single channel, then stops when conversion is finished.","title":"4.1. Single-Channel, Single Conversion Mode"},{"location":"blog/stm32/adc/#42-multiple-channel-single-conversion-mode","text":"It\u2019s also known as Scan Single Conversion Mode. A sequence can have up-to 16 channels, in a custom order. ADC module do not need to stop for CPU to configure the next channel, therefore, it saves CPU load can run in background. DMA is used to store converted data.","title":"4.2. Multiple-channel, Single Conversion Mode"},{"location":"blog/stm32/adc/#43-single-channel-continuous-conversion-mode","text":"This mode converts a single channel continuously and indefinitely in regular channel conversion. The continuous mode feature allows the ADC to work in the background. The ADC converts the channels continuously without any intervention from the CPU. Additionally, the DMA can be used in circular mode, thus reducing the CPU load.","title":"4.3. Single-Channel, Continuous Conversion Mode"},{"location":"blog/stm32/adc/#44-multiple-channel-continuous-conversion-mode","text":"This mode is also called multichannel continuous mode, and it can be used to convert some channels successively with the ADC in independent mode. Scan conversions are carried out in DMA mode. .small-image img { max-width: 50%; } .small-image2 img { max-width: 65%; } 1 Channel, Single Mode N-Channel, Single Mode 1-Channel, Continuous Mode N-Channel, Continuous Mode","title":"4.4. Multiple-channel, Continuous Conversion Mode"},{"location":"blog/stm32/adc/#45-injected-conversion-mode","text":"This mode is intended for use when conversion is triggered by an external event or by software. The injected group has priority over the regular channel group. It interrupts the conversion of the current channel in the regular channel group. Injected conversion mode For example, this mode can be used to synchronize the conversion of channels to an event. It is interested in motor control applications where transistor switching generates noise that impacts ADC measurements and results in wrong conversions. Using a timer, the injected conversion mode can thus be implemented to delay the ADC measurements to after the transistor switching.","title":"4.5. Injected Conversion Mode"},{"location":"blog/stm32/adc/#5-channel-selection","text":"Depending on the STM32 family and package used, ADCs in STM32 MCUs can convert signals from a variable number of channels.","title":"5. Channel Selection"},{"location":"blog/stm32/adc/#51-f0-and-l0-families","text":"In F0 and L0 families the allocation of channel is fixed : the first one is always IN0, the second IN1 and so on. User can decide only if a channel is enabled or not. This means that in scan mode the first sampled channel will be always IN0, the second IN1 and so on. The sampling speed is applied to all channel in F0 and L0 families . To read 1-channel, it is needed to disable the previous configured channel. If more than 1 channel is enabled, ADC will work in N-channel modem, causing reading ADC value always returns the value of the first channel. This will be explained more in the Lab 1 which use an STM32 F0 51R8 MCU.","title":"5.1. F0 and L0 families"},{"location":"blog/stm32/adc/#52-other-fx-and-lx-families","text":"Other STM32 MCUs, instead, offer the notion of group . A group consists of a sequence of conversions that can be done on any channel and in any order. The reordering of channels is performed by assigning to them an index (called rank ) ranging from 1 to 16. Those MCUs offering this possibility also allow to select the sampling speed of each channel individually, differently from F0/L0 MCUs where the configuration is ADC-wide. There exist two groups for each ADC: A regular group, made of up to 16 channels, which corresponds to the sequence of sampled channels during a scan conversion. An injected group, made of up to 4 channels, which corresponds to the sequence of injected channel if an injected conversion is performed. This will be explained more in the Lab 2 which use an STM32 F4 11CE MCU.","title":"5.2. Other Fx and Lx families"},{"location":"blog/stm32/adc/#6-lab-1-joystick-in-polling-mode","text":"The PS2 joystick module shown in the figure down below is basically a couple of potentiometers (variable resistors) that moves in 2 axes. This creates a voltage difference that can be read using any ADC peripheral on two analog pins: VRX and VRY . A simple joystick Requirements Read Joystick analog pins VRX and VRY concurrently Transfer these value in raw number on UART1 A target board Any board which has STM32 MCUs. This tutorial will be using the STM32F0 Discovery board, which features an STM32F051R8 Cortex-M0 MCU. STM32F051R8 Mode External peripheral PA9 Alternate Function UART1 TX PA10 Alternate Function UART1 RX PC8 GPIO Output Blue LED PC9 GPIO Output Green LED PA1 Analog Input 1 VRX PA2 Analog Input 2 VRY","title":"6. Lab 1: Joystick in Polling Mode"},{"location":"blog/stm32/adc/#61-start-a-new-project","text":"Open STM32CubeIDE and create a new STM32 with STM32F051R8 MCU by selecting the target board or just the target MCU. Make sure to configure below settings: Set the HLCK to 48 MHz Set the Debug mode to Debug Serial Wire Enable USART1 with settings: 115200 bps, 8 bits, no Parity, and 1-bit stop Set the PC8 and PC9 pins to GPIO output mode","title":"6.1. Start a new project"},{"location":"blog/stm32/adc/#62-enable-adc-peripheral","text":"In the ADC module under the Analog category, select below settings: Select Input Channel IN1 , and IN2 Clock Pre-scaler: If there is a dedicated HSI ADC clock source, Asynchronous clock can be selected. Otherwise, if the clock source is derived from APB clock, there is synchronous mode available there. Continuous/Discontinuous Conversion Mode are disabled by default, as ADC is not in scan mode DMA Continuous Request is disabled by default End of Conversion flag is selected to be set at End of single conversion Overrun behavior is set to Overrun Data Preserved Sampling time: base on the required conversion speed For example, select 239.5 cycles will result as 239.5 + 12 * 1/14000000 = 18 us (one conversion time), i.e. 55.5 kHz conversion rate. Setup ADC in polling mode","title":"6.2. Enable ADC Peripheral"},{"location":"blog/stm32/adc/#63-generated-code","text":"An ADC instance ADC_HandleTypeDef hadc; is created and the that ADC is initialized in the function MX_ADC_Init() in which the common settings will be applied. After that, it enables all selected channel for a converting sequence. static void MX_ADC_Init_Single_Conversion ( void ) { ADC_ChannelConfTypeDef sConfig = { 0 }; /** Configure the global features of the ADC (Clock, Resolution, Data Alignment and number of conversion) */ hadc . Instance = ADC1 ; hadc . Init . ClockPrescaler = ADC_CLOCK_ASYNC_DIV1 ; hadc . Init . Resolution = ADC_RESOLUTION_12B ; hadc . Init . DataAlign = ADC_DATAALIGN_RIGHT ; hadc . Init . ScanConvMode = ADC_SCAN_DIRECTION_FORWARD ; hadc . Init . EOCSelection = ADC_EOC_SINGLE_CONV ; hadc . Init . LowPowerAutoWait = DISABLE ; hadc . Init . LowPowerAutoPowerOff = DISABLE ; hadc . Init . ContinuousConvMode = DISABLE ; hadc . Init . DiscontinuousConvMode = DISABLE ; hadc . Init . ExternalTrigConv = ADC_SOFTWARE_START ; hadc . Init . ExternalTrigConvEdge = ADC_EXTERNALTRIGCONVEDGE_NONE ; hadc . Init . DMAContinuousRequests = DISABLE ; hadc . Init . Overrun = ADC_OVR_DATA_PRESERVED ; if ( HAL_ADC_Init ( & hadc ) != HAL_OK ) { Error_Handler (); } }","title":"6.3. Generated code"},{"location":"blog/stm32/adc/#64-single-channel-single-conversion","text":"To read an ADC channel, it is needed to configure one and only target channel. If there is more than one channel, ADC module will act as scan mode, and if the target channel has its number less than the first enabled channel, it will not be read. Here is the sequence to read a channel Clear all channel registered in Channel Selection CHSELR register by assigning it to 0. Enable the target channel by calling to HAL_ADC_ConfigChannel() with a config having: Channel Number, ADC_RANK_CHANNEL_NUMBER rank, and Sample Time Call to HAL_ADC_Start() Call to HAL_ADC_PollForConversion() Read the returned value with HAL_ADC_GetValue() Clear all channel registered in Channel Selection CHSELR register by assigning it to 0. void Add_ADC_Channel ( ADC_HandleTypeDef * hadc , uint32_t channel , uint32_t sampling_time ) { ADC_ChannelConfTypeDef sConfig = { 0 }; /** Configure for the selected ADC regular channel to be converted. */ sConfig . Channel = channel ; sConfig . Rank = ADC_RANK_CHANNEL_NUMBER ; sConfig . SamplingTime = sampling_time ; if ( HAL_ADC_ConfigChannel ( hadc , & sConfig ) != HAL_OK ) { Error_Handler (); } } uint32_t Read_ADC_Channel ( ADC_HandleTypeDef * hadc , uint32_t channel , uint32_t sampling_time ) { uint32_t adc_value = 0 ; // clear all channel hadc -> Instance -> CHSELR = 0 ; Add_ADC_Channel ( hadc , channel , sampling_time ); // read HAL_ADC_Start ( hadc ); HAL_ADC_PollForConversion ( hadc , HAL_MAX_DELAY ); adc_value = HAL_ADC_GetValue ( hadc ); HAL_ADC_Stop ( hadc ); // clear all channel hadc -> Instance -> CHSELR = 0 ; // return return adc_value ; } Read Joystick\u2019s position As the ADC value is an 12-bit register, Joystick has 2 channels, an array will be used to store the Joystick\u2019s position. A buffer also is used to hold the message which will be sent on UART1. uint16_t joystick [ 2 ] = { 0 }; char buffer [ 12 ] = { 0 }; // xxxx,yyyy\\r\\n It is recommended to do ADC Calibration before activating the ADC conversion. Then in the main while loop, call to Read_ADC() on ADC_CHANNEL_1 and ADC_CHANNEL_2 . The 20 ms delay will help to reduce the conversion rate to about 50 Hz. int main ( void ) { #if defined(ADC_1_CH_SINGLE_MODE) MX_ADC_Init_Single_Conversion (); HAL_ADCEx_Calibration_Start ( & hadc ); #endif while ( 1 ) { #ifdef ADC_1_CH_SINGLE_MODE HAL_GPIO_TogglePin ( LED_GPIO_Port , LED_Pin ); joystick [ JS_X ] = Read_ADC_Channel ( & hadc , ADC_CHANNEL_1 , ADC_SAMPLETIME_239CYCLES_5 ); joystick [ JS_Y ] = Read_ADC_Channel ( & hadc , ADC_CHANNEL_2 , ADC_SAMPLETIME_239CYCLES_5 ); #endif HAL_UART_Transmit ( & huart1 , ( uint8_t * ) buffer , strlen ( buffer ), HAL_MAX_DELAY ); HAL_Delay ( 20 ); } } Run the application and connect to the UART1 terminal, value of VRX and VRY will be printed out, like below: Joystick\u2019s position is printed in raw string To visualize the data, use Arduino Serial Plotter feature or Serial Plot program. Joystick\u2019s value in a timeline graph Joystick\u2019s value in a timeline graph","title":"6.4. Single-Channel, Single Conversion"},{"location":"blog/stm32/adc/#65-multiple-channel-single-conversion","text":"In the Single Conversion mode, if multiple channels are registered, ADC module will automatically run int Multiple-Channel scan mode. F0/L0 families use the channel numbers as the scan order in Multiple-Channel mode In the Multiple-Channel mode , ADC module starts with the first activated channel which has the smallest channel number when the function HAL_ADC_Start() is called. For each subsequence call of HAL_ADC_PollForConversion() , ADC module read the channel then move to the next channel, and wait for next polling call. int main ( void ) { #if defined(ADC_1_CH_SINGLE_MODE) || defined(ADC_N_CH_SINGLE_MODE) MX_ADC_Init_Single_Conversion (); HAL_ADCEx_Calibration_Start ( & hadc ); #endif while ( 1 ) { #ifdef ADC_N_CH_SINGLE_MODE HAL_GPIO_TogglePin ( LED_GPIO_Port , LED_Pin ); HAL_ADC_Start ( & hadc ); HAL_ADC_PollForConversion ( & hadc , HAL_MAX_DELAY ); joystick [ JS_X ] = HAL_ADC_GetValue ( & hadc ); HAL_ADC_PollForConversion ( & hadc , HAL_MAX_DELAY ); joystick [ JS_Y ] = HAL_ADC_GetValue ( & hadc ); HAL_ADC_Stop ( & hadc ); #endif HAL_UART_Transmit ( & huart1 , ( uint8_t * ) buffer , strlen ( buffer ), HAL_MAX_DELAY ); HAL_Delay ( 20 ); } }","title":"6.5. Multiple-Channel, Single Conversion"},{"location":"blog/stm32/adc/#66-continuous-conversion","text":"ADC module will not stop in this mode. When it finishes converting the last channel, it goes back to the first channel and then do conversion again. The modified points are: Continuous Conversion Mode is enabled DMA Continuous Request is enabled End of Conversion flag is selected to be set at End of sequence of conversion DMA Settings is set to Circular mode, Data increment for Memory with Half-Word width Setup ADC in continuous mode with DMA void MX_ADC_Init_Continuous_Conversion ( void ) { hadc . Instance = ADC1 ; hadc . Init . ClockPrescaler = ADC_CLOCK_ASYNC_DIV1 ; hadc . Init . Resolution = ADC_RESOLUTION_12B ; hadc . Init . DataAlign = ADC_DATAALIGN_RIGHT ; hadc . Init . ScanConvMode = ADC_SCAN_DIRECTION_FORWARD ; hadc . Init . EOCSelection = ADC_EOC_SEQ_CONV ; hadc . Init . LowPowerAutoWait = DISABLE ; hadc . Init . LowPowerAutoPowerOff = DISABLE ; hadc . Init . ContinuousConvMode = ENABLE ; hadc . Init . DiscontinuousConvMode = DISABLE ; hadc . Init . ExternalTrigConv = ADC_SOFTWARE_START ; hadc . Init . ExternalTrigConvEdge = ADC_EXTERNALTRIGCONVEDGE_NONE ; hadc . Init . DMAContinuousRequests = ENABLE ; hadc . Init . Overrun = ADC_OVR_DATA_PRESERVED ; if ( HAL_ADC_Init ( & hadc ) != HAL_OK ) { Error_Handler (); } } Then DMA module is linked to the ADC module in the function HAL_ADC_MspInit() : void HAL_ADC_MspInit ( ADC_HandleTypeDef * hadc ) { GPIO_InitTypeDef GPIO_InitStruct = { 0 }; if ( hadc -> Instance == ADC1 ) { __HAL_RCC_ADC1_CLK_ENABLE (); __HAL_RCC_GPIOA_CLK_ENABLE (); /**ADC GPIO Configuration PA1 ------> ADC_IN1 PA2 ------> ADC_IN2 */ GPIO_InitStruct . Pin = GPIO_PIN_1 | GPIO_PIN_2 ; GPIO_InitStruct . Mode = GPIO_MODE_ANALOG ; GPIO_InitStruct . Pull = GPIO_NOPULL ; HAL_GPIO_Init ( GPIOA , & GPIO_InitStruct ); /* ADC1 DMA Init */ /* ADC Init */ hdma_adc . Instance = DMA1_Channel1 ; hdma_adc . Init . Direction = DMA_PERIPH_TO_MEMORY ; hdma_adc . Init . PeriphInc = DMA_PINC_DISABLE ; hdma_adc . Init . MemInc = DMA_MINC_ENABLE ; hdma_adc . Init . PeriphDataAlignment = DMA_PDATAALIGN_HALFWORD ; hdma_adc . Init . MemDataAlignment = DMA_MDATAALIGN_HALFWORD ; hdma_adc . Init . Mode = DMA_CIRCULAR ; hdma_adc . Init . Priority = DMA_PRIORITY_LOW ; if ( HAL_DMA_Init ( & hdma_adc ) != HAL_OK ) { Error_Handler (); } __HAL_LINKDMA ( hadc , DMA_Handle , hdma_adc ); } } After that, add channel want to be read, and start the ADC in DMA mode. Make sure to set the buffer and the length for DMA. int main () { #if defined(ADC_1_CH_CONTINUOUS_MODE) Add_ADC_Channel ( & hadc , ADC_CHANNEL_1 , ADC_SAMPLETIME_239CYCLES_5 ); #endif #if defined(ADC_N_CH_SINGLE_MODE) || defined(ADC_N_CH_CONTINUOUS_MODE) Add_ADC_Channel ( & hadc , ADC_CHANNEL_1 , ADC_SAMPLETIME_239CYCLES_5 ); Add_ADC_Channel ( & hadc , ADC_CHANNEL_2 , ADC_SAMPLETIME_239CYCLES_5 ); #endif #if defined(ADC_1_CH_CONTINUOUS_MODE) HAL_ADC_Start_DMA ( & hadc , ( uint32_t * ) joystick , 1 ); #endif #if defined(ADC_N_CH_CONTINUOUS_MODE) HAL_ADC_Start_DMA ( & hadc , ( uint32_t * ) joystick , 2 ); #endif while ( 1 ) { HAL_Delay ( 20 ); } } That\u2019s all for this tutorial. The Discontinuous and Injected Scan mode will be covered in other guides.","title":"6.6. Continuous Conversion"},{"location":"blog/stm32/add-swo/","text":"Any original ST\u2019s board has an integrated ST-LINK/V2 debugger which supports SWO to trace ITM outputs on Cortex-M3+. That debugger can be used to program and debug an external MCU on other board, or turn into an J-Link debugger. Many ST-LINK clones do not have SWO pin exposed. When open the clone board, the STM32F103 chip is found, which is the same as the chip used in the original ST-LINK. So, the problem of missing SWO can be solved by exposing the SWO pin. 1. ST-LINK/V2 Schematic \u2693\ufe0e The original boards from ST always come with a schematic. Under the tab CAD Resources of the page for the Nucleo-F103 board on ST\u2019s site, the schematic is nucleo_64pins_sch.zip . In the schematic, it is clear that T_SWO line is connected to the pin PA10 (#31) on the STM32F103 chip. Original ST-LINK/V2 with the SWO pin 2. Clone schematic \u2693\ufe0e There is no way to see a schematic of a clone device. Clone hardware modules are marked with MX-LINK label. However, as the schematic for ST-LINK/V2 is public in the board document, it\u2019s expected that the clone uses the exactly same hardware with the original one. The firmware download works well on the clone, so it\u2019s mainly sure that the hardware is identical. People also have found that some cloned devices use STM32F101 instead of STM32F103 , and the pinout maybe LQFP64, not LQFP48. However, thanks to the pin compatibility of STM32, PA10 will still have the same function on variant chips. 3. Wire SWO Pin \u2693\ufe0e One thing apparently clear at the moment is the PA10 (#31) pin can be exposed to the header. Just cut a 5V pin, and wire the PA10 pin through a small resister (22R or 100R). Write the PA10 pin to the header on a LQFP64 STM32F101 That\u2019s it. Hardware modding is very simple. Next is to test with SWV mode in a debugging session. Check the steps in Debug with SWV mode . Capture of working ST-LINK/V2 SWV with SWV Viewer or CubeMonitor:","title":"Add SWO"},{"location":"blog/stm32/add-swo/#1-st-linkv2-schematic","text":"The original boards from ST always come with a schematic. Under the tab CAD Resources of the page for the Nucleo-F103 board on ST\u2019s site, the schematic is nucleo_64pins_sch.zip . In the schematic, it is clear that T_SWO line is connected to the pin PA10 (#31) on the STM32F103 chip. Original ST-LINK/V2 with the SWO pin","title":"1. ST-LINK/V2 Schematic"},{"location":"blog/stm32/add-swo/#2-clone-schematic","text":"There is no way to see a schematic of a clone device. Clone hardware modules are marked with MX-LINK label. However, as the schematic for ST-LINK/V2 is public in the board document, it\u2019s expected that the clone uses the exactly same hardware with the original one. The firmware download works well on the clone, so it\u2019s mainly sure that the hardware is identical. People also have found that some cloned devices use STM32F101 instead of STM32F103 , and the pinout maybe LQFP64, not LQFP48. However, thanks to the pin compatibility of STM32, PA10 will still have the same function on variant chips.","title":"2. Clone schematic"},{"location":"blog/stm32/add-swo/#3-wire-swo-pin","text":"One thing apparently clear at the moment is the PA10 (#31) pin can be exposed to the header. Just cut a 5V pin, and wire the PA10 pin through a small resister (22R or 100R). Write the PA10 pin to the header on a LQFP64 STM32F101 That\u2019s it. Hardware modding is very simple. Next is to test with SWV mode in a debugging session. Check the steps in Debug with SWV mode . Capture of working ST-LINK/V2 SWV with SWV Viewer or CubeMonitor:","title":"3. Wire SWO Pin"},{"location":"blog/stm32/clock/","text":"1. Clock source \u2693\ufe0e A clock is a device that usually generates a periodical square wave signal, with a 50% duty cycle . A clock signal oscillates between V L and V H voltage levels, which for STM32 microcontrollers are a fraction of the V DD supply voltage. The most fundamental parameter of a clock is the frequency, which indicates how many times it switches from V L to V H in a second. The frequency is expressed in Hertz . A typical clock signal The majority of STM32 MCUs can be clocked by two distinct clock sources alternatively: an internal RC oscillator High Speed Internal (HSI) ; or an external dedicated crystal oscillator High Speed External (HSE) There are several reasons to prefer an external crystal to the internal RC oscillator: An external crystal offers a higher precision compared to the internal RC network, which is rated of a 1% accuracy, especially when PCB operative temperatures are far from the ambient temperature of 25 \u00b0C Some peripherals, especially high speed ones, can be clocked only by a dedicated external crystal running at a given frequency Together with the high-speed oscillator, another clock source can be used to bias the low-speed oscillator, which in turn can be clocked by: an external crystal Low Speed External (LSE) ; or the internal dedicated RC oscillator Low Speed Internal (LSI) The low-speed oscillator is used to drive the Real Time Clock (RTC) and the Independent Watchdog (IWDT) peripheral. Using several Programmable Phase-Locked Loops (PLL) and pre-scalers, it is possible to increase/decrease the source frequency at needs, depending on the requested performances, the maximum speed for a given peripheral or bus and the overall global power consumption. PLL is used to increased/ decrease clock frequency 2. Clock tree \u2693\ufe0e The clock tree configuration is performed through a dedicated peripheral named Reset and Clock Control (RCC) , and it is a process essentially composed by three steps: The high-speed oscillator source is selected (HSI or HSE) and properly configured, if the HSE is used. If you need to feed the SYSCLK with a frequency higher than the one provided by the high-speed oscillator, then configure the main PLL (which provides the PLLCLK signal). The System Clock Switch (SW) is configured to choose the system clock source from HSI, HSE, or PLLCLK . Then select the AHB, APB1 and APB2 (if available) pre-scaler settings to reach the wanted frequency of the High-speed clock ( HCLK \u2014 that is the one that feeds the core, DMAs and AHB bus), and the frequencies of Advanced Peripheral Bus 1 (APB1) and APB2 (if available) buses. 3. Master Clock Output \u2693\ufe0e The RCC peripheral also allows to enable the Master Clock Output (MCO) , which is a pin that can be connected to a clock source. It can be used to clock another external device, allowing to save on the external crystal for this other IC. Once the MCO is enabled, it is possible to choose its clock source using the Clock Configuration view. 4. Clock Security System \u2693\ufe0e The Clock Security System (CSS) is a feature of the RCC peripheral used to detect malfunctions of the external HSE. The CSS is an important feature in some critical applications, and the detection of a failure is noticed through the NMI exception \u2014 a Cortex-M exception that cannot be disabled. When the failure of HSE is detected, the MCU automatically switch to the HSI clock, which is selected as source for the SYSCLK clock. So, if a higher core frequency is needed, it needs to perform proper initialization inside the NMI exception handler. Example of a clock tree 5. Configure Clocks \u2693\ufe0e After a reset : The device is running from the Internal High Speed oscillator (HSI 8 MHz) with Flash 0 wait state, Flash prefetch buffer is enabled, and all peripherals are off except internal SRAM, Flash and JTAG. There is no pre-scaler on High speed (AHB) and Low speed (APB) buses; all peripherals mapped on these buses are running at HSI speed. The clock for all peripherals is switched off, except the SRAM and FLASH. All GPIOs are in input floating state, except the JTAG pins which are assigned to be used for debug purpose. Once start up, the user application has to : Configure the clock source to be used to drive the System clock (if the application needs higher frequency/ performance) Configure the System clock frequency and Flash settings Configure the AHB and APB buses pre-scalers Enable the clock for the peripheral(s) to be used Configure the clock source(s) for peripherals whose clocks are not derived from the System clock (RTC, ADC, I2C, USART, TIM, USB FS, etc.) 6. STM32CubeMX Usage \u2693\ufe0e Here are two examples of setting up the clock on 2 boards \u2014 one with only internal oscillator, one with external crystals. Note that when changing the clock speed, there are some limitation of the frequency of the target buses, e.g. HCLK , PCK1 , PCK2 . For both HSE and LSE external crystals, STM32CubeMX offers three configuration options: Disable : the external oscillator is not available/used, and the corresponding internal oscillator is used. Crystal/Ceramic Resonator : an external crystal/ceramic resonator is used, and the corresponding main frequency is derived from it. This implies that RCC_OSC_IN and RCC_OSC_OUT pins are used to interface the HSE, and the corresponding signal I/Os are unavailable for other usages (if you use an external low-speed crystal, then the corresponding RCC_OSC32_IN and RCC_OSC32_OUT I/Os are used too). BYPASS Clock Source : an external clock source is used. The clock source is generated by another active device. This means that the RCC_OSC_OUT is leaved unused, and it is possible to use it as regular GPIO. User can fill in a number in a frequency node, and press Enter to let IDE automatically calculate the multiplier\u2019s and divider\u2019s value. 6.1. Internal RC oscillators \u2693\ufe0e This is an example guide on an official STM32F0 Discovery board , which only has internal RC oscillators: Select PLL Source Multiplexer is HSI Set PLL Multiplier and Divider to get PLLCLK Select System Clock Multiplexer is PLLCLK to get SYSCLK Set divider for AHB Bus HCLK and APB1 Bus PCLK1 Setup clock with HSI on STM32F051R8 6.2. External crystals \u2693\ufe0e This is an example guide on a custom black pill STM32F411CE board , which has external crystals: Enable HSE and LSE : In the RCC peripheral under the System Core modules, choose option Crystal/Ceramic Resonator . This will automatically setups 2 pins for HSE, and 2 pins for LSE. Enable HSE and LSE Select PLL Source Multiplexer is HSE Set PLL Multiplier and Divider to get PLLCLK Select System Clock Multiplexer is PLLCLK to get SYSCLK Set divider for AHB Bus HCLK , APB1 Bus PCLK1 , APB2 Bus PCLK2 Setup clock with HSE on STM32F411CE 7. STM32 CubeHAL Usage \u2693\ufe0e CubeMX is designed to generate the right code initialization for the clock tree of MCU. All the necessary code is packed inside the SystemClock_Config() routine in the file main.c : The most relevant C struct to configure the clock tree are RCC_OscInitTypeDef and RCC_ClkInitTypeDef . Use HAL_RCC_OscConfig() function to set up the Oscillator source, and then use HAL_RCC_ClockConfig() function to set up the System clock (CPU) and Bus clocks (AHB, APB). To configure the Master Clock Output, use the function HAL_RCC_MCOConfig() to select the clock source and its dividing factor. Note that when configuring the MCO pin as output GPIO, its speed (that is, the slew rate) affects the quality of the output clock. Example 1 \u2014 Setting clock on F051R8, with 8 MHz HSI, to make 48 MHz SYSCLK, and drive MCO at 48 MHz using SYSCLK: void SystemClock_Config ( void ) { RCC_OscInitTypeDef RCC_OscInitStruct = { 0 }; RCC_ClkInitTypeDef RCC_ClkInitStruct = { 0 }; /** Initializes the RCC Oscillators according to the specified parameters in the RCC_OscInitTypeDef structure.*/ RCC_OscInitStruct . OscillatorType = RCC_OSCILLATORTYPE_HSI ; RCC_OscInitStruct . HSIState = RCC_HSI_ON ; RCC_OscInitStruct . HSICalibrationValue = RCC_HSICALIBRATION_DEFAULT ; RCC_OscInitStruct . PLL . PLLState = RCC_PLL_ON ; RCC_OscInitStruct . PLL . PLLSource = RCC_PLLSOURCE_HSI ; RCC_OscInitStruct . PLL . PLLMUL = RCC_PLL_MUL12 ; RCC_OscInitStruct . PLL . PREDIV = RCC_PREDIV_DIV1 ; if ( HAL_RCC_OscConfig ( & RCC_OscInitStruct ) != HAL_OK ) { Error_Handler (); } /** Initializes the CPU, AHB and APB buses clocks */ RCC_ClkInitStruct . ClockType = RCC_CLOCKTYPE_HCLK | RCC_CLOCKTYPE_SYSCLK | RCC_CLOCKTYPE_PCLK1 ; RCC_ClkInitStruct . SYSCLKSource = RCC_SYSCLKSOURCE_PLLCLK ; RCC_ClkInitStruct . AHBCLKDivider = RCC_SYSCLK_DIV1 ; RCC_ClkInitStruct . APB1CLKDivider = RCC_HCLK_DIV1 ; if ( HAL_RCC_ClockConfig ( & RCC_ClkInitStruct , FLASH_LATENCY_1 ) != HAL_OK ) { Error_Handler (); } HAL_RCC_MCOConfig ( RCC_MCO , RCC_MCO1SOURCE_SYSCLK , RCC_MCODIV_1 ); } Example 2 \u2014 Setting clock on F411CE, with 25 MHz HSE and 32.765KHz LSE, to make 100 MHz SYSCLK, 50 MHz APB1 Bus, 100 MHz APB2, with CSS Enabled: void SystemClock_Config ( void ) { RCC_OscInitTypeDef RCC_OscInitStruct = { 0 }; RCC_ClkInitTypeDef RCC_ClkInitStruct = { 0 }; /** Configure the main internal regulator output voltage */ __HAL_RCC_PWR_CLK_ENABLE (); __HAL_PWR_VOLTAGESCALING_CONFIG ( PWR_REGULATOR_VOLTAGE_SCALE1 ); /** Initializes the RCC Oscillators according to the specified parameters * in the RCC_OscInitTypeDef structure. */ RCC_OscInitStruct . OscillatorType = RCC_OSCILLATORTYPE_HSE ; RCC_OscInitStruct . HSEState = RCC_HSE_ON ; RCC_OscInitStruct . PLL . PLLState = RCC_PLL_ON ; RCC_OscInitStruct . PLL . PLLSource = RCC_PLLSOURCE_HSE ; RCC_OscInitStruct . PLL . PLLM = 12 ; RCC_OscInitStruct . PLL . PLLN = 96 ; RCC_OscInitStruct . PLL . PLLP = RCC_PLLP_DIV2 ; RCC_OscInitStruct . PLL . PLLQ = 4 ; if ( HAL_RCC_OscConfig ( & RCC_OscInitStruct ) != HAL_OK ) { Error_Handler (); } /** Initializes the CPU, AHB and APB buses clocks */ RCC_ClkInitStruct . ClockType = RCC_CLOCKTYPE_HCLK | RCC_CLOCKTYPE_SYSCLK | RCC_CLOCKTYPE_PCLK1 | RCC_CLOCKTYPE_PCLK2 ; RCC_ClkInitStruct . SYSCLKSource = RCC_SYSCLKSOURCE_PLLCLK ; RCC_ClkInitStruct . AHBCLKDivider = RCC_SYSCLK_DIV1 ; RCC_ClkInitStruct . APB1CLKDivider = RCC_HCLK_DIV2 ; RCC_ClkInitStruct . APB2CLKDivider = RCC_HCLK_DIV1 ; if ( HAL_RCC_ClockConfig ( & RCC_ClkInitStruct , FLASH_LATENCY_3 ) != HAL_OK ) { Error_Handler (); } /** Enables the Clock Security System */ HAL_RCC_EnableCSS (); } Note that when CSS is enabled, HAL_RCC_NMI_IRQHandler() is added into the NMI_Handler() ISR. User should override the HAL_RCC_CSSCallback() function to re-configure the system clocks as the same way as it only has the internal RC oscillators.","title":"Clock Tree"},{"location":"blog/stm32/clock/#1-clock-source","text":"A clock is a device that usually generates a periodical square wave signal, with a 50% duty cycle . A clock signal oscillates between V L and V H voltage levels, which for STM32 microcontrollers are a fraction of the V DD supply voltage. The most fundamental parameter of a clock is the frequency, which indicates how many times it switches from V L to V H in a second. The frequency is expressed in Hertz . A typical clock signal The majority of STM32 MCUs can be clocked by two distinct clock sources alternatively: an internal RC oscillator High Speed Internal (HSI) ; or an external dedicated crystal oscillator High Speed External (HSE) There are several reasons to prefer an external crystal to the internal RC oscillator: An external crystal offers a higher precision compared to the internal RC network, which is rated of a 1% accuracy, especially when PCB operative temperatures are far from the ambient temperature of 25 \u00b0C Some peripherals, especially high speed ones, can be clocked only by a dedicated external crystal running at a given frequency Together with the high-speed oscillator, another clock source can be used to bias the low-speed oscillator, which in turn can be clocked by: an external crystal Low Speed External (LSE) ; or the internal dedicated RC oscillator Low Speed Internal (LSI) The low-speed oscillator is used to drive the Real Time Clock (RTC) and the Independent Watchdog (IWDT) peripheral. Using several Programmable Phase-Locked Loops (PLL) and pre-scalers, it is possible to increase/decrease the source frequency at needs, depending on the requested performances, the maximum speed for a given peripheral or bus and the overall global power consumption. PLL is used to increased/ decrease clock frequency","title":"1. Clock source"},{"location":"blog/stm32/clock/#2-clock-tree","text":"The clock tree configuration is performed through a dedicated peripheral named Reset and Clock Control (RCC) , and it is a process essentially composed by three steps: The high-speed oscillator source is selected (HSI or HSE) and properly configured, if the HSE is used. If you need to feed the SYSCLK with a frequency higher than the one provided by the high-speed oscillator, then configure the main PLL (which provides the PLLCLK signal). The System Clock Switch (SW) is configured to choose the system clock source from HSI, HSE, or PLLCLK . Then select the AHB, APB1 and APB2 (if available) pre-scaler settings to reach the wanted frequency of the High-speed clock ( HCLK \u2014 that is the one that feeds the core, DMAs and AHB bus), and the frequencies of Advanced Peripheral Bus 1 (APB1) and APB2 (if available) buses.","title":"2. Clock tree"},{"location":"blog/stm32/clock/#3-master-clock-output","text":"The RCC peripheral also allows to enable the Master Clock Output (MCO) , which is a pin that can be connected to a clock source. It can be used to clock another external device, allowing to save on the external crystal for this other IC. Once the MCO is enabled, it is possible to choose its clock source using the Clock Configuration view.","title":"3. Master Clock Output"},{"location":"blog/stm32/clock/#4-clock-security-system","text":"The Clock Security System (CSS) is a feature of the RCC peripheral used to detect malfunctions of the external HSE. The CSS is an important feature in some critical applications, and the detection of a failure is noticed through the NMI exception \u2014 a Cortex-M exception that cannot be disabled. When the failure of HSE is detected, the MCU automatically switch to the HSI clock, which is selected as source for the SYSCLK clock. So, if a higher core frequency is needed, it needs to perform proper initialization inside the NMI exception handler. Example of a clock tree","title":"4. Clock Security System"},{"location":"blog/stm32/clock/#5-configure-clocks","text":"After a reset : The device is running from the Internal High Speed oscillator (HSI 8 MHz) with Flash 0 wait state, Flash prefetch buffer is enabled, and all peripherals are off except internal SRAM, Flash and JTAG. There is no pre-scaler on High speed (AHB) and Low speed (APB) buses; all peripherals mapped on these buses are running at HSI speed. The clock for all peripherals is switched off, except the SRAM and FLASH. All GPIOs are in input floating state, except the JTAG pins which are assigned to be used for debug purpose. Once start up, the user application has to : Configure the clock source to be used to drive the System clock (if the application needs higher frequency/ performance) Configure the System clock frequency and Flash settings Configure the AHB and APB buses pre-scalers Enable the clock for the peripheral(s) to be used Configure the clock source(s) for peripherals whose clocks are not derived from the System clock (RTC, ADC, I2C, USART, TIM, USB FS, etc.)","title":"5. Configure Clocks"},{"location":"blog/stm32/clock/#6-stm32cubemx-usage","text":"Here are two examples of setting up the clock on 2 boards \u2014 one with only internal oscillator, one with external crystals. Note that when changing the clock speed, there are some limitation of the frequency of the target buses, e.g. HCLK , PCK1 , PCK2 . For both HSE and LSE external crystals, STM32CubeMX offers three configuration options: Disable : the external oscillator is not available/used, and the corresponding internal oscillator is used. Crystal/Ceramic Resonator : an external crystal/ceramic resonator is used, and the corresponding main frequency is derived from it. This implies that RCC_OSC_IN and RCC_OSC_OUT pins are used to interface the HSE, and the corresponding signal I/Os are unavailable for other usages (if you use an external low-speed crystal, then the corresponding RCC_OSC32_IN and RCC_OSC32_OUT I/Os are used too). BYPASS Clock Source : an external clock source is used. The clock source is generated by another active device. This means that the RCC_OSC_OUT is leaved unused, and it is possible to use it as regular GPIO. User can fill in a number in a frequency node, and press Enter to let IDE automatically calculate the multiplier\u2019s and divider\u2019s value.","title":"6. STM32CubeMX Usage"},{"location":"blog/stm32/clock/#61-internal-rc-oscillators","text":"This is an example guide on an official STM32F0 Discovery board , which only has internal RC oscillators: Select PLL Source Multiplexer is HSI Set PLL Multiplier and Divider to get PLLCLK Select System Clock Multiplexer is PLLCLK to get SYSCLK Set divider for AHB Bus HCLK and APB1 Bus PCLK1 Setup clock with HSI on STM32F051R8","title":"6.1. Internal RC oscillators"},{"location":"blog/stm32/clock/#62-external-crystals","text":"This is an example guide on a custom black pill STM32F411CE board , which has external crystals: Enable HSE and LSE : In the RCC peripheral under the System Core modules, choose option Crystal/Ceramic Resonator . This will automatically setups 2 pins for HSE, and 2 pins for LSE. Enable HSE and LSE Select PLL Source Multiplexer is HSE Set PLL Multiplier and Divider to get PLLCLK Select System Clock Multiplexer is PLLCLK to get SYSCLK Set divider for AHB Bus HCLK , APB1 Bus PCLK1 , APB2 Bus PCLK2 Setup clock with HSE on STM32F411CE","title":"6.2. External crystals"},{"location":"blog/stm32/clock/#7-stm32-cubehal-usage","text":"CubeMX is designed to generate the right code initialization for the clock tree of MCU. All the necessary code is packed inside the SystemClock_Config() routine in the file main.c : The most relevant C struct to configure the clock tree are RCC_OscInitTypeDef and RCC_ClkInitTypeDef . Use HAL_RCC_OscConfig() function to set up the Oscillator source, and then use HAL_RCC_ClockConfig() function to set up the System clock (CPU) and Bus clocks (AHB, APB). To configure the Master Clock Output, use the function HAL_RCC_MCOConfig() to select the clock source and its dividing factor. Note that when configuring the MCO pin as output GPIO, its speed (that is, the slew rate) affects the quality of the output clock. Example 1 \u2014 Setting clock on F051R8, with 8 MHz HSI, to make 48 MHz SYSCLK, and drive MCO at 48 MHz using SYSCLK: void SystemClock_Config ( void ) { RCC_OscInitTypeDef RCC_OscInitStruct = { 0 }; RCC_ClkInitTypeDef RCC_ClkInitStruct = { 0 }; /** Initializes the RCC Oscillators according to the specified parameters in the RCC_OscInitTypeDef structure.*/ RCC_OscInitStruct . OscillatorType = RCC_OSCILLATORTYPE_HSI ; RCC_OscInitStruct . HSIState = RCC_HSI_ON ; RCC_OscInitStruct . HSICalibrationValue = RCC_HSICALIBRATION_DEFAULT ; RCC_OscInitStruct . PLL . PLLState = RCC_PLL_ON ; RCC_OscInitStruct . PLL . PLLSource = RCC_PLLSOURCE_HSI ; RCC_OscInitStruct . PLL . PLLMUL = RCC_PLL_MUL12 ; RCC_OscInitStruct . PLL . PREDIV = RCC_PREDIV_DIV1 ; if ( HAL_RCC_OscConfig ( & RCC_OscInitStruct ) != HAL_OK ) { Error_Handler (); } /** Initializes the CPU, AHB and APB buses clocks */ RCC_ClkInitStruct . ClockType = RCC_CLOCKTYPE_HCLK | RCC_CLOCKTYPE_SYSCLK | RCC_CLOCKTYPE_PCLK1 ; RCC_ClkInitStruct . SYSCLKSource = RCC_SYSCLKSOURCE_PLLCLK ; RCC_ClkInitStruct . AHBCLKDivider = RCC_SYSCLK_DIV1 ; RCC_ClkInitStruct . APB1CLKDivider = RCC_HCLK_DIV1 ; if ( HAL_RCC_ClockConfig ( & RCC_ClkInitStruct , FLASH_LATENCY_1 ) != HAL_OK ) { Error_Handler (); } HAL_RCC_MCOConfig ( RCC_MCO , RCC_MCO1SOURCE_SYSCLK , RCC_MCODIV_1 ); } Example 2 \u2014 Setting clock on F411CE, with 25 MHz HSE and 32.765KHz LSE, to make 100 MHz SYSCLK, 50 MHz APB1 Bus, 100 MHz APB2, with CSS Enabled: void SystemClock_Config ( void ) { RCC_OscInitTypeDef RCC_OscInitStruct = { 0 }; RCC_ClkInitTypeDef RCC_ClkInitStruct = { 0 }; /** Configure the main internal regulator output voltage */ __HAL_RCC_PWR_CLK_ENABLE (); __HAL_PWR_VOLTAGESCALING_CONFIG ( PWR_REGULATOR_VOLTAGE_SCALE1 ); /** Initializes the RCC Oscillators according to the specified parameters * in the RCC_OscInitTypeDef structure. */ RCC_OscInitStruct . OscillatorType = RCC_OSCILLATORTYPE_HSE ; RCC_OscInitStruct . HSEState = RCC_HSE_ON ; RCC_OscInitStruct . PLL . PLLState = RCC_PLL_ON ; RCC_OscInitStruct . PLL . PLLSource = RCC_PLLSOURCE_HSE ; RCC_OscInitStruct . PLL . PLLM = 12 ; RCC_OscInitStruct . PLL . PLLN = 96 ; RCC_OscInitStruct . PLL . PLLP = RCC_PLLP_DIV2 ; RCC_OscInitStruct . PLL . PLLQ = 4 ; if ( HAL_RCC_OscConfig ( & RCC_OscInitStruct ) != HAL_OK ) { Error_Handler (); } /** Initializes the CPU, AHB and APB buses clocks */ RCC_ClkInitStruct . ClockType = RCC_CLOCKTYPE_HCLK | RCC_CLOCKTYPE_SYSCLK | RCC_CLOCKTYPE_PCLK1 | RCC_CLOCKTYPE_PCLK2 ; RCC_ClkInitStruct . SYSCLKSource = RCC_SYSCLKSOURCE_PLLCLK ; RCC_ClkInitStruct . AHBCLKDivider = RCC_SYSCLK_DIV1 ; RCC_ClkInitStruct . APB1CLKDivider = RCC_HCLK_DIV2 ; RCC_ClkInitStruct . APB2CLKDivider = RCC_HCLK_DIV1 ; if ( HAL_RCC_ClockConfig ( & RCC_ClkInitStruct , FLASH_LATENCY_3 ) != HAL_OK ) { Error_Handler (); } /** Enables the Clock Security System */ HAL_RCC_EnableCSS (); } Note that when CSS is enabled, HAL_RCC_NMI_IRQHandler() is added into the NMI_Handler() ISR. User should override the HAL_RCC_CSSCallback() function to re-configure the system clocks as the same way as it only has the internal RC oscillators.","title":"7. STM32 CubeHAL Usage"},{"location":"blog/stm32/dma/","text":"DMA Mem2Mem vs memcpy 1. DMA Controller \u2693\ufe0e The Direct Memory Access (DMA) controller is a dedicated and programmable hardware unit that allows MCU peripherals to access to internal memories without the intervention of the Cortex-M core. The CPU is completely freed from the overhead generated by the data transfer (except for the overhead related to the DMA configuration), and it can perform other activities. Bus architecture of and STM32F0 MCU Some important things about DMA: Both the Cortex-M core and the DMA controller interact with the other MCU peripherals through a series of buses Both the Cortex-M core and the DMA controller are masters, This means they are the only units that can start a transaction on a bus, but they cannot access to the same slave peripheral at the same time In every STM32 MCU, the DMA controller is a hardware unit that: has two master ports , named peripheral and memory port respectively, connected to the Advanced High-performance Bus (AHB), one able to interface a slave peripheral and the other one a memory controller (SRAM, flash, FSMC, etc.); in some DMA controllers a peripheral port is also able to interface a memory controller, allowing memory-to-memory transfers has one slave port , connected to the AHB bus, used to program the DMA controller from the other master, that is the CPU has a number of independent and programmable channels (request sources), each one connectable to a given peripheral request line (UART_TX, TIM_U, etc.) allows assigning different priorities to channels, in order to arbitrate the access to the memory giving higher priority to faster and important peripherals allows the data to flow in both directions, that is from memory-to-peripheral and from peripheral-to-memory The DMA architecture in an STM32 F0/F1/F3/L1 MCUs The DMA architecture in an STM32 F2/F4/F7 MCU 2. DMA Channels \u2693\ufe0e Each channel can handle DMA transfer between a peripheral register located at a fixed address and a memory address. The amount of data to be transferred (up to 65535) is programmable. The register which contains the amount of data items to be transferred is decremented after each transaction. The transfer data sizes of the peripheral and memory are fully programmable through the PSIZE and MSIZE bits in the DMA_CCRx register. Peripheral and memory pointers can optionally be automatically post-incremented after each transaction depending on the PINC (peripheral address increment) and MINC (memory address increment) bits in the DMA_CCRx register. If incremented mode is enabled, the address of the next transfer will be the address of the previous one incremented by 1, 2, or 4 depending on the chosen data size. 3. DMA Circular Mode \u2693\ufe0e The circular mode is available to handle circular buffers and continuous data flows (e.g. ADC scan mode). This feature can be enabled using the CIRC bit in the DMA_CCRx register. When the circular mode is activated, the number of data to be transferred is automatically reloaded with the initial value programmed during the channel configuration phase, and the DMA requests continue to be served. 4. DMA Interrupts \u2693\ufe0e From the performance point of view, the DMA transfer in polling mode is meaningless as there is no reason to start a DMA transfer then consume a lot of CPU cycles just to wait for the transfer completion. So the best option is to arm the DMA and let it notify when the transfer is completed. The DMA is able to generate interrupts related to channel activities (for example, the DMA1 in an STM32F030 MCU has one IRQ for channel 1, one for channels 2 and 3, one for channels 4 and 5). Moreover, three independent enable bits are available to enable IRQ on half transfer, full transfer and transfer error. Separate interrupt enable bits are available for flexibility. 5. STM32 CubeHAL Usage \u2693\ufe0e The Hardware Abstract Layer (HAL) is designed so that it abstracts from the specific peripheral memory mapping. But, it also provides a general and more user-friendly way to configure the peripheral, without forcing the programmers to now how to configure its registers in detail. Excerpt from Description of STM32F0 HAL and low-layer drivers How to use DMA HAL Enable and configure the peripheral to be connected to the DMA Channel (except for internal SRAM / FLASH memories: no initialization is necessary). Please refer to Reference manual for connection between peripherals and DMA requests. For a given Channel, program the required configuration through the following parameters: Transfer Direction, Source and Destination data formats, Circular or Normal mode, Channel Priority level, Source and Destination Increment mode, using HAL_DMA_Init() function. In Memory-to-Memory transfer mode, Circular mode is not allowed Use HAL_DMA_GetState() function to return the DMA state and HAL_DMA_GetError() in case of error detection. Use HAL_DMA_Abort() function to abort the current transfer Operation modes: Polling mode IO operation Use HAL_DMA_Start() to start DMA transfer after the configuration of Source address and destination address and the Length of data to be transferred Use HAL_DMA_PollForTransfer() to poll for the end of current transfer, in this case a fixed Timeout can be configured by User depending on from the application If DMA interrupt is enabled, this function may not work properly, read more in Notes - DMA Polling Interrupt mode IO operation Configure the DMA interrupt priority using HAL_NVIC_SetPriority() Enable the DMA IRQ handler using HAL_NVIC_EnableIRQ() Use HAL_DMA_Start_IT() to start DMA transfer after the configuration of Source address and destination address and the Length of data to be transferred. In this case the DMA interrupt is configured Use HAL_DMA_Channel_IRQHandler() called under DMA_IRQHandler() Interrupt subroutine At the end of data transfer, HAL_DMA_IRQHandler() function is executed and user can add a callback function by assigning function pointer XferCpltCallback and XferErrorCallback (i.e a member of DMA handle structure). 6. Lab: DMA Memory to Memory \u2693\ufe0e To compare the performance of DMA with CPU, this project will compare the speed of using memcpy() function and the DMA Memory-to-Memory transfer in byte-to-byte mode. Requirement : Create a 4 KB data block in flash memory (slow speed) Create a 4 KB buffer in SRAM memory (high speed) Disable code optimization in compilation Run CPU memcpy() function to copy from flash to SRAM Run DMA Mem2Mem transfer to copy from flash to SRAM Each operation\u2019s duration will be measure by a pulse on GPIO to visual view on a logic analyzer Target board : Any board has GPIOs to output execution time pulses. STM32F051R8 Mode PC8 Output Push Pull, No Pull-up and No Pull-down PC9 Output Push Pull, No Pull-up and No Pull-down 6.1. Start new project \u2693\ufe0e If start a new project on an ST\u2019s Discovery / Nucleo board, select to use default settings for the board. If start a new custom project, make sure to set up the system clock, and programmer interface. 6.2. Enable DMA \u2693\ufe0e Go to System Core \u00bb DMA peripheral Add new DMA Request, then select MEM TO MEM . Select DMA Channel, e.g. DMA1 Channel 1 Check the boxes that increase the Source Address and Destination Address, with Data Width as Byte (same as memcpy() function in non-optimized mode) Enable DMA in System Core 6.3. Generated code \u2693\ufe0e An instance of DMA_HandleTypeDef hdma_m2m_dma1_channel1 is created to hold the DMA object. Then the function MX_DMA_Init() which takes care of setting up the DMA channel enabled in IDE is generated: Enable DMA clock Setup DMA properties: Channel / Mode / Memory Address Increment / Data size /Priority static void MX_DMA_Init ( void ) { /* DMA controller clock enable */ __HAL_RCC_DMA1_CLK_ENABLE (); /* Configure DMA request hdma_m2m_dma1_channel1 on DMA1_Channel1 */ hdma_m2m_dma1_channel1 . Instance = DMA1_Channel1 ; hdma_m2m_dma1_channel1 . Init . Direction = DMA_MEMORY_TO_MEMORY ; hdma_m2m_dma1_channel1 . Init . PeriphInc = DMA_PINC_ENABLE ; hdma_m2m_dma1_channel1 . Init . MemInc = DMA_MINC_ENABLE ; hdma_m2m_dma1_channel1 . Init . PeriphDataAlignment = DMA_PDATAALIGN_BYTE ; hdma_m2m_dma1_channel1 . Init . MemDataAlignment = DMA_MDATAALIGN_BYTE ; hdma_m2m_dma1_channel1 . Init . Mode = DMA_NORMAL ; hdma_m2m_dma1_channel1 . Init . Priority = DMA_PRIORITY_LOW ; if ( HAL_DMA_Init ( & hdma_m2m_dma1_channel1 ) != HAL_OK ) { Error_Handler ( ); } } 6.4. User code \u2693\ufe0e Declare memory block The first step is to declare the data block in the Flash and the buffer in the SRAM. #define TRANSFER_SIZE 4096 const char flash_data [ TRANSFER_SIZE ] = \"hello\" ; char sram_buffer [ TRANSFER_SIZE ]; Always allocated memory for DMA at the global scope Using const modifier to put variable in to the Flash Memory by Linker. Read more here . Measure execution time To measure the execution time in a logic analyzer, output a pulse on PC9 during the transfers. This pin is set to LOW at the startup, and set to HIGH when starting transfer, and set back to LOW when the transfer completes. Test the CPU memcpy() function HAL_Delay ( 1 ); HAL_GPIO_WritePin ( GPIOC , GPIO_PIN_9 , GPIO_PIN_SET ); memcpy ( & sram_buffer , & flash_data , TRANSFER_SIZE ); HAL_GPIO_WritePin ( GPIOC , GPIO_PIN_9 , GPIO_PIN_RESET ); Test the DMA Memory-to-Memory transfer Note to use the function HAL_DMA_PollForTransfer() to blocking the CPU execution while DMA is running: HAL_Delay ( 1 ); ` HAL_GPIO_WritePin ( GPIOC , GPIO_PIN_9 , GPIO_PIN_SET ); HAL_DMA_Start ( & hdma_m2m_dma1_channel1 , ( uint32_t ) & flash_data , ( uint32_t ) & sram_buffer , TRANSFER_SIZE ); HAL_DMA_PollForTransfer ( & hdma_m2m_dma1_channel1 , HAL_DMA_FULL_TRANSFER , HAL_MAX_DELAY ); HAL_GPIO_WritePin ( GPIOC , GPIO_PIN_9 , GPIO_PIN_RESET ); Here are the output pulses showing that memcpy() needs 1193 us to complete while DMA only needs 525 us. Compare between memcpy() and DMA Mem-to-Mem 6.5. DMA interrupts \u2693\ufe0e Now, enable DMA interrupts using IDE by going to NVIC sections and check on the row saying that \u201cDMA1 channel 1 interrupt\u201d : Enable DMA Interrupt in IDE Then generated code will add into an IRQ handler in the stm32xxxx_it.c file: void DMA1_Channel1_IRQHandler ( void ) { HAL_DMA_IRQHandler ( & hdma_m2m_dma1_channel1 ); } The function HAL_DMA_IRQHandler() will call to 2 handling functions registered in DMA Handler instance: Half data length callback hdma->XferHalfCpltCallback() Full data length callback hdma->XferCpltCallback() By default, these callbacks are not set, therefore, write 2 functions to handle DMA interrupts. Note that, a new GPIO PC8 is used to show the last half transfer time. void DMA_HalfTransferCallback ( DMA_HandleTypeDef * _hdma ) { HAL_GPIO_WritePin ( GPIOC , GPIO_PIN_8 , GPIO_PIN_SET ); } void DMA_FullTransferCallback ( DMA_HandleTypeDef * _hdma ) { HAL_GPIO_WritePin ( GPIOC , GPIO_PIN_8 , GPIO_PIN_RESET ); HAL_GPIO_WritePin ( GPIOC , GPIO_PIN_9 , GPIO_PIN_RESET ); } Then register them, and call the DMA Start in Interrupt mode: int main ( void ) { ``` cpp HAL_Delay ( 1 ); HAL_GPIO_WritePin ( GPIOC , GPIO_PIN_9 , GPIO_PIN_SET ); #ifdef USE_DMA_INTERRUPT HAL_DMA_RegisterCallback ( & hdma_m2m_dma1_channel1 , HAL_DMA_XFER_HALFCPLT_CB_ID , DMA_HalfTransferCallback ); HAL_DMA_RegisterCallback ( & hdma_m2m_dma1_channel1 , HAL_DMA_XFER_CPLT_CB_ID , DMA_FullTransferCallback ); HAL_DMA_Start_IT ( & hdma_m2m_dma1_channel1 , ( uint32_t ) & flash_data , ( uint32_t ) & sram_buffer , TRANSFER_SIZE ); #else /* DMA Polling mode */ #endif In this case, pin LD3 will show a pulse during DMA a full transfer, while LD4 will show the execution time of the 2 nd half transfer. The DMA interrupt indicates time execution of the 2 nd half transfer 6.6. DMA Data size \u2693\ufe0e Using Word-aligned memory block to speed up the DMA transfer. Note that transfer size will be reduced. static void MX_DMA_Init ( void ) { ... hdma_m2m_dma1_channel1 . Init . PeriphDataAlignment = DMA_PDATAALIGN_BYTE ; hdma_m2m_dma1_channel1 . Init . MemDataAlignment = DMA_MDATAALIGN_BYTE ; ... } int main ( void ) { HAL_DMA_Start_IT ( & hdma_m2m_dma1_channel1 , ( uint32_t ) & flash_data , ( uint32_t ) & sram_buffer , TRANSFER_SIZE / 4 ); } As seen in below image, the DMA transferring time in Word-aligned mode is only 142us, comparing the 525us in Byte-aligned mode. Using World-aligned to reduce DMA transfer time","title":"DMA"},{"location":"blog/stm32/dma/#1-dma-controller","text":"The Direct Memory Access (DMA) controller is a dedicated and programmable hardware unit that allows MCU peripherals to access to internal memories without the intervention of the Cortex-M core. The CPU is completely freed from the overhead generated by the data transfer (except for the overhead related to the DMA configuration), and it can perform other activities. Bus architecture of and STM32F0 MCU Some important things about DMA: Both the Cortex-M core and the DMA controller interact with the other MCU peripherals through a series of buses Both the Cortex-M core and the DMA controller are masters, This means they are the only units that can start a transaction on a bus, but they cannot access to the same slave peripheral at the same time In every STM32 MCU, the DMA controller is a hardware unit that: has two master ports , named peripheral and memory port respectively, connected to the Advanced High-performance Bus (AHB), one able to interface a slave peripheral and the other one a memory controller (SRAM, flash, FSMC, etc.); in some DMA controllers a peripheral port is also able to interface a memory controller, allowing memory-to-memory transfers has one slave port , connected to the AHB bus, used to program the DMA controller from the other master, that is the CPU has a number of independent and programmable channels (request sources), each one connectable to a given peripheral request line (UART_TX, TIM_U, etc.) allows assigning different priorities to channels, in order to arbitrate the access to the memory giving higher priority to faster and important peripherals allows the data to flow in both directions, that is from memory-to-peripheral and from peripheral-to-memory The DMA architecture in an STM32 F0/F1/F3/L1 MCUs The DMA architecture in an STM32 F2/F4/F7 MCU","title":"1. DMA Controller"},{"location":"blog/stm32/dma/#2-dma-channels","text":"Each channel can handle DMA transfer between a peripheral register located at a fixed address and a memory address. The amount of data to be transferred (up to 65535) is programmable. The register which contains the amount of data items to be transferred is decremented after each transaction. The transfer data sizes of the peripheral and memory are fully programmable through the PSIZE and MSIZE bits in the DMA_CCRx register. Peripheral and memory pointers can optionally be automatically post-incremented after each transaction depending on the PINC (peripheral address increment) and MINC (memory address increment) bits in the DMA_CCRx register. If incremented mode is enabled, the address of the next transfer will be the address of the previous one incremented by 1, 2, or 4 depending on the chosen data size.","title":"2. DMA Channels"},{"location":"blog/stm32/dma/#3-dma-circular-mode","text":"The circular mode is available to handle circular buffers and continuous data flows (e.g. ADC scan mode). This feature can be enabled using the CIRC bit in the DMA_CCRx register. When the circular mode is activated, the number of data to be transferred is automatically reloaded with the initial value programmed during the channel configuration phase, and the DMA requests continue to be served.","title":"3. DMA Circular Mode"},{"location":"blog/stm32/dma/#4-dma-interrupts","text":"From the performance point of view, the DMA transfer in polling mode is meaningless as there is no reason to start a DMA transfer then consume a lot of CPU cycles just to wait for the transfer completion. So the best option is to arm the DMA and let it notify when the transfer is completed. The DMA is able to generate interrupts related to channel activities (for example, the DMA1 in an STM32F030 MCU has one IRQ for channel 1, one for channels 2 and 3, one for channels 4 and 5). Moreover, three independent enable bits are available to enable IRQ on half transfer, full transfer and transfer error. Separate interrupt enable bits are available for flexibility.","title":"4. DMA Interrupts"},{"location":"blog/stm32/dma/#5-stm32-cubehal-usage","text":"The Hardware Abstract Layer (HAL) is designed so that it abstracts from the specific peripheral memory mapping. But, it also provides a general and more user-friendly way to configure the peripheral, without forcing the programmers to now how to configure its registers in detail. Excerpt from Description of STM32F0 HAL and low-layer drivers How to use DMA HAL Enable and configure the peripheral to be connected to the DMA Channel (except for internal SRAM / FLASH memories: no initialization is necessary). Please refer to Reference manual for connection between peripherals and DMA requests. For a given Channel, program the required configuration through the following parameters: Transfer Direction, Source and Destination data formats, Circular or Normal mode, Channel Priority level, Source and Destination Increment mode, using HAL_DMA_Init() function. In Memory-to-Memory transfer mode, Circular mode is not allowed Use HAL_DMA_GetState() function to return the DMA state and HAL_DMA_GetError() in case of error detection. Use HAL_DMA_Abort() function to abort the current transfer Operation modes: Polling mode IO operation Use HAL_DMA_Start() to start DMA transfer after the configuration of Source address and destination address and the Length of data to be transferred Use HAL_DMA_PollForTransfer() to poll for the end of current transfer, in this case a fixed Timeout can be configured by User depending on from the application If DMA interrupt is enabled, this function may not work properly, read more in Notes - DMA Polling Interrupt mode IO operation Configure the DMA interrupt priority using HAL_NVIC_SetPriority() Enable the DMA IRQ handler using HAL_NVIC_EnableIRQ() Use HAL_DMA_Start_IT() to start DMA transfer after the configuration of Source address and destination address and the Length of data to be transferred. In this case the DMA interrupt is configured Use HAL_DMA_Channel_IRQHandler() called under DMA_IRQHandler() Interrupt subroutine At the end of data transfer, HAL_DMA_IRQHandler() function is executed and user can add a callback function by assigning function pointer XferCpltCallback and XferErrorCallback (i.e a member of DMA handle structure).","title":"5. STM32 CubeHAL Usage"},{"location":"blog/stm32/dma/#6-lab-dma-memory-to-memory","text":"To compare the performance of DMA with CPU, this project will compare the speed of using memcpy() function and the DMA Memory-to-Memory transfer in byte-to-byte mode. Requirement : Create a 4 KB data block in flash memory (slow speed) Create a 4 KB buffer in SRAM memory (high speed) Disable code optimization in compilation Run CPU memcpy() function to copy from flash to SRAM Run DMA Mem2Mem transfer to copy from flash to SRAM Each operation\u2019s duration will be measure by a pulse on GPIO to visual view on a logic analyzer Target board : Any board has GPIOs to output execution time pulses. STM32F051R8 Mode PC8 Output Push Pull, No Pull-up and No Pull-down PC9 Output Push Pull, No Pull-up and No Pull-down","title":"6. Lab: DMA Memory to Memory"},{"location":"blog/stm32/dma/#61-start-new-project","text":"If start a new project on an ST\u2019s Discovery / Nucleo board, select to use default settings for the board. If start a new custom project, make sure to set up the system clock, and programmer interface.","title":"6.1. Start new project"},{"location":"blog/stm32/dma/#62-enable-dma","text":"Go to System Core \u00bb DMA peripheral Add new DMA Request, then select MEM TO MEM . Select DMA Channel, e.g. DMA1 Channel 1 Check the boxes that increase the Source Address and Destination Address, with Data Width as Byte (same as memcpy() function in non-optimized mode) Enable DMA in System Core","title":"6.2. Enable DMA"},{"location":"blog/stm32/dma/#63-generated-code","text":"An instance of DMA_HandleTypeDef hdma_m2m_dma1_channel1 is created to hold the DMA object. Then the function MX_DMA_Init() which takes care of setting up the DMA channel enabled in IDE is generated: Enable DMA clock Setup DMA properties: Channel / Mode / Memory Address Increment / Data size /Priority static void MX_DMA_Init ( void ) { /* DMA controller clock enable */ __HAL_RCC_DMA1_CLK_ENABLE (); /* Configure DMA request hdma_m2m_dma1_channel1 on DMA1_Channel1 */ hdma_m2m_dma1_channel1 . Instance = DMA1_Channel1 ; hdma_m2m_dma1_channel1 . Init . Direction = DMA_MEMORY_TO_MEMORY ; hdma_m2m_dma1_channel1 . Init . PeriphInc = DMA_PINC_ENABLE ; hdma_m2m_dma1_channel1 . Init . MemInc = DMA_MINC_ENABLE ; hdma_m2m_dma1_channel1 . Init . PeriphDataAlignment = DMA_PDATAALIGN_BYTE ; hdma_m2m_dma1_channel1 . Init . MemDataAlignment = DMA_MDATAALIGN_BYTE ; hdma_m2m_dma1_channel1 . Init . Mode = DMA_NORMAL ; hdma_m2m_dma1_channel1 . Init . Priority = DMA_PRIORITY_LOW ; if ( HAL_DMA_Init ( & hdma_m2m_dma1_channel1 ) != HAL_OK ) { Error_Handler ( ); } }","title":"6.3. Generated code"},{"location":"blog/stm32/dma/#64-user-code","text":"Declare memory block The first step is to declare the data block in the Flash and the buffer in the SRAM. #define TRANSFER_SIZE 4096 const char flash_data [ TRANSFER_SIZE ] = \"hello\" ; char sram_buffer [ TRANSFER_SIZE ]; Always allocated memory for DMA at the global scope Using const modifier to put variable in to the Flash Memory by Linker. Read more here . Measure execution time To measure the execution time in a logic analyzer, output a pulse on PC9 during the transfers. This pin is set to LOW at the startup, and set to HIGH when starting transfer, and set back to LOW when the transfer completes. Test the CPU memcpy() function HAL_Delay ( 1 ); HAL_GPIO_WritePin ( GPIOC , GPIO_PIN_9 , GPIO_PIN_SET ); memcpy ( & sram_buffer , & flash_data , TRANSFER_SIZE ); HAL_GPIO_WritePin ( GPIOC , GPIO_PIN_9 , GPIO_PIN_RESET ); Test the DMA Memory-to-Memory transfer Note to use the function HAL_DMA_PollForTransfer() to blocking the CPU execution while DMA is running: HAL_Delay ( 1 ); ` HAL_GPIO_WritePin ( GPIOC , GPIO_PIN_9 , GPIO_PIN_SET ); HAL_DMA_Start ( & hdma_m2m_dma1_channel1 , ( uint32_t ) & flash_data , ( uint32_t ) & sram_buffer , TRANSFER_SIZE ); HAL_DMA_PollForTransfer ( & hdma_m2m_dma1_channel1 , HAL_DMA_FULL_TRANSFER , HAL_MAX_DELAY ); HAL_GPIO_WritePin ( GPIOC , GPIO_PIN_9 , GPIO_PIN_RESET ); Here are the output pulses showing that memcpy() needs 1193 us to complete while DMA only needs 525 us. Compare between memcpy() and DMA Mem-to-Mem","title":"6.4. User code"},{"location":"blog/stm32/dma/#65-dma-interrupts","text":"Now, enable DMA interrupts using IDE by going to NVIC sections and check on the row saying that \u201cDMA1 channel 1 interrupt\u201d : Enable DMA Interrupt in IDE Then generated code will add into an IRQ handler in the stm32xxxx_it.c file: void DMA1_Channel1_IRQHandler ( void ) { HAL_DMA_IRQHandler ( & hdma_m2m_dma1_channel1 ); } The function HAL_DMA_IRQHandler() will call to 2 handling functions registered in DMA Handler instance: Half data length callback hdma->XferHalfCpltCallback() Full data length callback hdma->XferCpltCallback() By default, these callbacks are not set, therefore, write 2 functions to handle DMA interrupts. Note that, a new GPIO PC8 is used to show the last half transfer time. void DMA_HalfTransferCallback ( DMA_HandleTypeDef * _hdma ) { HAL_GPIO_WritePin ( GPIOC , GPIO_PIN_8 , GPIO_PIN_SET ); } void DMA_FullTransferCallback ( DMA_HandleTypeDef * _hdma ) { HAL_GPIO_WritePin ( GPIOC , GPIO_PIN_8 , GPIO_PIN_RESET ); HAL_GPIO_WritePin ( GPIOC , GPIO_PIN_9 , GPIO_PIN_RESET ); } Then register them, and call the DMA Start in Interrupt mode: int main ( void ) { ``` cpp HAL_Delay ( 1 ); HAL_GPIO_WritePin ( GPIOC , GPIO_PIN_9 , GPIO_PIN_SET ); #ifdef USE_DMA_INTERRUPT HAL_DMA_RegisterCallback ( & hdma_m2m_dma1_channel1 , HAL_DMA_XFER_HALFCPLT_CB_ID , DMA_HalfTransferCallback ); HAL_DMA_RegisterCallback ( & hdma_m2m_dma1_channel1 , HAL_DMA_XFER_CPLT_CB_ID , DMA_FullTransferCallback ); HAL_DMA_Start_IT ( & hdma_m2m_dma1_channel1 , ( uint32_t ) & flash_data , ( uint32_t ) & sram_buffer , TRANSFER_SIZE ); #else /* DMA Polling mode */ #endif In this case, pin LD3 will show a pulse during DMA a full transfer, while LD4 will show the execution time of the 2 nd half transfer. The DMA interrupt indicates time execution of the 2 nd half transfer","title":"6.5. DMA interrupts"},{"location":"blog/stm32/dma/#66-dma-data-size","text":"Using Word-aligned memory block to speed up the DMA transfer. Note that transfer size will be reduced. static void MX_DMA_Init ( void ) { ... hdma_m2m_dma1_channel1 . Init . PeriphDataAlignment = DMA_PDATAALIGN_BYTE ; hdma_m2m_dma1_channel1 . Init . MemDataAlignment = DMA_MDATAALIGN_BYTE ; ... } int main ( void ) { HAL_DMA_Start_IT ( & hdma_m2m_dma1_channel1 , ( uint32_t ) & flash_data , ( uint32_t ) & sram_buffer , TRANSFER_SIZE / 4 ); } As seen in below image, the DMA transferring time in Word-aligned mode is only 142us, comparing the 525us in Byte-aligned mode. Using World-aligned to reduce DMA transfer time","title":"6.6. DMA Data size"},{"location":"blog/stm32/docs/","text":"STM32CubeIDE has a better way to list all related documents of selected processor, and it can download documents too. Find the documents in menu Help \u2192 Target device docs and resources . List of documents for a target 1. The Datasheet \u2693\ufe0e This document contains highlight of the target microprocessor with main features and capabilities. Many people are confused with Reference Manual, but when comparing the content, they are written for different purpose. This document is helpful when designing a PCB. It gives recommended layout for things like signal characteristic, NRST pin, ADC pins, Boot mode, etc. Datasheet provides the following: General description including product line, speed, memory, operating voltage, temperature range Device overview with block diagram, available peripherals and functions Pinouts and pin descriptions Memory map and memory ranges Electrical Characteristics Package information, for modeling PCB footprints Ordering Information Excerpt from DS8668 \u2014 STM32F051x4 STM32F051x6 STM32F051x8 Datasheet The block diagram of STM32F051xx Boot modes At startup, the boot pin and boot selector option bit are used to select one of the three boot options: boot from User Flash memory boot from System Memory boot from embedded SRAM The boot loader is located in System Memory. It is used to reprogram the Flash memory by using USART on pins PA14 / PA15 or PA9 / PA10 . Pinout table I/O structure with marker FT for 5V-tolerant I/O, TT or TC for 3.3V-only I/O. Unless otherwise specified by a note, all I/Os are set as floating inputs during and after reset. The pinout description Alternate functions Memory map and boundary address Operation condition Speed modes on IO 2. The Reference Manual \u2693\ufe0e This is by far the most important document in order to program the target device. It defines all information about the core and peripheral at register level with bit-by-bit description. By using only this document, developer still can program the chip without any higher level API \u2014 usually called Bare-metal programming. Reference Manual provides the following: System Architecture with bus, peripherals, and connections Memory map and boundary address Boot configuration and vector table relocation Peripheral with details features, descriptions, and structure Register name and bit-fields for all accessible registers Code examples using CMSIS header files Excerpt from RM0091 \u2014 STM32F0x1/STM32F0x2/STM32F0x8 advanced ARM\u00ae-based 32-bit MCUs System architecture for STM32F0x Boot modes The boot mode configuration is latched on the 4 th rising edge of SYSCLK after a reset, and is also re-sampled when exiting from Standby mode. After this startup delay has elapsed, the CPU always fetches the top-of-stack value from address 0x00000000 , then starts code execution from the boot memory at 0x00000004 . Depending on the selected boot mode, main Flash memory, system memory or SRAM is accessible as follows: Boot from main Flash memory: the main Flash memory is aliased in the boot memory space 0x00000000 , but still accessible from its original memory space 0x08000000 . Boot from system memory: the system memory is aliased in the boot memory space 0x00000000 , but still accessible from its original memory space ( 0x1FFFEC00 on STM32F03x and STM32F05x devices, 0x1FFFC400 on STM32F04x devices, 0x1FFFC800 on STM32F07x and 0x1FFFD800 on STM32F09x devices). Boot from the embedded SRAM: the SRAM is aliased in the boot memory space 0x00000000 , but it is still accessible from its original memory space 0x20000000 . Physical remap For application code which is located in a different address than 0x08000000 , some additional code must be added in order to be able to serve the application interrupts. A solution will be to relocate by software the vector table to the internal SRAM, at the initialization phase: Copy the vector table from the Flash (mapped at the base of the application load address) to the base address of the SRAM at 0x20000000 Remap SRAM at address 0x00000000 , using SYSCFG configuration register 1 Embedded boot loader The embedded boot loader is located in the System memory, programmed by ST during production. It is used to reprogram the Flash memory using one of the following serial interfaces: USART on pins PA14 / PA15 or PA9 / PA10 I2C on pins PB6 / PB7 (STM32F04xxx, STM32F07xxx and STM32F09xxx devices only) USB DFU interface (STM32F04xxx and STM32F07xxx devices only) Debug pin During and just after reset, the alternate functions are not active and most of the I/O ports are configured in input floating mode, except the debug pins are in AF mode immediately: PA14 : SWCLK in pull-down PA13 : SWDIO in pull-up The clock paths Example code USART transmitter configuration: /* (1) Oversampling by 16, 9600 baud */ /* (2) 8 data bit, 1 start bit, 1 stop bit, no parity */ USART1 -> BRR = 480000 / 96 ; /* (1) */ USART1 -> CR1 = USART_CR1_TE | USART_CR1_UE ; /* (2) */ USART transfer: if (( USART1 -> ISR & USART_ISR_TC ) == USART_ISR_TC ) { if ( send == sizeof ( stringtosend )) { send = 0 ; USART1 -> ICR |= USART_ICR_TCCF ; /* Clear transfer complete flag */ } else { /* clear transfer complete flag and fill TDR with a new char */ USART1 -> TDR = stringtosend [ send ++ ]; } } The structure of an IO pin 3. Programming Manual \u2693\ufe0e This programming manual provides information for application and system-level software developers. It gives a full description of the STM32 Cortex\u2122-M0 processor programming model, instruction set and core peripherals. Programming Manual provides the following: Processor Modes, Stacks Memory model Exception model, the Vector table and the interrupt service routines Fault handling Power management: enter Sleep mode, Wake up The Instruction Set CMSIS intrinsic functions Core Peripherals: Memory Protection Unit (MPU) Nested vectored interrupt controller (NVIC) System control block (SCB) SysTick timer (STK) Excerpt from PM0215 \u2014 STM32F0xxx Cortex-M0 programming manual Processor modes Thread mode: Used to execute application software. The processor enters Thread mode when it comes out of reset Handler mode: Used to handle exceptions. The processor returns to Thread mode when it has finished exception processing. Registers Stacks The processor uses a full descending stack. This means the stack pointer indicates the last stacked item on the stack memory. The processor implements two stacks, with independent copies of the stack pointer: The main stack and The process stack In Thread mode, the CONTROL register controls whether the processor uses the main stack or the process stack: 0 : Main Stack Pointer (MSP)(reset value). On reset, the processor loads the MSP with the value from address 0x00000000 . 1 : Process Stack Pointer (PSP). In Handler mode, the processor always uses the main stack. Memory endianness The processor views memory in little-endian format. It stores the least significant byte (lsbyte) of a word at the lowest-numbered byte, and the most significant byte (msbyte) at the highest-numbered byte. The Little-Endian memory layout The exception types Vector table On system reset, the vector table is fixed at address 0x00000000 . The least-significant bit of each vector must be 1, indicating that the exception handler is Thumb code. The exception vector table 4. Application Note \u2693\ufe0e There many Application Note documents provided by ST. Each document present the usage, design, and advice for a specific application or feature. Application Note provides the following: Peripherals architecture in hardware and software Operation characteristic Excerpt from AN2548 \u2014 Using the STM32F0/F1/F3/Gx/Lx Series DMA controller DMA transfer timing For the case where only one DMA channel is active, a new hardware back-to-back request can not be handled by the DMA before the completion of the previous one, adding one AHB clock cycle for the final idle phase of the DMA request-acknowledge handshake protocol. DMA Block diagram When more than one channel is requesting a DMA transfer, the DMA request arbitration can be performed meanwhile the two last cycles of when the AHB bus is accessed by the DMA. Request arbitration overhead is then masked by the AHB bus transfer time. In case not only two channels, but two DMA controllers are used (in products that offer this possibility), two DMA transfers can be processed in parallel, as long as they are not conflicting within the bus matrix, not accessing the same slave device. Timing of Two DMA channel on AHB Bus Excerpt from AN2834 \u2014 How to get the best ADC accuracy in STM32 microcontrollers SAR ADC internal structure The ADC embedded in STM32 microcontrollers uses the SAR (successive approximation register) principle, by which the conversion is performed in several steps. The number of conversion steps is equal to the number of bits in the ADC converter. Each step is driven by the ADC clock. Each ADC clock produces one bit from result to output. The ADC internal design is based on the switched-capacitor technique. Basic schematic of SAR switched-capacitor ADC How to get the best ADC accuracy Reduce the effects of ADC-related ADC errors Offset and gain errors can be easily compensated using the STM32 ADC self-calibration feature or by microcontroller firmware. Minimize ADC errors related to external environment of ADC It is recommended to connect capacitors with good high-frequency characteristics between the power and ground lines. That is, a 0.1 \u00b5F and a 1 to 10 \u00b5F capacitor should be placed close to the power source. In most STM32 microcontrollers, the VDD and VSS pins are placed close to each other. So are the VREF+ and VSSA pins. A capacitor can therefore be connected very close to the microcontroller with very short leads. For multiple VDD and VSS pins, use separate decoupling capacitors. 5. Platform API Manual \u2693\ufe0e When using a software platform as a base for application development, the API manual document provides the usage and use case of available functions, settings, and parameters. STM32 MCUs come with Hardware Abstract Layer (HAL) and Low-Layer (LL) library which are used in code generation from STM32CubeMX. Excerpt from UM1785 \u2014 Description of STM32F0 HAL and low-layer drivers GPIO Firmware driver API description Enable the GPIO AHB clock using the following function __HAL_RCC_GPIOx_CLK_ENABLE() . Configure the GPIO pin(s) using HAL_GPIO_Init() . Configure the IO mode using \u201cMode\u201d member from GPIO_InitTypeDef structure Activate Pull-up, Pull-down resistor using \u201cPull\u201d member from GPIO_InitTypeDef structure. In case of Output or alternate function mode selection: the speed is configured through \u201cSpeed\u201d member from GPIO_InitTypeDef structure. In alternate mode is selection, the alternate function connected to the IO is configured through \u201cAlternate\u201d member from GPIO_InitTypeDef structure. Analog mode is required when a pin is to be used as ADC channel or DAC output. In case of external interrupt/event selection the \u201cMode\u201d member from GPIO_InitTypeDef structure select the type (interrupt or event) and the corresponding trigger event (rising or falling or both). In case of external interrupt/event mode selection, configure NVIC IRQ priority mapped to the EXTI line using HAL_NVIC_SetPriority() and enable it using HAL_NVIC_EnableIRQ() . HAL_GPIO_DeInit() allows to set register values to their reset value. It\u2019s also recommended to use it to un-configure pin which was used as an external interrupt or in event mode. That\u2019s the only way to reset corresponding bit in EXTI & SYSCFG registers. To get the level of a pin configured in input mode use HAL_GPIO_ReadPin() . To set/reset the level of a pin configured in output mode use HAL_GPIO_WritePin() / HAL_GPIO_TogglePin() . To lock pin configuration until next reset use HAL_GPIO_LockPin() . During and just after reset, the alternate functions are not active and the GPIO pins are configured in input floating mode (except JTAG/SWD pins). The LSE oscillator pins OSC32_IN and OSC32_OUT can be used as general purpose ( PC14 and PC15 , respectively) when the LSE oscillator is off. The LSE has priority over the GPIO function. The HSE oscillator pins OSC_IN and OSC_OUT can be used as general purpose PF0 and PF1 , respectively, when the HSE oscillator is off. The HSE has priority over the GPIO function. 6. Main board schematic \u2693\ufe0e It is better to get a schematic of the board which is under the development, to know the correct signal level and characteristic. Main board schematic provides the following: Input and Output characteristics (Pull-up, Pull-down, Open, Voltage level) Connection points (internal wires, connectors, test point) Working conditions (Power level, Voltage Level tolerance) When downloading schematic from ST, please check the version of hardware on the board, such as MB1034B . In old Manual Document, there is a section for schematic. Excerpt from MB1034 \u2014 STM32F0DISCOVERY schematic STMF0DISCOVERY schematic 7. Board-specific document \u2693\ufe0e When using an official board from ST, there are some board-specific documents provided to users: Peripheral firmware example Migration and compatibility guidelines 8. Application integration \u2693\ufe0e When using RTOS or other application later, it is recommended to read their guides and API documents. For example: UM1722 \u2014 Developing applications on STM32Cube with RTOS This document is a reference to program user application in RTOS. This document has below content: FreeRTOS: overview, APIs, memory management, low power managements, and configuration CMSIS-RTOS: a higher layer to communicate between CMSIS and FreeRTOS Usage to create thread, use Semaphore, Queues, and Timer CMSIS \u2014 Cortex Microcontroller Software Interface Standard ARM develops the Cortex Microcontroller Software Interface Standard (CMSIS) to allow microcontroller and software vendor to use a consistent software infrastructure to develop software solutions for Cortex-M microcontroller. It is a set of APIs for application or middleware developers to access the features on the Cortex-M processor regardless of the microcontroller devices or tool chain used. To use the CMSIS-Core (Cortex-M) the following files are added to the embedded application: Startup File startup_<device>.c with reset handler and exception vectors. System Configuration Files system_<device>.c and system_<device>.h with general device configuration (i.e. for clock and BUS setup). Device Header File <device.h> gives access to processor core and all peripherals. Register names and bit-fields are defined in the Reference Manual of the process. 9. Source Code \u2693\ufe0e Reading a source code and understanding how it works is one of a good way to know about the target system. There are comments in the source code too, and they usually explain about a corner case, issue, or the particular purpose of the implementation. 10. Website \u2693\ufe0e Yep, search on the internet, read them all, sometime ask people, and try to answer other\u2019s question. All those actions can help in learning not only programming but also other fields.","title":"Documents"},{"location":"blog/stm32/docs/#1-the-datasheet","text":"This document contains highlight of the target microprocessor with main features and capabilities. Many people are confused with Reference Manual, but when comparing the content, they are written for different purpose. This document is helpful when designing a PCB. It gives recommended layout for things like signal characteristic, NRST pin, ADC pins, Boot mode, etc. Datasheet provides the following: General description including product line, speed, memory, operating voltage, temperature range Device overview with block diagram, available peripherals and functions Pinouts and pin descriptions Memory map and memory ranges Electrical Characteristics Package information, for modeling PCB footprints Ordering Information Excerpt from DS8668 \u2014 STM32F051x4 STM32F051x6 STM32F051x8 Datasheet The block diagram of STM32F051xx Boot modes At startup, the boot pin and boot selector option bit are used to select one of the three boot options: boot from User Flash memory boot from System Memory boot from embedded SRAM The boot loader is located in System Memory. It is used to reprogram the Flash memory by using USART on pins PA14 / PA15 or PA9 / PA10 . Pinout table I/O structure with marker FT for 5V-tolerant I/O, TT or TC for 3.3V-only I/O. Unless otherwise specified by a note, all I/Os are set as floating inputs during and after reset. The pinout description Alternate functions Memory map and boundary address Operation condition Speed modes on IO","title":"1. The Datasheet"},{"location":"blog/stm32/docs/#2-the-reference-manual","text":"This is by far the most important document in order to program the target device. It defines all information about the core and peripheral at register level with bit-by-bit description. By using only this document, developer still can program the chip without any higher level API \u2014 usually called Bare-metal programming. Reference Manual provides the following: System Architecture with bus, peripherals, and connections Memory map and boundary address Boot configuration and vector table relocation Peripheral with details features, descriptions, and structure Register name and bit-fields for all accessible registers Code examples using CMSIS header files Excerpt from RM0091 \u2014 STM32F0x1/STM32F0x2/STM32F0x8 advanced ARM\u00ae-based 32-bit MCUs System architecture for STM32F0x Boot modes The boot mode configuration is latched on the 4 th rising edge of SYSCLK after a reset, and is also re-sampled when exiting from Standby mode. After this startup delay has elapsed, the CPU always fetches the top-of-stack value from address 0x00000000 , then starts code execution from the boot memory at 0x00000004 . Depending on the selected boot mode, main Flash memory, system memory or SRAM is accessible as follows: Boot from main Flash memory: the main Flash memory is aliased in the boot memory space 0x00000000 , but still accessible from its original memory space 0x08000000 . Boot from system memory: the system memory is aliased in the boot memory space 0x00000000 , but still accessible from its original memory space ( 0x1FFFEC00 on STM32F03x and STM32F05x devices, 0x1FFFC400 on STM32F04x devices, 0x1FFFC800 on STM32F07x and 0x1FFFD800 on STM32F09x devices). Boot from the embedded SRAM: the SRAM is aliased in the boot memory space 0x00000000 , but it is still accessible from its original memory space 0x20000000 . Physical remap For application code which is located in a different address than 0x08000000 , some additional code must be added in order to be able to serve the application interrupts. A solution will be to relocate by software the vector table to the internal SRAM, at the initialization phase: Copy the vector table from the Flash (mapped at the base of the application load address) to the base address of the SRAM at 0x20000000 Remap SRAM at address 0x00000000 , using SYSCFG configuration register 1 Embedded boot loader The embedded boot loader is located in the System memory, programmed by ST during production. It is used to reprogram the Flash memory using one of the following serial interfaces: USART on pins PA14 / PA15 or PA9 / PA10 I2C on pins PB6 / PB7 (STM32F04xxx, STM32F07xxx and STM32F09xxx devices only) USB DFU interface (STM32F04xxx and STM32F07xxx devices only) Debug pin During and just after reset, the alternate functions are not active and most of the I/O ports are configured in input floating mode, except the debug pins are in AF mode immediately: PA14 : SWCLK in pull-down PA13 : SWDIO in pull-up The clock paths Example code USART transmitter configuration: /* (1) Oversampling by 16, 9600 baud */ /* (2) 8 data bit, 1 start bit, 1 stop bit, no parity */ USART1 -> BRR = 480000 / 96 ; /* (1) */ USART1 -> CR1 = USART_CR1_TE | USART_CR1_UE ; /* (2) */ USART transfer: if (( USART1 -> ISR & USART_ISR_TC ) == USART_ISR_TC ) { if ( send == sizeof ( stringtosend )) { send = 0 ; USART1 -> ICR |= USART_ICR_TCCF ; /* Clear transfer complete flag */ } else { /* clear transfer complete flag and fill TDR with a new char */ USART1 -> TDR = stringtosend [ send ++ ]; } } The structure of an IO pin","title":"2. The Reference Manual"},{"location":"blog/stm32/docs/#3-programming-manual","text":"This programming manual provides information for application and system-level software developers. It gives a full description of the STM32 Cortex\u2122-M0 processor programming model, instruction set and core peripherals. Programming Manual provides the following: Processor Modes, Stacks Memory model Exception model, the Vector table and the interrupt service routines Fault handling Power management: enter Sleep mode, Wake up The Instruction Set CMSIS intrinsic functions Core Peripherals: Memory Protection Unit (MPU) Nested vectored interrupt controller (NVIC) System control block (SCB) SysTick timer (STK) Excerpt from PM0215 \u2014 STM32F0xxx Cortex-M0 programming manual Processor modes Thread mode: Used to execute application software. The processor enters Thread mode when it comes out of reset Handler mode: Used to handle exceptions. The processor returns to Thread mode when it has finished exception processing. Registers Stacks The processor uses a full descending stack. This means the stack pointer indicates the last stacked item on the stack memory. The processor implements two stacks, with independent copies of the stack pointer: The main stack and The process stack In Thread mode, the CONTROL register controls whether the processor uses the main stack or the process stack: 0 : Main Stack Pointer (MSP)(reset value). On reset, the processor loads the MSP with the value from address 0x00000000 . 1 : Process Stack Pointer (PSP). In Handler mode, the processor always uses the main stack. Memory endianness The processor views memory in little-endian format. It stores the least significant byte (lsbyte) of a word at the lowest-numbered byte, and the most significant byte (msbyte) at the highest-numbered byte. The Little-Endian memory layout The exception types Vector table On system reset, the vector table is fixed at address 0x00000000 . The least-significant bit of each vector must be 1, indicating that the exception handler is Thumb code. The exception vector table","title":"3. Programming Manual"},{"location":"blog/stm32/docs/#4-application-note","text":"There many Application Note documents provided by ST. Each document present the usage, design, and advice for a specific application or feature. Application Note provides the following: Peripherals architecture in hardware and software Operation characteristic Excerpt from AN2548 \u2014 Using the STM32F0/F1/F3/Gx/Lx Series DMA controller DMA transfer timing For the case where only one DMA channel is active, a new hardware back-to-back request can not be handled by the DMA before the completion of the previous one, adding one AHB clock cycle for the final idle phase of the DMA request-acknowledge handshake protocol. DMA Block diagram When more than one channel is requesting a DMA transfer, the DMA request arbitration can be performed meanwhile the two last cycles of when the AHB bus is accessed by the DMA. Request arbitration overhead is then masked by the AHB bus transfer time. In case not only two channels, but two DMA controllers are used (in products that offer this possibility), two DMA transfers can be processed in parallel, as long as they are not conflicting within the bus matrix, not accessing the same slave device. Timing of Two DMA channel on AHB Bus Excerpt from AN2834 \u2014 How to get the best ADC accuracy in STM32 microcontrollers SAR ADC internal structure The ADC embedded in STM32 microcontrollers uses the SAR (successive approximation register) principle, by which the conversion is performed in several steps. The number of conversion steps is equal to the number of bits in the ADC converter. Each step is driven by the ADC clock. Each ADC clock produces one bit from result to output. The ADC internal design is based on the switched-capacitor technique. Basic schematic of SAR switched-capacitor ADC How to get the best ADC accuracy Reduce the effects of ADC-related ADC errors Offset and gain errors can be easily compensated using the STM32 ADC self-calibration feature or by microcontroller firmware. Minimize ADC errors related to external environment of ADC It is recommended to connect capacitors with good high-frequency characteristics between the power and ground lines. That is, a 0.1 \u00b5F and a 1 to 10 \u00b5F capacitor should be placed close to the power source. In most STM32 microcontrollers, the VDD and VSS pins are placed close to each other. So are the VREF+ and VSSA pins. A capacitor can therefore be connected very close to the microcontroller with very short leads. For multiple VDD and VSS pins, use separate decoupling capacitors.","title":"4. Application Note"},{"location":"blog/stm32/docs/#5-platform-api-manual","text":"When using a software platform as a base for application development, the API manual document provides the usage and use case of available functions, settings, and parameters. STM32 MCUs come with Hardware Abstract Layer (HAL) and Low-Layer (LL) library which are used in code generation from STM32CubeMX. Excerpt from UM1785 \u2014 Description of STM32F0 HAL and low-layer drivers GPIO Firmware driver API description Enable the GPIO AHB clock using the following function __HAL_RCC_GPIOx_CLK_ENABLE() . Configure the GPIO pin(s) using HAL_GPIO_Init() . Configure the IO mode using \u201cMode\u201d member from GPIO_InitTypeDef structure Activate Pull-up, Pull-down resistor using \u201cPull\u201d member from GPIO_InitTypeDef structure. In case of Output or alternate function mode selection: the speed is configured through \u201cSpeed\u201d member from GPIO_InitTypeDef structure. In alternate mode is selection, the alternate function connected to the IO is configured through \u201cAlternate\u201d member from GPIO_InitTypeDef structure. Analog mode is required when a pin is to be used as ADC channel or DAC output. In case of external interrupt/event selection the \u201cMode\u201d member from GPIO_InitTypeDef structure select the type (interrupt or event) and the corresponding trigger event (rising or falling or both). In case of external interrupt/event mode selection, configure NVIC IRQ priority mapped to the EXTI line using HAL_NVIC_SetPriority() and enable it using HAL_NVIC_EnableIRQ() . HAL_GPIO_DeInit() allows to set register values to their reset value. It\u2019s also recommended to use it to un-configure pin which was used as an external interrupt or in event mode. That\u2019s the only way to reset corresponding bit in EXTI & SYSCFG registers. To get the level of a pin configured in input mode use HAL_GPIO_ReadPin() . To set/reset the level of a pin configured in output mode use HAL_GPIO_WritePin() / HAL_GPIO_TogglePin() . To lock pin configuration until next reset use HAL_GPIO_LockPin() . During and just after reset, the alternate functions are not active and the GPIO pins are configured in input floating mode (except JTAG/SWD pins). The LSE oscillator pins OSC32_IN and OSC32_OUT can be used as general purpose ( PC14 and PC15 , respectively) when the LSE oscillator is off. The LSE has priority over the GPIO function. The HSE oscillator pins OSC_IN and OSC_OUT can be used as general purpose PF0 and PF1 , respectively, when the HSE oscillator is off. The HSE has priority over the GPIO function.","title":"5. Platform API Manual"},{"location":"blog/stm32/docs/#6-main-board-schematic","text":"It is better to get a schematic of the board which is under the development, to know the correct signal level and characteristic. Main board schematic provides the following: Input and Output characteristics (Pull-up, Pull-down, Open, Voltage level) Connection points (internal wires, connectors, test point) Working conditions (Power level, Voltage Level tolerance) When downloading schematic from ST, please check the version of hardware on the board, such as MB1034B . In old Manual Document, there is a section for schematic. Excerpt from MB1034 \u2014 STM32F0DISCOVERY schematic STMF0DISCOVERY schematic","title":"6. Main board schematic"},{"location":"blog/stm32/docs/#7-board-specific-document","text":"When using an official board from ST, there are some board-specific documents provided to users: Peripheral firmware example Migration and compatibility guidelines","title":"7. Board-specific document"},{"location":"blog/stm32/docs/#8-application-integration","text":"When using RTOS or other application later, it is recommended to read their guides and API documents. For example: UM1722 \u2014 Developing applications on STM32Cube with RTOS This document is a reference to program user application in RTOS. This document has below content: FreeRTOS: overview, APIs, memory management, low power managements, and configuration CMSIS-RTOS: a higher layer to communicate between CMSIS and FreeRTOS Usage to create thread, use Semaphore, Queues, and Timer CMSIS \u2014 Cortex Microcontroller Software Interface Standard ARM develops the Cortex Microcontroller Software Interface Standard (CMSIS) to allow microcontroller and software vendor to use a consistent software infrastructure to develop software solutions for Cortex-M microcontroller. It is a set of APIs for application or middleware developers to access the features on the Cortex-M processor regardless of the microcontroller devices or tool chain used. To use the CMSIS-Core (Cortex-M) the following files are added to the embedded application: Startup File startup_<device>.c with reset handler and exception vectors. System Configuration Files system_<device>.c and system_<device>.h with general device configuration (i.e. for clock and BUS setup). Device Header File <device.h> gives access to processor core and all peripherals. Register names and bit-fields are defined in the Reference Manual of the process.","title":"8. Application integration"},{"location":"blog/stm32/docs/#9-source-code","text":"Reading a source code and understanding how it works is one of a good way to know about the target system. There are comments in the source code too, and they usually explain about a corner case, issue, or the particular purpose of the implementation.","title":"9. Source Code"},{"location":"blog/stm32/docs/#10-website","text":"Yep, search on the internet, read them all, sometime ask people, and try to answer other\u2019s question. All those actions can help in learning not only programming but also other fields.","title":"10. Website"},{"location":"blog/stm32/free-rtos/interrupt/","text":"1. Interrupts \u2693\ufe0e SVC interrupt Interrupt risen by SVC instruction SVC 0 call used only once, to start the scheduler (within vPortStartFirstTask() which is used to start the kernel) SysTick timer Lowest NVIC interrupt priority Used for task switching on configTICK_RATE_HZ regular time base Set PendSV if context switch is necessary PendSV interrupt Used for task switching before tick rate Lowest NVIC interrupt priority Not triggered by any peripheral Kernel interrupts FreeRTOS kernel and its IRQ procedures ( PendSV , SysTick ) have the lowest possible interrupt priority (255) set in FreeRTOSConfig.h by the declaration configKERNEL_INTERRUPT_PRIORITY . There is a group of interrupts which can cooperate with FreeRTOS API by calling its functions. Maximum level for those peripherals (based on the position in vector table) is set in configMAX_SYSCALL_INTERRUPT_PRIORITY . It is possible to use nested interrupts. ISR is independent of all tasks The code of the ISR does not belong to any part of the task code of FreeRTOS. Each ISR is a function, but it is not a task, and it will not be called by any task. ISR uses the stack in different way of a task. FreeRTOS allocates independent stack space for each task, which is used to save local variables of functions and so on. When an interrupt occurs, certain registers of the CPU will be saved to the current stack (instead of specifying a task stack), and then the ISR program will be executed. If the code of a certain task is currently being executed, it will occupy the stack of the task If the code of another ISR is currently being executed and interrupt nesting occurs, then the stack of the task that was interrupted earlier may continue to be used ISR does not change the status of the current task . Although the execution of the currently running task is suspended after the IRQ occurs, and the CPU executes the code of the ISR, the state of the current task is still Running, and it does not change to another state - this is obviously different from the task being preempted. Even if the FreeRTOS API is called in the ISR, other tasks with higher priority than the current task are awakened (turned to the Ready state), and the task switching operation will be performed after the ISR returns, and the task to run will be reselected. In fact, the ISR does not know what the currently running task is, and it does not make sense to actively change the current task status. 2. API functions in Interrupts \u2693\ufe0e In the FreeRTOS documentation, it has been emphasized that the API functions whose names end with FromISR must be called in the ISR, instead of the conventional API. This is because the execution environment and tasks of the ISR are different. The API called in the ISR requires a quick return and no waiting is allowed . Some APIs cannot be used in ISR because they have blocking functions, or they can change their functions, including parameter passing requirements. For example, there are two APIs for using Semaphore: xSemaphoreGiveFromISR ( semaphore , * pxHigherPriorityTaskWoken ) and xSemaphoreGiveFromISR ( semaphore ) The only difference for the programmer is additional argument *pxHigherPriorityTaskWoken which is used to determine whether a higher priority task is awakened, and the ISR itself decides whether to switch tasks. If this parameter is pdTRUE , context switch (PendSV IRQ) should be requested by portYIELD_FROM_ISR() in kernel before the interrupt exits. When using CMSIS API, this process is automatically handled by the library (by checking IPSR content) and is transparent. 3. Signal from ISR to Task \u2693\ufe0e In order to support real-time response to hardware events, the interrupt service routine (ISR) must be executed as soon as possible. Because the system may have a variety of interrupts, the ISR needs to be programmed as short as possible, and return after critical operations are performed to allow other interrupts to be processed. It\u2019s preferred to post a message from an ISR using FromISR API and then handle that message in a task space. However, this may cause latency in processing the request if the target task is not scheduled to run soon or in the worst case, it is blocked. Only if the requirement is to have very low latency of processing, ISR can process the data. One solution to process data immediately after the ISR is post a message to the font of the queue, and request schedule to switch to a task. void vBufferISR ( void ) { char cIn ; BaseType_t xHigherPriorityTaskWoken ; /* We have not woken a task at the start of the ISR. */ xHigherPriorityTaskWoken = pdFALSE ; /* Obtain a byte from the buffer. */ cIn = portINPUT_BYTE ( RX_REGISTER_ADDRESS ); if ( cIn == EMERGENCY_MESSAGE ) { /* Post the byte to the front of the queue. */ xQueueSendToFrontFromISR ( xRxQueue , & cIn , & xHigherPriorityTaskWoken ); } else { /* Post the byte to the back of the queue. */ xQueueSendToBackFromISR ( xRxQueue , & cIn , & xHigherPriorityTaskWoken ); } /* Did sending to the queue unblock a higher priority task? */ /* Actual macro used here is port specific. */ portYIELD_FROM_ISR ( xHigherPriorityTaskWoken ); } 4. Interrupt status \u2693\ufe0e There maybe a code which can be call either in a task or in an ISR. However, it should be implemented to be run in both cases without impact the execution. The IPSR (Interrupt Program Status Register) is read to determine whether there is an interrupt is being processed. register uint32_t __regIPSR __ASM ( \"ipsr\" ); An example of checking IPSR: uint32_t osGetSysTick ( void ) { /* read out IPSR register*/ register uint32_t __regIPSR __ASM ( \"ipsr\" ); /* regIPSR == 0 if controller is in thread mode */ if ( __regIPSR == 0 ) { return xTaskGetTickCount (); } else { return xTaskGetTickCountFromISR (); } }","title":"Interrupt"},{"location":"blog/stm32/free-rtos/interrupt/#1-interrupts","text":"SVC interrupt Interrupt risen by SVC instruction SVC 0 call used only once, to start the scheduler (within vPortStartFirstTask() which is used to start the kernel) SysTick timer Lowest NVIC interrupt priority Used for task switching on configTICK_RATE_HZ regular time base Set PendSV if context switch is necessary PendSV interrupt Used for task switching before tick rate Lowest NVIC interrupt priority Not triggered by any peripheral Kernel interrupts FreeRTOS kernel and its IRQ procedures ( PendSV , SysTick ) have the lowest possible interrupt priority (255) set in FreeRTOSConfig.h by the declaration configKERNEL_INTERRUPT_PRIORITY . There is a group of interrupts which can cooperate with FreeRTOS API by calling its functions. Maximum level for those peripherals (based on the position in vector table) is set in configMAX_SYSCALL_INTERRUPT_PRIORITY . It is possible to use nested interrupts. ISR is independent of all tasks The code of the ISR does not belong to any part of the task code of FreeRTOS. Each ISR is a function, but it is not a task, and it will not be called by any task. ISR uses the stack in different way of a task. FreeRTOS allocates independent stack space for each task, which is used to save local variables of functions and so on. When an interrupt occurs, certain registers of the CPU will be saved to the current stack (instead of specifying a task stack), and then the ISR program will be executed. If the code of a certain task is currently being executed, it will occupy the stack of the task If the code of another ISR is currently being executed and interrupt nesting occurs, then the stack of the task that was interrupted earlier may continue to be used ISR does not change the status of the current task . Although the execution of the currently running task is suspended after the IRQ occurs, and the CPU executes the code of the ISR, the state of the current task is still Running, and it does not change to another state - this is obviously different from the task being preempted. Even if the FreeRTOS API is called in the ISR, other tasks with higher priority than the current task are awakened (turned to the Ready state), and the task switching operation will be performed after the ISR returns, and the task to run will be reselected. In fact, the ISR does not know what the currently running task is, and it does not make sense to actively change the current task status.","title":"1. Interrupts"},{"location":"blog/stm32/free-rtos/interrupt/#2-api-functions-in-interrupts","text":"In the FreeRTOS documentation, it has been emphasized that the API functions whose names end with FromISR must be called in the ISR, instead of the conventional API. This is because the execution environment and tasks of the ISR are different. The API called in the ISR requires a quick return and no waiting is allowed . Some APIs cannot be used in ISR because they have blocking functions, or they can change their functions, including parameter passing requirements. For example, there are two APIs for using Semaphore: xSemaphoreGiveFromISR ( semaphore , * pxHigherPriorityTaskWoken ) and xSemaphoreGiveFromISR ( semaphore ) The only difference for the programmer is additional argument *pxHigherPriorityTaskWoken which is used to determine whether a higher priority task is awakened, and the ISR itself decides whether to switch tasks. If this parameter is pdTRUE , context switch (PendSV IRQ) should be requested by portYIELD_FROM_ISR() in kernel before the interrupt exits. When using CMSIS API, this process is automatically handled by the library (by checking IPSR content) and is transparent.","title":"2. API functions in Interrupts"},{"location":"blog/stm32/free-rtos/interrupt/#3-signal-from-isr-to-task","text":"In order to support real-time response to hardware events, the interrupt service routine (ISR) must be executed as soon as possible. Because the system may have a variety of interrupts, the ISR needs to be programmed as short as possible, and return after critical operations are performed to allow other interrupts to be processed. It\u2019s preferred to post a message from an ISR using FromISR API and then handle that message in a task space. However, this may cause latency in processing the request if the target task is not scheduled to run soon or in the worst case, it is blocked. Only if the requirement is to have very low latency of processing, ISR can process the data. One solution to process data immediately after the ISR is post a message to the font of the queue, and request schedule to switch to a task. void vBufferISR ( void ) { char cIn ; BaseType_t xHigherPriorityTaskWoken ; /* We have not woken a task at the start of the ISR. */ xHigherPriorityTaskWoken = pdFALSE ; /* Obtain a byte from the buffer. */ cIn = portINPUT_BYTE ( RX_REGISTER_ADDRESS ); if ( cIn == EMERGENCY_MESSAGE ) { /* Post the byte to the front of the queue. */ xQueueSendToFrontFromISR ( xRxQueue , & cIn , & xHigherPriorityTaskWoken ); } else { /* Post the byte to the back of the queue. */ xQueueSendToBackFromISR ( xRxQueue , & cIn , & xHigherPriorityTaskWoken ); } /* Did sending to the queue unblock a higher priority task? */ /* Actual macro used here is port specific. */ portYIELD_FROM_ISR ( xHigherPriorityTaskWoken ); }","title":"3. Signal from ISR to Task"},{"location":"blog/stm32/free-rtos/interrupt/#4-interrupt-status","text":"There maybe a code which can be call either in a task or in an ISR. However, it should be implemented to be run in both cases without impact the execution. The IPSR (Interrupt Program Status Register) is read to determine whether there is an interrupt is being processed. register uint32_t __regIPSR __ASM ( \"ipsr\" ); An example of checking IPSR: uint32_t osGetSysTick ( void ) { /* read out IPSR register*/ register uint32_t __regIPSR __ASM ( \"ipsr\" ); /* regIPSR == 0 if controller is in thread mode */ if ( __regIPSR == 0 ) { return xTaskGetTickCount (); } else { return xTaskGetTickCountFromISR (); } }","title":"4. Interrupt status"},{"location":"blog/stm32/free-rtos/memory/","text":"1. Dynamic Memory Management \u2693\ufe0e FreeRTOS uses a region of memory called Heap (into the RAM) to allocate memory for tasks, queues, timers, semaphores, mutexes and when dynamically creating variables. FreeRTOS heap is different from the system heap defined at the compiler level. Memory Heap in RTOS When FreeRTOS requires RAM, instead of calling the standard malloc() , it calls PvPortMalloc() . When it needs to free memory it calls PvPortFree() instead of the standard free() . FreeRTOS offers several heap management schemes that range in complexity and features. The FreeRTOS download includes five sample memory allocation implementations, each of which are described in the following subsections. The subsections also include information on when each of the provided implementations might be the most appropriate to select. Heap management schemes: heap_1 \u2014 the very simplest, does not permit memory to be freed. heap_2 \u2014 permits memory to be freed, but does not coalescence adjacent free blocks. heap_3 \u2014 simply wraps the standard malloc() and free() for thread safety. heap_4 \u2014 coalescence adjacent free blocks to avoid fragmentation. Includes absolute address placement option. heap_5 \u2014 as per heap_4 , with the ability to span the heap across multiple non-adjacent memory areas. Notes: heap_1 is less useful since FreeRTOS added support for static allocation. heap_2 is now considered legacy as the newer heap_4 implementation is preferred. 1.1. Heap_1 \u2693\ufe0e This implementation uses first fit algorithm to allocate memory. It is the simplest allocation method (deterministic), but does not allow freeing of allocated memory. This could be interesting when no memory freeing is necessary. Heap_1 method 1.2. Heap_2 \u2693\ufe0e This implementation is not recommended to new projects. It\u2019s kept due to backward compatibility. This method implements the best fit algorithm for allocation. It allows memory free() operation but doesn\u2019t combine adjacent free blocks. This method has risk of fragmentation. Heap_2 method 1.3. Heap_3 \u2693\ufe0e This method implements simple wrapper for standard C library malloc() and free() ; wrapper makes these functions thread safe, but makes code increase and not deterministic It uses linker heap region. The configTOTAL_HEAP_SIZE setting has no effect when this model is used Heap_3 method 1.4. Heap_4 \u2693\ufe0e This method uses first fit algorithm to allocate memory. It is able to combine adjacent free memory blocks into a single block . Heap_4 method The heap is organized as a linked list: for better efficiency when dynamically allocating/Freeing memory. As consequence when allocating N bytes in the heap memory using pvPortMalloc() API it consumes: Size of BlockLink_t (structure of the heap linked list) : 8 bytes. Data to be allocated itself : N bytes. Add padding to total allocated size (N + 8) to be 8 bytes aligned The memory array used by heap_4 is declared within heap_4.c file and its start address is configured by the linker automatically. To manually set the memory array address: Set configAPPLICATION_ALLOCATED_HEAP to 1 Declared a memory array: uint8_t ucHeap [ configTOTAL_HEAP_SIZE ] 1.5. Heap_5 \u2693\ufe0e The Fit algorithm in this method is able to combine adjacent free memory blocks into a single block using the same algorithms as in heap_4 , but supporting different memory regions (i.e. SRAM1, SRAM2) being not in linear memory space It is the only memory allocation scheme that must be explicitly initialized before any OS object can be created (before first call of pvPortMalloc() ). Application specifies start address and size of each separate memory area. Lower address appears in the array first To initialize this scheme, vPortDefineHeapRegions() function should be called. An example for STM32L476 device with SRAM1 and SRAM2 areas: #define SRAM1_OS_START (uint8_t *)0x2000 1000 #define SRAM1_OS_SIZE 0x0800 //2kB #define SRAM2_OS_START (uint8_t *)0x1000 0000 #define SRAM2_OS_SIZE 0x1000 //4kB /* Define */ Const HeapRegion_t xHeapRegions [] = { { SRAM2_OS_START , SRAM2_OS_SIZE }, { SRAM1_OS_START , SRAM1_OS_SIZE }, { NULL , 0 } /*terminates the array*/ } /* Initialize */ vPortDefineHeapRegions ( HeapRegions ); 2. Manual allocation \u2693\ufe0e There is an option to use alternative functions for memory management, however it is not recommended (inefficient) way of operation: void StartTask1 ( void const * argument ) { /* USER CODE BEGIN 5 */ osPoolDef ( Memory , 0x100 , uint8_t ); PoolHandle = osPoolCreate ( osPool ( Memory )); uint8_t * buffer = osPoolAlloc ( PoolHandle ); /* Infinite loop */ for (;;) { osDelay ( 5000 ); } /* USER CODE END 5 */ }","title":"Memory"},{"location":"blog/stm32/free-rtos/memory/#1-dynamic-memory-management","text":"FreeRTOS uses a region of memory called Heap (into the RAM) to allocate memory for tasks, queues, timers, semaphores, mutexes and when dynamically creating variables. FreeRTOS heap is different from the system heap defined at the compiler level. Memory Heap in RTOS When FreeRTOS requires RAM, instead of calling the standard malloc() , it calls PvPortMalloc() . When it needs to free memory it calls PvPortFree() instead of the standard free() . FreeRTOS offers several heap management schemes that range in complexity and features. The FreeRTOS download includes five sample memory allocation implementations, each of which are described in the following subsections. The subsections also include information on when each of the provided implementations might be the most appropriate to select. Heap management schemes: heap_1 \u2014 the very simplest, does not permit memory to be freed. heap_2 \u2014 permits memory to be freed, but does not coalescence adjacent free blocks. heap_3 \u2014 simply wraps the standard malloc() and free() for thread safety. heap_4 \u2014 coalescence adjacent free blocks to avoid fragmentation. Includes absolute address placement option. heap_5 \u2014 as per heap_4 , with the ability to span the heap across multiple non-adjacent memory areas. Notes: heap_1 is less useful since FreeRTOS added support for static allocation. heap_2 is now considered legacy as the newer heap_4 implementation is preferred.","title":"1. Dynamic Memory Management"},{"location":"blog/stm32/free-rtos/memory/#11-heap_1","text":"This implementation uses first fit algorithm to allocate memory. It is the simplest allocation method (deterministic), but does not allow freeing of allocated memory. This could be interesting when no memory freeing is necessary. Heap_1 method","title":"1.1. Heap_1"},{"location":"blog/stm32/free-rtos/memory/#12-heap_2","text":"This implementation is not recommended to new projects. It\u2019s kept due to backward compatibility. This method implements the best fit algorithm for allocation. It allows memory free() operation but doesn\u2019t combine adjacent free blocks. This method has risk of fragmentation. Heap_2 method","title":"1.2. Heap_2"},{"location":"blog/stm32/free-rtos/memory/#13-heap_3","text":"This method implements simple wrapper for standard C library malloc() and free() ; wrapper makes these functions thread safe, but makes code increase and not deterministic It uses linker heap region. The configTOTAL_HEAP_SIZE setting has no effect when this model is used Heap_3 method","title":"1.3. Heap_3"},{"location":"blog/stm32/free-rtos/memory/#14-heap_4","text":"This method uses first fit algorithm to allocate memory. It is able to combine adjacent free memory blocks into a single block . Heap_4 method The heap is organized as a linked list: for better efficiency when dynamically allocating/Freeing memory. As consequence when allocating N bytes in the heap memory using pvPortMalloc() API it consumes: Size of BlockLink_t (structure of the heap linked list) : 8 bytes. Data to be allocated itself : N bytes. Add padding to total allocated size (N + 8) to be 8 bytes aligned The memory array used by heap_4 is declared within heap_4.c file and its start address is configured by the linker automatically. To manually set the memory array address: Set configAPPLICATION_ALLOCATED_HEAP to 1 Declared a memory array: uint8_t ucHeap [ configTOTAL_HEAP_SIZE ]","title":"1.4. Heap_4"},{"location":"blog/stm32/free-rtos/memory/#15-heap_5","text":"The Fit algorithm in this method is able to combine adjacent free memory blocks into a single block using the same algorithms as in heap_4 , but supporting different memory regions (i.e. SRAM1, SRAM2) being not in linear memory space It is the only memory allocation scheme that must be explicitly initialized before any OS object can be created (before first call of pvPortMalloc() ). Application specifies start address and size of each separate memory area. Lower address appears in the array first To initialize this scheme, vPortDefineHeapRegions() function should be called. An example for STM32L476 device with SRAM1 and SRAM2 areas: #define SRAM1_OS_START (uint8_t *)0x2000 1000 #define SRAM1_OS_SIZE 0x0800 //2kB #define SRAM2_OS_START (uint8_t *)0x1000 0000 #define SRAM2_OS_SIZE 0x1000 //4kB /* Define */ Const HeapRegion_t xHeapRegions [] = { { SRAM2_OS_START , SRAM2_OS_SIZE }, { SRAM1_OS_START , SRAM1_OS_SIZE }, { NULL , 0 } /*terminates the array*/ } /* Initialize */ vPortDefineHeapRegions ( HeapRegions );","title":"1.5. Heap_5"},{"location":"blog/stm32/free-rtos/memory/#2-manual-allocation","text":"There is an option to use alternative functions for memory management, however it is not recommended (inefficient) way of operation: void StartTask1 ( void const * argument ) { /* USER CODE BEGIN 5 */ osPoolDef ( Memory , 0x100 , uint8_t ); PoolHandle = osPoolCreate ( osPool ( Memory )); uint8_t * buffer = osPoolAlloc ( PoolHandle ); /* Infinite loop */ for (;;) { osDelay ( 5000 ); } /* USER CODE END 5 */ }","title":"2. Manual allocation"},{"location":"blog/stm32/free-rtos/overview/","text":"F051R8_RTOS_Simple_Tasks.zip F411CE_RTOS_Simple_Tasks_SysView.zip 1. RTOS \u2693\ufe0e RTOS stands for Real Time Operating System. And as the name suggests, it is capable of doing tasks, as an operating system does. The main purpose of an OS is to have the functionality, of running multiple tasks at the same time, which obviously isn\u2019t possible with bare metal. The core of an RTOS is an advanced algorithm for scheduling , with the key factors are minimal interrupt latency and minimal thread switching latency . A real-time OS is valued more for how quickly or how predictably it can respond than for the amount of work it can perform in a given period of time. Refer to the comparison table of RTOSs . Kernel is the main core of an RTOS which manages tasks, memory, hardware access. The goal of a kernel is to make task runs concurrently in user point of view. In underlying works, kernel run tasks one by one, each task can run in some milliseconds and pause, leave CPU and hardware for other tasks. Task Execution The core of any preemptively multitasks system is context switching, in which a task can be halted, its context saved, and then later be restored, allowing it to continue execution. The context is defined primarily as the task\u2019s stack and the state of the processor registers. RTOS still is a normal C program Even the name RTOS is an Operating System, it is still a part of a single C program which starts from the only one main function. The only interesting point is that RTOS has a magic scheduler to switching tasks (loops). 1.1. A Task \u2693\ufe0e A task will do a specific functionality, such as toggling an LED, reading an input. The task function usually has an infinite loop, it means a task will continuously run and never returns. The Task Function is declared as: void taskFunctionName ( void * argument ) { for (;;) { // do things over and over } } In FreeRTOS, every task has its own stack that stores TCB (Task Control Block) and other stack-related operations while the task is being executed. It also stores processor context before a context switch (switching to other task). Stack size must be sufficient to accommodate all local variables and processor context. A Task has 4 states: inactive : not to be run ready : in queue to be run running : is being executed waiting/blocked : is paused, put in run queue, but not to be run in next time slot 1.2. The Scheduler \u2693\ufe0e This part of kernel decides which task will be run next. There are some rules to pick a task: Cooperative : task by task, each task does its work until it finishes Round-robin : each task has a time slice to run, there is no priority for task execution Priority-based : task has priority which has high number can interrupt the running task and takes place of execution Round-robin scheduler Priority-based scheduler 1.3. The SysTick \u2693\ufe0e SysTick is a part of the ARM Core, that counts down from the reload value to zero, and fire an interrupt to make a periodical event. SysTick is mainly used for delay function in non-RTOS firmware, and is used as the interrupt for RTOS scheduler. SysTick is also used as countable time span of a waiting task. For example, a task need to read an input, and it should wait for 50 ms, if nothing comes, task should move to other work. This task will use SysTick, which is fired every 1 ms, to count up a waiting counter, if the counter reaches 50 ticks, task quits the waiting loop and runs other code. Read more about setting up SysTick and Delay . 1.4. Memory Allocation \u2693\ufe0e Real time operating system supports static and dynamic memory allocation, with different strategies and algorithm. Creating RTOS objects dynamically has the benefit of greater simplicity, and the potential to minimize the application\u2019s maximum RAM usage: The memory allocation occurs automatically. The RAM used by an RTOS object can be re-used if the object is deleted. The memory allocation scheme used can be chosen to the best suite the application. Creating RTOS objects using statically allocated RAM has the benefit of providing the application more control: RTOS objects can be placed at specific memory locations. It allows the RTOS to be used in applications that simply don\u2019t allow any dynamic memory allocation. Avoid memory-related issues such as leak memory, dangling pointer, and undefined objects. Memory layout in FreeRTOS 1.5. Shared Memory \u2693\ufe0e Tasks are usually a work to do in a loop, and it thinks it can control all resource. In a system, there are many tasks run together, and in many cases, they work with condition from others. Inter-task communication is defined as some type: Signal: tell other task to start doing something, to synchronize tasks Message Queue/Mailbox: send data between tasks Mutex/Semaphore: synchronize access to a shared resource, lock resource which is in-use Queue between tasks Signal between tasks Shared resource between tasks 2. FreeRTOS for STM32 \u2693\ufe0e In the STM32 CubeHAL firmware solution, FreeRTOS is used as a real time operating system through the generic CMSIS-OS wrapping layer provided by ARM. Examples and applications using the FreeRTOS can be directly ported on any other RTOS without modifying the high level APIs, only the CMSIS-OS wrapper has to be changed in this case. 2.1. Main features \u2693\ufe0e Preemptive or cooperative real-time kernel Tiny memory footprint (less than 10 KB ROM) and easy scalable Includes a tickless mode for low power applications Synchronization and inter-task communication using message queues binary and counting semaphores mutexes group events (flags) stream buffer Software timers for tasks scheduling Execution trace functionality CMSIS-RTOS API port 2.2. Used resources \u2693\ufe0e Core resources: System timer ( SysTick ) \u2014 generate system time (time slice) Two stack pointers: MSP, PSP Interrupt vectors: SVC \u2014 system service call (like SWI in ARM7) PendSV \u2014 pended system call (switching context) SysTick \u2014 System Timer Memory: Flash: 6-10 KB Flash + RAM memory: 0.5 KB + task stacks 2.3. File structure \u2693\ufe0e File Description task.c ask functions and utilities definition list.c List implementation used by the scheduler queue.c Queue implementation used by tasks timers.c Software timers functions definition port.c Low level functions supporting SysTick timer, context switch, interrupt management on low HW level \u2014 strongly depends on the platform (core and SW tool set). Mostly written in assembly FreeRTOS.h Configuration file which collect whole FreeRTOS sources FreeRTOSConfig.h Configuration of FreeRTOS system, system clock and IRQ parameters configuration heap_x.c Different implementation of dynamic memory management coroutine.c Co-routines functions definitions. Efficient in 8 and 16bit architecture. In 32bit architecture usage of tasks is suggested event_groups.c Flags to notify tasks about am event 2.4. Memory Management \u2693\ufe0e FreeRTOS uses a region of memory called Heap (into the RAM) to allocate memory for tasks, queues, timers, semaphores, mutexes and when dynamically creating variables. FreeRTOS heap is different from the system heap defined at the compiler level. When FreeRTOS requires RAM, instead of calling the standard malloc() , it calls PvPortMalloc() . When it needs to free memory it calls PvPortFree() instead of the standard free() . FreeRTOS offers several heap management schemes that range in complexity and features. The FreeRTOS download includes five sample memory allocation implementations, each of which are described in the following subsections. The subsections also include information on when each of the provided implementations might be the most appropriate to select. Heap management schemes: heap_1 \u2014 the very simplest, does not permit memory to be freed. heap_2 \u2014 permits memory to be freed, but does not coalescence adjacent free blocks. heap_3 \u2014 simply wraps the standard malloc() and free() for thread safety. heap_4 \u2014 coalescence adjacent free blocks to avoid fragmentation. Includes absolute address placement option. heap_5 \u2014 as per heap_4 , with the ability to span the heap across multiple non-adjacent memory areas. Notes: heap_1 is less useful since FreeRTOS added support for static allocation. heap_2 is now considered legacy as the newer heap_4 implementation is preferred. For more detail, refer to RTOS Memory Management . 2.5. Interrupts \u2693\ufe0e PendSV interrupt Used for task switching before tick rate Lowest NVIC interrupt priority Not triggered by any peripheral SVC interrupt Interrupt risen by SVC instruction SVC 0 call used only once, to start the scheduler (within vPortStartFirstTask() which is used to start the kernel) SysTick timer Lowest NVIC interrupt priority Used for task switching on configTICK_RATE_HZ regular time base Set PendSV if context switch is necessary 2.6. API conventions \u2693\ufe0e Prefixes at variable names: c \u2014 char / s \u2014 short / l \u2014 long / u \u2014 unsigned x \u2014 portBASE_TYPE defined in portmacro.h for each platform (in STM32 it is long) p \u2014 pointer Functions name structure: prefix + file name + function name . For example: vTaskPrioritySet() . Prefixes at macros defines their definition location and names. For example: portMAX_DELAY 2.7. General Configs \u2693\ufe0e Configuration options are declared in file FreeRTOSConfig.h . Important configuration options are: Config option Description configUSE_PREEMPTION Enables Preemption configCPU_CLOCK_HZ CPU clock frequency in Hz configTICK_RATE_HZ Tick rate in Hz configMAX_PRIORITIES Maximum task priority configTOTAL_HEAP_SIZE Total heap size for dynamic allocation configLIBRARY_LOWEST_INTERRUPT_PRIORITY The lowest interrupt priority (0xF when using 4 cortex preemption bits) configLIBRARY_MAX_SYSCALL_INTERRUPT_PRIORITY The highest thread safe interrupt priority (higher priorities are lower numeric value) If preemption is enabled , RTOS will use preemptive scheduling, otherwise, RTOS will use co-operative scheduling: Preemptive scheduling Co-operative scheduling The xPortGetFreeHeapSize() API function returns the total amount of heap space that remains unallocated (allowing the configTOTAL_HEAP_SIZE setting to be optimized). The total amount of heap space that remains unallocated is also available with xFreeBytesRemaining variable for heap management schemes 2 to 5. Each created task (including the idle task) requires a Task Control Block (TCB) and a stack that are allocated in the heap. The TCB size in bytes depends on the options enabled in the FreeRTOSConfig.h : With minimum configuration the TCB size is 24 words i.e. 96 bytes. If configUSE_TASK_NOTIFICATIONS enabled add 8 bytes (2 words) if configUSE_TRACE_FACILITY enabled add 8 bytes (2 words) if configUSE_MUTEXES enabled add 8 bytes (2 words). The task stack size is passed as argument when creating at task. The task stack size is defined in words of 32 bits not in bytes. Task Memory = TCB size + (4 x Task Stack size) . The configMINIMAL_STACK_SIZE defines the minimum stack size that can be used in words. The idle task stack size takes automatically this value. When Soft Timers are enabled ( configUSE_TIMERS enabled), the scheduler creates automatically the timers service task (daemon) when started. The timers service task is used to control and monitor (internally) all timers that the user will create. The scheduler also creates automatically a message queue used to send commands to the timers task (timer start, timer stop, etc.). The number of elements of a queue (number of messages that can be hold) are configurable through to define configTIMER_QUEUE_LENGTH . 2.8. CMSIS_OS API \u2693\ufe0e CMSIS-OS API is a generic RTOS interface for Cortex-M processor based devices. Implementation in file cmsis-os.c in \\Middlewares\\Third_Party\\FreeRTOS\\Source\\CMSIS_RTOS . Middleware components using the CMSIS-OS API are RTOS independent, this allows an easy linking to any third-party RTOS. The CMSIS-OS API defines a minimum feature set including Thread Management Kernel control Semaphore management Message queue and mail queue Memory management For detailed documents, refer to CMSIS-RTOS . 2.8.1. CMSIS_RTOS Wrapper \u2693\ufe0e API category CMSIS_RTOS API FreeRTOS API Kernel control osKernelStart vTaskStartScheduler Thread management osThreadCreate xTaskCreate Semaphore osSemaphoreCreate vSemaphoreCreateBinary , xSemaphoreCreateCounting Mutex osMutexWait xSemaphoreTake Message queue osMessagePut xQueueSend , xQueueSendFromISR Timer osTimerCreate xTimerCreate Most of the functions returns osStatus value, which allows checking whether the function is completed or there was some issue (defined in the cmsis_os.h file). Each OS component has its own ID: Tasks: osThreadId (mapped to TaskHandle_t within FreeRTOS API) Queues: osMessageQId (mapped to QueueHandle_t within FreeRTOS API) Semaphores: osSemaphoreId (mapped to SemaphoreHandle_t within FreeRTOS API) Mutexes: osMutexId (mapped to SemaphoreHandle_t within FreeRTOS API) SW timers: osTimerId (mapped to TimerHandle_t within FreeRTOS API) Delays and timeouts are given in ms: 0 \u2014 no delay >0 \u2014 delay in ms 0xFFFFFFFF \u2014 wait forever (defined in osWaitForever within cmsis_os.h file) 3. Lab 0: Create simple tasks \u2693\ufe0e Assume that an application intend to toggle two LEDs at 1 Second and 2 Second intervals respectively. Below is a bare-metal approach (without timers) of doing it: int main () { while ( 1 ) { LED1_TURN_ON (); LED2_TURN_ON (); delay_seconds ( 1 ); LED1_TURN_OFF (); delay_seconds ( 1 ); LED1_TURN_ON (); LED2_TURN_OFF (); delay_seconds ( 1 ); LED1_TURN_OFF (); delay_seconds ( 1 ); } return 0 ; } In this approach, a decision about LED states needs to be taken at an interval of the highest common factor of the delays (in the above example it is 1 second). It is cumbersome to design with this approach if the number of LEDs is large. Also, adding a newer LED (with a different blink rate) needs considerable re-work of the older code. Hence, this approach is not scalable. This lab guides to setup RTOS with 3 simple tasks to blink LEDs and read one input button. 3.1. Create a new project \u2693\ufe0e Start a new project and select a target MCU. After setting up the clock and basic pinouts, it is the time to select a timer for HAL time base. Select time base source for HAL functions 3.2. Enable RTOS \u2693\ufe0e Under the Pinout and Configuration tab, select the Middleware section and choose FreeRTOS . There are 2 versions of CMSIS wrapper: Version 1 and Version 2. The differences are listed in ARM document site . Note to enable the option USE_PREEMPTION . User can config some features of RTOS through a list of enabled definition. 3.3. Add Tasks \u2693\ufe0e Adding a task using IDE is very simple. In the tab Tasks and Queues , add 3 new tasks by filling some importance settings for a task: Task Name, Task Priority, Task Stack size, and Task Function. It is optional to set the Task Allocation mode, which is set to Dynamic as default. Enable RTOS version 10 with CMSIS V2 Add a new Task 3.4. RTOS components \u2693\ufe0e RTOS components After running code generation, there are some new folders and files added to the project. The RTOS Source code is located in the Middlewares folder which includes FreeRTOS core and CMSIS_RTOS wrapper. The core files of FreeRTOS are: task.c , timer.c , queue.c , list.c , etc. Note that, on a target hardware, FreeRTOS will include some specific files for that hardware only. In the demo project which uses F051R8 MCU, FreeRTOS will include ARM_CM0 porting files. All of the default configs for FreeRTOS are defined in the FreeRTOS.h . The Kernel settings in the IDE will be set in the FreeRTOSConfig.h file, and user can override default settings in this config file. In the main.c file, there are tasks created by IDE, such as the task Task_A below. Note that those functions are actually CMSIS wrappers which have the os prefix. /* Definitions for Task_A */ osThreadId_t Task_AHandle ; const osThreadAttr_t Task_A_attributes = { . name = \"Task_A\" , . stack_size = 64 * 4 , . priority = ( osPriority_t ) osPriorityNormal , }; /* Definition of the Task_A_Function */ void Task_A_Main ( void * argument ) { for (;;) { // loop forever osDelay ( 1 ); } } Finally, in the main() function, FreeRTOS kernel is initialized by calling osKernelInitialize() and each task will be created with function osThreadNew() such as below call for Task_A : Task_AHandle = osThreadNew ( Task_A_Main , NULL , & Task_A_attributes ); To start the OS, call osKernelStart() , and it will start a kernel loop to schedule the tasks. Implement tasks In this lab, there are 3 tasks: Task_C reads the button state every 100 ms void Task_C_Main ( void * argument ) { for (;;) { isButtonPressed = ( HAL_GPIO_ReadPin ( BUTTON_GPIO_Port , BUTTON_Pin ) == GPIO_PIN_SET ); osDelay ( 100 ); } } Task_A toggles the LED_A every 100 ms if button pressed void Task_C_Main ( void * argument ) { for (;;) { if ( isButtonPressed ) { HAL_GPIO_TogglePin ( LED_A_GPIO_PortLED_A_Pin ); } osDelay ( 100 ); } } Task_B toggles the LED_B every 100 ms if button is not pressed void Task_C_Main ( void * argument ) { for (;;) { if ( ! isButtonPressed ) { HAL_GPIO_TogglePin ( LED_B_GPIO_Port , LED_B_Pin ); } osDelay ( 100 ); } } That is enough to create 3 concurrent tasks. Let\u2019s run it and see how the LEDs and the button work. 3.5. The Idle Task \u2693\ufe0e When running in a debug session, CubeIDE supports to see the state of all tasks under FreeRTOS environment. To open it, click on Windows \u00bb Show View \u00bb FreeRTOS . There are 2 new tasks appearing in the list: IDLE and TmrSrv (Soft-Timer Service). Task List The idle task is created automatically when the RTOS scheduler is started to ensure there is always at least one task that is able to run. It is created at the lowest possible priority to ensure it does not use any CPU time if there are higher priority application tasks in the ready state. The idle task is responsible for freeing memory allocated by the RTOS to tasks that have since been deleted. It is therefore important in applications that make use of the vTaskDelete() function to ensure the idle task is not starved of processing time. The idle task has no other active functions so can legitimately be starved of microcontroller time under all other conditions. The Idle Task Hook : An idle task hook is a function that is called during each cycle of the idle task. It is common to use the idle hook function to place the microcontroller CPU into a power saving mode. 3.6. The Timer Service \u2693\ufe0e There is a dedicated Tmr Svc (Timer Service or Daemon) task that maintains an ordered list of Software Timers , with the timer to expire next in front of the list. The Timer Service task is not continuously running: from the Timer List, the task knows the time when it has to wake up each time a timer in the timer list has expired. When a timer has expired, the Timer Service task calls its callback (the Timer callback). A Software Timer Lets modified the Lab 0 a bit: Task_A and Task_B toggle their LEDs be default If user presses on the button, Task_C will block LED toggling After 5 seconds, system will unlock LED toggling During 5 seconds, if user presses on the button again, the 5-second period is restarted Create a Software Timer Here are generated code for this Soft Timer: osTimerId_t Timer5sHandle ; const osTimerAttr_t Timer5s_attributes = { . name = \"Timer5s\" }; void Timer5sCallback ( void * argument ) { /* add code here */ } int main () { Timer5sHandle = osTimerNew ( Timer5sCallback , osTimerOnce , NULL , & Timer5s_attributes ); } And here is the modified work of the Task_C : void Task_C_Main ( void * argument ){ for (;;) { if ( HAL_GPIO_ReadPin ( BUTTON_GPIO_Port , BUTTON_Pin ) == GPIO_PIN_SET ) { isButtonPressed = 1 ; osTimerStart ( Timer5sHandle , 5000 ); } osDelay ( 100 ); } } void Timer5sCallback ( void * argument ) { isButtonPressed = 0 ; } When debugging, Soft timers are listed in the FreeRTOS Timers list, and Tmr Srv will be executed when one of soft timers reaches to its configured period counter. Software Timer and the Timer Service status","title":"FreeRTOS"},{"location":"blog/stm32/free-rtos/overview/#1-rtos","text":"RTOS stands for Real Time Operating System. And as the name suggests, it is capable of doing tasks, as an operating system does. The main purpose of an OS is to have the functionality, of running multiple tasks at the same time, which obviously isn\u2019t possible with bare metal. The core of an RTOS is an advanced algorithm for scheduling , with the key factors are minimal interrupt latency and minimal thread switching latency . A real-time OS is valued more for how quickly or how predictably it can respond than for the amount of work it can perform in a given period of time. Refer to the comparison table of RTOSs . Kernel is the main core of an RTOS which manages tasks, memory, hardware access. The goal of a kernel is to make task runs concurrently in user point of view. In underlying works, kernel run tasks one by one, each task can run in some milliseconds and pause, leave CPU and hardware for other tasks. Task Execution The core of any preemptively multitasks system is context switching, in which a task can be halted, its context saved, and then later be restored, allowing it to continue execution. The context is defined primarily as the task\u2019s stack and the state of the processor registers. RTOS still is a normal C program Even the name RTOS is an Operating System, it is still a part of a single C program which starts from the only one main function. The only interesting point is that RTOS has a magic scheduler to switching tasks (loops).","title":"1. RTOS"},{"location":"blog/stm32/free-rtos/overview/#11-a-task","text":"A task will do a specific functionality, such as toggling an LED, reading an input. The task function usually has an infinite loop, it means a task will continuously run and never returns. The Task Function is declared as: void taskFunctionName ( void * argument ) { for (;;) { // do things over and over } } In FreeRTOS, every task has its own stack that stores TCB (Task Control Block) and other stack-related operations while the task is being executed. It also stores processor context before a context switch (switching to other task). Stack size must be sufficient to accommodate all local variables and processor context. A Task has 4 states: inactive : not to be run ready : in queue to be run running : is being executed waiting/blocked : is paused, put in run queue, but not to be run in next time slot","title":"1.1. A Task"},{"location":"blog/stm32/free-rtos/overview/#12-the-scheduler","text":"This part of kernel decides which task will be run next. There are some rules to pick a task: Cooperative : task by task, each task does its work until it finishes Round-robin : each task has a time slice to run, there is no priority for task execution Priority-based : task has priority which has high number can interrupt the running task and takes place of execution Round-robin scheduler Priority-based scheduler","title":"1.2. The Scheduler"},{"location":"blog/stm32/free-rtos/overview/#13-the-systick","text":"SysTick is a part of the ARM Core, that counts down from the reload value to zero, and fire an interrupt to make a periodical event. SysTick is mainly used for delay function in non-RTOS firmware, and is used as the interrupt for RTOS scheduler. SysTick is also used as countable time span of a waiting task. For example, a task need to read an input, and it should wait for 50 ms, if nothing comes, task should move to other work. This task will use SysTick, which is fired every 1 ms, to count up a waiting counter, if the counter reaches 50 ticks, task quits the waiting loop and runs other code. Read more about setting up SysTick and Delay .","title":"1.3. The SysTick"},{"location":"blog/stm32/free-rtos/overview/#14-memory-allocation","text":"Real time operating system supports static and dynamic memory allocation, with different strategies and algorithm. Creating RTOS objects dynamically has the benefit of greater simplicity, and the potential to minimize the application\u2019s maximum RAM usage: The memory allocation occurs automatically. The RAM used by an RTOS object can be re-used if the object is deleted. The memory allocation scheme used can be chosen to the best suite the application. Creating RTOS objects using statically allocated RAM has the benefit of providing the application more control: RTOS objects can be placed at specific memory locations. It allows the RTOS to be used in applications that simply don\u2019t allow any dynamic memory allocation. Avoid memory-related issues such as leak memory, dangling pointer, and undefined objects. Memory layout in FreeRTOS","title":"1.4. Memory Allocation"},{"location":"blog/stm32/free-rtos/overview/#15-shared-memory","text":"Tasks are usually a work to do in a loop, and it thinks it can control all resource. In a system, there are many tasks run together, and in many cases, they work with condition from others. Inter-task communication is defined as some type: Signal: tell other task to start doing something, to synchronize tasks Message Queue/Mailbox: send data between tasks Mutex/Semaphore: synchronize access to a shared resource, lock resource which is in-use Queue between tasks Signal between tasks Shared resource between tasks","title":"1.5. Shared Memory"},{"location":"blog/stm32/free-rtos/overview/#2-freertos-for-stm32","text":"In the STM32 CubeHAL firmware solution, FreeRTOS is used as a real time operating system through the generic CMSIS-OS wrapping layer provided by ARM. Examples and applications using the FreeRTOS can be directly ported on any other RTOS without modifying the high level APIs, only the CMSIS-OS wrapper has to be changed in this case.","title":"2. FreeRTOS for STM32"},{"location":"blog/stm32/free-rtos/overview/#21-main-features","text":"Preemptive or cooperative real-time kernel Tiny memory footprint (less than 10 KB ROM) and easy scalable Includes a tickless mode for low power applications Synchronization and inter-task communication using message queues binary and counting semaphores mutexes group events (flags) stream buffer Software timers for tasks scheduling Execution trace functionality CMSIS-RTOS API port","title":"2.1. Main features"},{"location":"blog/stm32/free-rtos/overview/#22-used-resources","text":"Core resources: System timer ( SysTick ) \u2014 generate system time (time slice) Two stack pointers: MSP, PSP Interrupt vectors: SVC \u2014 system service call (like SWI in ARM7) PendSV \u2014 pended system call (switching context) SysTick \u2014 System Timer Memory: Flash: 6-10 KB Flash + RAM memory: 0.5 KB + task stacks","title":"2.2. Used resources"},{"location":"blog/stm32/free-rtos/overview/#23-file-structure","text":"File Description task.c ask functions and utilities definition list.c List implementation used by the scheduler queue.c Queue implementation used by tasks timers.c Software timers functions definition port.c Low level functions supporting SysTick timer, context switch, interrupt management on low HW level \u2014 strongly depends on the platform (core and SW tool set). Mostly written in assembly FreeRTOS.h Configuration file which collect whole FreeRTOS sources FreeRTOSConfig.h Configuration of FreeRTOS system, system clock and IRQ parameters configuration heap_x.c Different implementation of dynamic memory management coroutine.c Co-routines functions definitions. Efficient in 8 and 16bit architecture. In 32bit architecture usage of tasks is suggested event_groups.c Flags to notify tasks about am event","title":"2.3. File structure"},{"location":"blog/stm32/free-rtos/overview/#24-memory-management","text":"FreeRTOS uses a region of memory called Heap (into the RAM) to allocate memory for tasks, queues, timers, semaphores, mutexes and when dynamically creating variables. FreeRTOS heap is different from the system heap defined at the compiler level. When FreeRTOS requires RAM, instead of calling the standard malloc() , it calls PvPortMalloc() . When it needs to free memory it calls PvPortFree() instead of the standard free() . FreeRTOS offers several heap management schemes that range in complexity and features. The FreeRTOS download includes five sample memory allocation implementations, each of which are described in the following subsections. The subsections also include information on when each of the provided implementations might be the most appropriate to select. Heap management schemes: heap_1 \u2014 the very simplest, does not permit memory to be freed. heap_2 \u2014 permits memory to be freed, but does not coalescence adjacent free blocks. heap_3 \u2014 simply wraps the standard malloc() and free() for thread safety. heap_4 \u2014 coalescence adjacent free blocks to avoid fragmentation. Includes absolute address placement option. heap_5 \u2014 as per heap_4 , with the ability to span the heap across multiple non-adjacent memory areas. Notes: heap_1 is less useful since FreeRTOS added support for static allocation. heap_2 is now considered legacy as the newer heap_4 implementation is preferred. For more detail, refer to RTOS Memory Management .","title":"2.4. Memory Management"},{"location":"blog/stm32/free-rtos/overview/#25-interrupts","text":"PendSV interrupt Used for task switching before tick rate Lowest NVIC interrupt priority Not triggered by any peripheral SVC interrupt Interrupt risen by SVC instruction SVC 0 call used only once, to start the scheduler (within vPortStartFirstTask() which is used to start the kernel) SysTick timer Lowest NVIC interrupt priority Used for task switching on configTICK_RATE_HZ regular time base Set PendSV if context switch is necessary","title":"2.5. Interrupts"},{"location":"blog/stm32/free-rtos/overview/#26-api-conventions","text":"Prefixes at variable names: c \u2014 char / s \u2014 short / l \u2014 long / u \u2014 unsigned x \u2014 portBASE_TYPE defined in portmacro.h for each platform (in STM32 it is long) p \u2014 pointer Functions name structure: prefix + file name + function name . For example: vTaskPrioritySet() . Prefixes at macros defines their definition location and names. For example: portMAX_DELAY","title":"2.6. API conventions"},{"location":"blog/stm32/free-rtos/overview/#27-general-configs","text":"Configuration options are declared in file FreeRTOSConfig.h . Important configuration options are: Config option Description configUSE_PREEMPTION Enables Preemption configCPU_CLOCK_HZ CPU clock frequency in Hz configTICK_RATE_HZ Tick rate in Hz configMAX_PRIORITIES Maximum task priority configTOTAL_HEAP_SIZE Total heap size for dynamic allocation configLIBRARY_LOWEST_INTERRUPT_PRIORITY The lowest interrupt priority (0xF when using 4 cortex preemption bits) configLIBRARY_MAX_SYSCALL_INTERRUPT_PRIORITY The highest thread safe interrupt priority (higher priorities are lower numeric value) If preemption is enabled , RTOS will use preemptive scheduling, otherwise, RTOS will use co-operative scheduling: Preemptive scheduling Co-operative scheduling The xPortGetFreeHeapSize() API function returns the total amount of heap space that remains unallocated (allowing the configTOTAL_HEAP_SIZE setting to be optimized). The total amount of heap space that remains unallocated is also available with xFreeBytesRemaining variable for heap management schemes 2 to 5. Each created task (including the idle task) requires a Task Control Block (TCB) and a stack that are allocated in the heap. The TCB size in bytes depends on the options enabled in the FreeRTOSConfig.h : With minimum configuration the TCB size is 24 words i.e. 96 bytes. If configUSE_TASK_NOTIFICATIONS enabled add 8 bytes (2 words) if configUSE_TRACE_FACILITY enabled add 8 bytes (2 words) if configUSE_MUTEXES enabled add 8 bytes (2 words). The task stack size is passed as argument when creating at task. The task stack size is defined in words of 32 bits not in bytes. Task Memory = TCB size + (4 x Task Stack size) . The configMINIMAL_STACK_SIZE defines the minimum stack size that can be used in words. The idle task stack size takes automatically this value. When Soft Timers are enabled ( configUSE_TIMERS enabled), the scheduler creates automatically the timers service task (daemon) when started. The timers service task is used to control and monitor (internally) all timers that the user will create. The scheduler also creates automatically a message queue used to send commands to the timers task (timer start, timer stop, etc.). The number of elements of a queue (number of messages that can be hold) are configurable through to define configTIMER_QUEUE_LENGTH .","title":"2.7. General Configs"},{"location":"blog/stm32/free-rtos/overview/#28-cmsis_os-api","text":"CMSIS-OS API is a generic RTOS interface for Cortex-M processor based devices. Implementation in file cmsis-os.c in \\Middlewares\\Third_Party\\FreeRTOS\\Source\\CMSIS_RTOS . Middleware components using the CMSIS-OS API are RTOS independent, this allows an easy linking to any third-party RTOS. The CMSIS-OS API defines a minimum feature set including Thread Management Kernel control Semaphore management Message queue and mail queue Memory management For detailed documents, refer to CMSIS-RTOS .","title":"2.8. CMSIS_OS API"},{"location":"blog/stm32/free-rtos/overview/#281-cmsis_rtos-wrapper","text":"API category CMSIS_RTOS API FreeRTOS API Kernel control osKernelStart vTaskStartScheduler Thread management osThreadCreate xTaskCreate Semaphore osSemaphoreCreate vSemaphoreCreateBinary , xSemaphoreCreateCounting Mutex osMutexWait xSemaphoreTake Message queue osMessagePut xQueueSend , xQueueSendFromISR Timer osTimerCreate xTimerCreate Most of the functions returns osStatus value, which allows checking whether the function is completed or there was some issue (defined in the cmsis_os.h file). Each OS component has its own ID: Tasks: osThreadId (mapped to TaskHandle_t within FreeRTOS API) Queues: osMessageQId (mapped to QueueHandle_t within FreeRTOS API) Semaphores: osSemaphoreId (mapped to SemaphoreHandle_t within FreeRTOS API) Mutexes: osMutexId (mapped to SemaphoreHandle_t within FreeRTOS API) SW timers: osTimerId (mapped to TimerHandle_t within FreeRTOS API) Delays and timeouts are given in ms: 0 \u2014 no delay >0 \u2014 delay in ms 0xFFFFFFFF \u2014 wait forever (defined in osWaitForever within cmsis_os.h file)","title":"2.8.1. CMSIS_RTOS Wrapper"},{"location":"blog/stm32/free-rtos/overview/#3-lab-0-create-simple-tasks","text":"Assume that an application intend to toggle two LEDs at 1 Second and 2 Second intervals respectively. Below is a bare-metal approach (without timers) of doing it: int main () { while ( 1 ) { LED1_TURN_ON (); LED2_TURN_ON (); delay_seconds ( 1 ); LED1_TURN_OFF (); delay_seconds ( 1 ); LED1_TURN_ON (); LED2_TURN_OFF (); delay_seconds ( 1 ); LED1_TURN_OFF (); delay_seconds ( 1 ); } return 0 ; } In this approach, a decision about LED states needs to be taken at an interval of the highest common factor of the delays (in the above example it is 1 second). It is cumbersome to design with this approach if the number of LEDs is large. Also, adding a newer LED (with a different blink rate) needs considerable re-work of the older code. Hence, this approach is not scalable. This lab guides to setup RTOS with 3 simple tasks to blink LEDs and read one input button.","title":"3. Lab 0: Create simple tasks"},{"location":"blog/stm32/free-rtos/overview/#31-create-a-new-project","text":"Start a new project and select a target MCU. After setting up the clock and basic pinouts, it is the time to select a timer for HAL time base. Select time base source for HAL functions","title":"3.1. Create a new project"},{"location":"blog/stm32/free-rtos/overview/#32-enable-rtos","text":"Under the Pinout and Configuration tab, select the Middleware section and choose FreeRTOS . There are 2 versions of CMSIS wrapper: Version 1 and Version 2. The differences are listed in ARM document site . Note to enable the option USE_PREEMPTION . User can config some features of RTOS through a list of enabled definition.","title":"3.2. Enable RTOS"},{"location":"blog/stm32/free-rtos/overview/#33-add-tasks","text":"Adding a task using IDE is very simple. In the tab Tasks and Queues , add 3 new tasks by filling some importance settings for a task: Task Name, Task Priority, Task Stack size, and Task Function. It is optional to set the Task Allocation mode, which is set to Dynamic as default. Enable RTOS version 10 with CMSIS V2 Add a new Task","title":"3.3. Add Tasks"},{"location":"blog/stm32/free-rtos/overview/#34-rtos-components","text":"RTOS components After running code generation, there are some new folders and files added to the project. The RTOS Source code is located in the Middlewares folder which includes FreeRTOS core and CMSIS_RTOS wrapper. The core files of FreeRTOS are: task.c , timer.c , queue.c , list.c , etc. Note that, on a target hardware, FreeRTOS will include some specific files for that hardware only. In the demo project which uses F051R8 MCU, FreeRTOS will include ARM_CM0 porting files. All of the default configs for FreeRTOS are defined in the FreeRTOS.h . The Kernel settings in the IDE will be set in the FreeRTOSConfig.h file, and user can override default settings in this config file. In the main.c file, there are tasks created by IDE, such as the task Task_A below. Note that those functions are actually CMSIS wrappers which have the os prefix. /* Definitions for Task_A */ osThreadId_t Task_AHandle ; const osThreadAttr_t Task_A_attributes = { . name = \"Task_A\" , . stack_size = 64 * 4 , . priority = ( osPriority_t ) osPriorityNormal , }; /* Definition of the Task_A_Function */ void Task_A_Main ( void * argument ) { for (;;) { // loop forever osDelay ( 1 ); } } Finally, in the main() function, FreeRTOS kernel is initialized by calling osKernelInitialize() and each task will be created with function osThreadNew() such as below call for Task_A : Task_AHandle = osThreadNew ( Task_A_Main , NULL , & Task_A_attributes ); To start the OS, call osKernelStart() , and it will start a kernel loop to schedule the tasks. Implement tasks In this lab, there are 3 tasks: Task_C reads the button state every 100 ms void Task_C_Main ( void * argument ) { for (;;) { isButtonPressed = ( HAL_GPIO_ReadPin ( BUTTON_GPIO_Port , BUTTON_Pin ) == GPIO_PIN_SET ); osDelay ( 100 ); } } Task_A toggles the LED_A every 100 ms if button pressed void Task_C_Main ( void * argument ) { for (;;) { if ( isButtonPressed ) { HAL_GPIO_TogglePin ( LED_A_GPIO_PortLED_A_Pin ); } osDelay ( 100 ); } } Task_B toggles the LED_B every 100 ms if button is not pressed void Task_C_Main ( void * argument ) { for (;;) { if ( ! isButtonPressed ) { HAL_GPIO_TogglePin ( LED_B_GPIO_Port , LED_B_Pin ); } osDelay ( 100 ); } } That is enough to create 3 concurrent tasks. Let\u2019s run it and see how the LEDs and the button work.","title":"3.4. RTOS components"},{"location":"blog/stm32/free-rtos/overview/#35-the-idle-task","text":"When running in a debug session, CubeIDE supports to see the state of all tasks under FreeRTOS environment. To open it, click on Windows \u00bb Show View \u00bb FreeRTOS . There are 2 new tasks appearing in the list: IDLE and TmrSrv (Soft-Timer Service). Task List The idle task is created automatically when the RTOS scheduler is started to ensure there is always at least one task that is able to run. It is created at the lowest possible priority to ensure it does not use any CPU time if there are higher priority application tasks in the ready state. The idle task is responsible for freeing memory allocated by the RTOS to tasks that have since been deleted. It is therefore important in applications that make use of the vTaskDelete() function to ensure the idle task is not starved of processing time. The idle task has no other active functions so can legitimately be starved of microcontroller time under all other conditions. The Idle Task Hook : An idle task hook is a function that is called during each cycle of the idle task. It is common to use the idle hook function to place the microcontroller CPU into a power saving mode.","title":"3.5. The Idle Task"},{"location":"blog/stm32/free-rtos/overview/#36-the-timer-service","text":"There is a dedicated Tmr Svc (Timer Service or Daemon) task that maintains an ordered list of Software Timers , with the timer to expire next in front of the list. The Timer Service task is not continuously running: from the Timer List, the task knows the time when it has to wake up each time a timer in the timer list has expired. When a timer has expired, the Timer Service task calls its callback (the Timer callback). A Software Timer Lets modified the Lab 0 a bit: Task_A and Task_B toggle their LEDs be default If user presses on the button, Task_C will block LED toggling After 5 seconds, system will unlock LED toggling During 5 seconds, if user presses on the button again, the 5-second period is restarted Create a Software Timer Here are generated code for this Soft Timer: osTimerId_t Timer5sHandle ; const osTimerAttr_t Timer5s_attributes = { . name = \"Timer5s\" }; void Timer5sCallback ( void * argument ) { /* add code here */ } int main () { Timer5sHandle = osTimerNew ( Timer5sCallback , osTimerOnce , NULL , & Timer5s_attributes ); } And here is the modified work of the Task_C : void Task_C_Main ( void * argument ){ for (;;) { if ( HAL_GPIO_ReadPin ( BUTTON_GPIO_Port , BUTTON_Pin ) == GPIO_PIN_SET ) { isButtonPressed = 1 ; osTimerStart ( Timer5sHandle , 5000 ); } osDelay ( 100 ); } } void Timer5sCallback ( void * argument ) { isButtonPressed = 0 ; } When debugging, Soft timers are listed in the FreeRTOS Timers list, and Tmr Srv will be executed when one of soft timers reaches to its configured period counter. Software Timer and the Timer Service status","title":"3.6. The Timer Service"},{"location":"blog/stm32/free-rtos/reentrant/","text":"F411CE_FreeRTOS_Newlib_Reentrant.zip F411CE_FreeRTOS_heap_useNewlib.zip 1. Reentrant \u2693\ufe0e Reentrant is an attribute of a piece of code and basically means it can be re-entered by another execution flow, for example by an interrupt or by another task or thread. Generally speaking, a function produces output data based on some input data (though both are optional, in general). Shared data could be accessed by any function at any time. If data can be changed by any function (and none keep track of those changes), there is no guarantee to those that share a datum that that datum is the same as at any time before. Data has a characteristic called scope, which describes where in a program the data may be used. Data scope is either global (outside the scope of any function and with an indefinite extent) or local (created each time a function is called and destroyed upon exit). Local data is not shared by any routines, re-entering or not; therefore, it does not affect re-entrance. Global data is defined outside functions and can be accessed by more than one function, either in the form of global variables (data shared between all functions), or as static variables (data shared by all invocations of the same function). Reentrant is distinct from, but closely related to, thread-safety. A function can be thread-safe and still not reentrant. 1.1. Rules for reentrant \u2693\ufe0e Reentrant code may not hold any static or global non-constant data. Reentrant code may not modify itself. Reentrant code may not call non-reentrant computer programs or routines. 1.2. Examples \u2693\ufe0e Two functions below are reentrant: int f ( int i ) { return i + 2 ; } int g ( int i ) { return f ( i ) + 2 ; } However, if f() depends on non-constant global variable, both functions become non-reentrant, such as: int v = 1 ; int f ( int i ) { v += i ; return v ; } int g ( int i ) { return f ( i ) + 2 ; } Some functions are thread-safe, but not reentrant, such as below function. function() can be called by different threads without any problem. But, if the function is used in a reentrant interrupt handler and a second interrupt arises inside the function, the second routine will hang forever. int function () { mutex_lock (); // function body mutex_unlock (); } 2. Newlib implementation \u2693\ufe0e GNU ARM libraries use Newlib to provide standard implementation of C libraries. However, to reduce the code size and make it independent to hardware, there is a lightweight version Newlib-nano used in MCUs. The Newlib library maps standard C functions to a specific implementation environment through a chain of functions, for example: write() invokes _write_r() with the current reentrant context (e.g. thread/task-unique errno); _write_r() invokes _write() and copies errno appropriately; _write() must be provided by something. By default, The Newlib-nano library does not provide an implementation of low-level system calls which are used by C standard libraries, such as _write() or _read() . To make the application compilable, a new library named nosys (enabled with -specs=nosys.specs to the gcc linker command line) should be added. This library just provide a simple implementation of low-level system calls which mostly return a by-pass value.CubeMX, with nosys , will generate syscalls.c and sysmem.c to provide low-level implementation for Newlib-nano interface: Function and data object definitions : char ** environ ; int _chown ( const char * path , uid_t owner , gid_t group ); int_execve ( const char * filename , char * const argv [], char * const envp []); pid_t _fork ( void ); pid_t _getpid ( void ); int _gettimeofday ( struct timeval * tv , struct timezone * tz ); int _kill ( pid_t pid , int sig ); int _link ( const char * oldpath , const char * newpath ); ssize_t _readlink ( const char * path , char * buf , size_t bufsiz ); int _stat ( const char * path , struct stat * buf ); int _symlink ( const char * oldpath , const char * newpath ); clock_t _times ( struct tms * buf ); int _unlink ( const char * pathname ); pid_t _wait ( int * status ); void _exit ( int status ); File Descriptor Operations : int _close ( int fd ); int _fstat ( int fd , struct stat * buf ); int _isatty ( int fd ); off_t _lseek ( int fd , off_t offset , int whence ); int _open ( const char * pathname , int flags ); ssize_t _read ( int fd , void * buf , size_t count ); ssize_t _write ( int fd , const void * buf , size_t count ); Heap Management : void * _sbrk ( ptrdiff_t increment ); 3. Newlib reentrant \u2693\ufe0e The Newlib library does support reentrant, but for Newlib-nano , the reentrant attribute depends on how its interfaces are implemented. The most concerned functions of reentrant support are malloc() and free() which directly are related to dynamic memory management. If these functions are not reentrant, the information of memory layout will be messed up if there are multiple calls to malloc() or free() at a time. Newlib maintains information it needs to support each separate context (thread/task/ISR) in a reentrant structure . This includes things like a thread-specific errno , thread-specific pointers to allocated buffers , etc. The active reentrant structure is pointed at by global pointer _impure_ptr , which initially points to a statically allocated structure instance. Newlib requires below things to complete its reentrant: Switching context. Multiple reentrant structures (one per context) must be created, initialized, cleaned and pointing upon _impure_ptr to the correct context each time the context is switching Concurrency protection. For example of using malloc() , it should be lock() and unlock() in that function to make it thread-safe first 4. FreeRTOS supports Newlib reentrant \u2693\ufe0e 4.1. Switching context \u2693\ufe0e FreeRTOS provides support for Newlib\u2019s context management. In FreeRTOSconfig.h , add: /* The following flag must be enabled only when using Newlib */ #define configUSE_NEWLIB_REENTRANT 1 Be default, STM32 projects generated by STM32CubeIDE use Newlib-nano . Whenever FreeRTOS is enabled, IDE will prompt to enable Newlib Reentrant attribute: A prompt asking to enable Newlib reentrant With this option configUSE_NEWLIB_REENTRANT = 1 , FreeRTOS does the following (in task.c ): For each task, allocate and initialize a Newlib reentrant structure in the task control block Each task switch, set _impure_ptr to point to the newly active task\u2019s reentrant structure On task destruction, clean up the reentrant structure (help Newlib free any associated memory) 4.2. Concurrency protection \u2693\ufe0e There is one more thing to fully support Newlib reentrant: FreeRTOS Memory Management. FreeRTOS internally uses its own memory management scheme with different heap management implementations in heapxx.c , such as heap_1 , or heap_4 . If an application only uses FreeRTOS-provided memory management APIs such as pvPortMalloc() and vPortFree() , this application is safe for Newlib reentrant, because FreeRTOS suspends the task-switching and interrupts during memory management . However, many third party libraries do use the standard C malloc() and free() functions. For those cases, the Concurrency protection is not guaranteed. That is the reason that Dave Nadler implemented a new heap scheme for Newlib in FreeRTOS. Details in https://nadler.com/embedded/NewlibAndFreeRTOS.html . FreeRTOS in STM32CubeMX The FreeRTOS version shipped in STM32CubeMX does not fully resolve Memory Management for Newlib. Dave Nadler provides a version for STM32 at heap_useNewlib_ST.c . The usage will be covered in a below section. 5. Lab 0: Reentrant printf function \u2693\ufe0e This example project demonstrates an issue when using printf() function without reentrant enabled for Newlib in FreeRTOS. In that case, the data printed out is interrupted by different tasks. 5.1. Precondition \u2693\ufe0e Let\u2019s create a new FreeRTOS application using STM32CubeMX with below settings: Time base Source for HAL is moved to a general timer, such as TIM6 or TIM10, TIM11 An UART port is enabled, such as UART1 TX on the pin PA9 FreeRTOS is enabled with configs: CMSIS V2 is selected Memory Management Scheme is either heap_3 or heap_4 Newlib setting is USE_NEWLIB_REENTRANT = Disabled 5.2. Create 2 printing tasks \u2693\ufe0e Add 2 tasks: Task1 and Task2 which call to a same function PrintTask but with different input messages message1 and message2 . Note that two tasks have the same priority. Add 2 printing tasks 5.3. Define messages and print out \u2693\ufe0e Two different messages will be prepared. To make the issue happens, the length of messages will be chosen to be long enough, such as 128 bytes (comparing to 128 * 4 bytes of the task stack size). char * message1 = \"................................................................................................................................\" ; char * message2 = \"++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\" ; The function PrintTask() will print out a message along with the task name, the Reentrant config, an increasing counter to see new messages clearly. #include \"FreeRTOSConfig.h\" void PrintTask ( void * argument ) { char * name = pcTaskGetName ( NULL ); char * message = ( char * ) argument ; char counter = 0 ; /* Infinite loop */ for (;;) { printf ( \"%d %s: %03d %s \\r\\n \" , configUSE_NEWLIB_REENTRANT , name , counter ++ , message ); osDelay ( 500 ); } } A final step is to redirect printed data to an UART port, such as USART1 using the low-level _write() function: int _write ( int file , char * ptr , int len ) { // block write to UART if it is not ready while ( HAL_UART_GetState ( & huart1 ) != HAL_UART_STATE_READY ); HAL_StatusTypeDef hstatus ; hstatus = HAL_UART_Transmit ( & huart1 , ( uint8_t * ) ptr , len , HAL_MAX_DELAY ); if ( hstatus == HAL_OK ) { return len ; } else { return 0 ; } } 5.4. Compile and Run \u2693\ufe0e Build the project and run a target board, the output will be messed up as it can be seen that characters in the messages1 is printed in the line of the messages2 . 5.5. Turn on Newlib reentrant \u2693\ufe0e If set the configUSE_NEWLIB_REENTRANT = 1 , the issue will not happen! Different outputs on different reentrant settings 5.6. Debug and Analyze \u2693\ufe0e Enable RTOS Kernel Awareness feature to seen task information and call stack when system is suspended. Select RTOS kernel awareness feature 5.6.1. Non-reentrant \u2693\ufe0e Step 1 : Task 1 formats its output string. Step 2 : Task 1 starts printing the formatted string saved at the address pointed by the ptr pointer. Step 3 : Task 1 is suspended, Task 2 formats its output string. Due to non-reentrant, printf saves the formatted string at a fixed location \u2014 the same location of formatted string in Task 1, causing an overwritten data . Step 4 : Task 2 cannot print as it has to wait for a ready flag. Step 5 : Task 1 is reactivated after a SysTick interruption, and Task 1 continues printing but the content of the formatted string is overwritten when Task2 formats its string . Non-reentrant debug step 1 Non-reentrant debug step 2 Non-reentrant debug step 3 Non-reentrant debug step 4 Non-reentrant debug step 5 5.6.2. Reentrant \u2693\ufe0e When reentrant is enabled, each task has its own reentrant struct and uses its own stack for Newlib functions. As a result, there is no shared memory location used by both tasks, that avoid overwriting data. Task2 print stack Task1 print stack 6. Integrate Newlib memory scheme \u2693\ufe0e As mentioned above, Dave Nadler provides a version for STM32 at heap_useNewlib_ST.c . It is not officially supported by ST. A method to ensure thread-safe for malloc() and free() is to wrap Newlib malloc-like functions to use FreeRTOS\u2019s porting memory management functions. However, FreeRTOS heap implementations do not support realloc() . The heap_usNewlib_ST scheme choose another method to solve malloc-like functions\u2019 thread-safe. This memory scheme implements thread-safe for malloc() and free() in Newlib, and then overwrites FreeRTOS\u2019s memory function to use Newlib\u2019s functions. Here are step to integrate heap_usNewlib_ST into STM32 project: Exclude sysmem.c file from build. This file provides an implementation of _sbrk() which is used by malloc() Exclude FreeRTOS heap management such as heap_4.c which implements pvPortMalloc() and vPortFree() Include heap_useNewlib_ST.c to project. Define 2 configs below to support ISR stack check #define configISR_STACK_SIZE_WORDS (128) // DRN in WORDS, must be valid constant for assembler #define configSUPPORT_ISR_STACK_CHECK 1 // DRN initialize and check ISR stack Set reentrant support using #define configUSE_NEWLIB_REENTRANT 1 7. References \u2693\ufe0e FreeRTOS Memory Management: https://www.freertos.org/a00111.html Newlib interface: http://pabigot.github.io/bspacm/Newlib.html Newlib FreeRTOS Memory Management: https://nadler.com/embedded/NewlibAndFreeRTOS.html Thread-safe in C library: https://developer.arm.com/documentation/dui0492/i/the-c-and-c---libraries/thread-safe-c-library-functions","title":"Reentrant"},{"location":"blog/stm32/free-rtos/reentrant/#1-reentrant","text":"Reentrant is an attribute of a piece of code and basically means it can be re-entered by another execution flow, for example by an interrupt or by another task or thread. Generally speaking, a function produces output data based on some input data (though both are optional, in general). Shared data could be accessed by any function at any time. If data can be changed by any function (and none keep track of those changes), there is no guarantee to those that share a datum that that datum is the same as at any time before. Data has a characteristic called scope, which describes where in a program the data may be used. Data scope is either global (outside the scope of any function and with an indefinite extent) or local (created each time a function is called and destroyed upon exit). Local data is not shared by any routines, re-entering or not; therefore, it does not affect re-entrance. Global data is defined outside functions and can be accessed by more than one function, either in the form of global variables (data shared between all functions), or as static variables (data shared by all invocations of the same function). Reentrant is distinct from, but closely related to, thread-safety. A function can be thread-safe and still not reentrant.","title":"1. Reentrant"},{"location":"blog/stm32/free-rtos/reentrant/#11-rules-for-reentrant","text":"Reentrant code may not hold any static or global non-constant data. Reentrant code may not modify itself. Reentrant code may not call non-reentrant computer programs or routines.","title":"1.1. Rules for reentrant"},{"location":"blog/stm32/free-rtos/reentrant/#12-examples","text":"Two functions below are reentrant: int f ( int i ) { return i + 2 ; } int g ( int i ) { return f ( i ) + 2 ; } However, if f() depends on non-constant global variable, both functions become non-reentrant, such as: int v = 1 ; int f ( int i ) { v += i ; return v ; } int g ( int i ) { return f ( i ) + 2 ; } Some functions are thread-safe, but not reentrant, such as below function. function() can be called by different threads without any problem. But, if the function is used in a reentrant interrupt handler and a second interrupt arises inside the function, the second routine will hang forever. int function () { mutex_lock (); // function body mutex_unlock (); }","title":"1.2. Examples"},{"location":"blog/stm32/free-rtos/reentrant/#2-newlib-implementation","text":"GNU ARM libraries use Newlib to provide standard implementation of C libraries. However, to reduce the code size and make it independent to hardware, there is a lightweight version Newlib-nano used in MCUs. The Newlib library maps standard C functions to a specific implementation environment through a chain of functions, for example: write() invokes _write_r() with the current reentrant context (e.g. thread/task-unique errno); _write_r() invokes _write() and copies errno appropriately; _write() must be provided by something. By default, The Newlib-nano library does not provide an implementation of low-level system calls which are used by C standard libraries, such as _write() or _read() . To make the application compilable, a new library named nosys (enabled with -specs=nosys.specs to the gcc linker command line) should be added. This library just provide a simple implementation of low-level system calls which mostly return a by-pass value.CubeMX, with nosys , will generate syscalls.c and sysmem.c to provide low-level implementation for Newlib-nano interface: Function and data object definitions : char ** environ ; int _chown ( const char * path , uid_t owner , gid_t group ); int_execve ( const char * filename , char * const argv [], char * const envp []); pid_t _fork ( void ); pid_t _getpid ( void ); int _gettimeofday ( struct timeval * tv , struct timezone * tz ); int _kill ( pid_t pid , int sig ); int _link ( const char * oldpath , const char * newpath ); ssize_t _readlink ( const char * path , char * buf , size_t bufsiz ); int _stat ( const char * path , struct stat * buf ); int _symlink ( const char * oldpath , const char * newpath ); clock_t _times ( struct tms * buf ); int _unlink ( const char * pathname ); pid_t _wait ( int * status ); void _exit ( int status ); File Descriptor Operations : int _close ( int fd ); int _fstat ( int fd , struct stat * buf ); int _isatty ( int fd ); off_t _lseek ( int fd , off_t offset , int whence ); int _open ( const char * pathname , int flags ); ssize_t _read ( int fd , void * buf , size_t count ); ssize_t _write ( int fd , const void * buf , size_t count ); Heap Management : void * _sbrk ( ptrdiff_t increment );","title":"2. Newlib implementation"},{"location":"blog/stm32/free-rtos/reentrant/#3-newlib-reentrant","text":"The Newlib library does support reentrant, but for Newlib-nano , the reentrant attribute depends on how its interfaces are implemented. The most concerned functions of reentrant support are malloc() and free() which directly are related to dynamic memory management. If these functions are not reentrant, the information of memory layout will be messed up if there are multiple calls to malloc() or free() at a time. Newlib maintains information it needs to support each separate context (thread/task/ISR) in a reentrant structure . This includes things like a thread-specific errno , thread-specific pointers to allocated buffers , etc. The active reentrant structure is pointed at by global pointer _impure_ptr , which initially points to a statically allocated structure instance. Newlib requires below things to complete its reentrant: Switching context. Multiple reentrant structures (one per context) must be created, initialized, cleaned and pointing upon _impure_ptr to the correct context each time the context is switching Concurrency protection. For example of using malloc() , it should be lock() and unlock() in that function to make it thread-safe first","title":"3. Newlib reentrant"},{"location":"blog/stm32/free-rtos/reentrant/#4-freertos-supports-newlib-reentrant","text":"","title":"4. FreeRTOS supports Newlib reentrant"},{"location":"blog/stm32/free-rtos/reentrant/#41-switching-context","text":"FreeRTOS provides support for Newlib\u2019s context management. In FreeRTOSconfig.h , add: /* The following flag must be enabled only when using Newlib */ #define configUSE_NEWLIB_REENTRANT 1 Be default, STM32 projects generated by STM32CubeIDE use Newlib-nano . Whenever FreeRTOS is enabled, IDE will prompt to enable Newlib Reentrant attribute: A prompt asking to enable Newlib reentrant With this option configUSE_NEWLIB_REENTRANT = 1 , FreeRTOS does the following (in task.c ): For each task, allocate and initialize a Newlib reentrant structure in the task control block Each task switch, set _impure_ptr to point to the newly active task\u2019s reentrant structure On task destruction, clean up the reentrant structure (help Newlib free any associated memory)","title":"4.1. Switching context"},{"location":"blog/stm32/free-rtos/reentrant/#42-concurrency-protection","text":"There is one more thing to fully support Newlib reentrant: FreeRTOS Memory Management. FreeRTOS internally uses its own memory management scheme with different heap management implementations in heapxx.c , such as heap_1 , or heap_4 . If an application only uses FreeRTOS-provided memory management APIs such as pvPortMalloc() and vPortFree() , this application is safe for Newlib reentrant, because FreeRTOS suspends the task-switching and interrupts during memory management . However, many third party libraries do use the standard C malloc() and free() functions. For those cases, the Concurrency protection is not guaranteed. That is the reason that Dave Nadler implemented a new heap scheme for Newlib in FreeRTOS. Details in https://nadler.com/embedded/NewlibAndFreeRTOS.html . FreeRTOS in STM32CubeMX The FreeRTOS version shipped in STM32CubeMX does not fully resolve Memory Management for Newlib. Dave Nadler provides a version for STM32 at heap_useNewlib_ST.c . The usage will be covered in a below section.","title":"4.2. Concurrency protection"},{"location":"blog/stm32/free-rtos/reentrant/#5-lab-0-reentrant-printf-function","text":"This example project demonstrates an issue when using printf() function without reentrant enabled for Newlib in FreeRTOS. In that case, the data printed out is interrupted by different tasks.","title":"5. Lab 0: Reentrant printf function"},{"location":"blog/stm32/free-rtos/reentrant/#51-precondition","text":"Let\u2019s create a new FreeRTOS application using STM32CubeMX with below settings: Time base Source for HAL is moved to a general timer, such as TIM6 or TIM10, TIM11 An UART port is enabled, such as UART1 TX on the pin PA9 FreeRTOS is enabled with configs: CMSIS V2 is selected Memory Management Scheme is either heap_3 or heap_4 Newlib setting is USE_NEWLIB_REENTRANT = Disabled","title":"5.1. Precondition"},{"location":"blog/stm32/free-rtos/reentrant/#52-create-2-printing-tasks","text":"Add 2 tasks: Task1 and Task2 which call to a same function PrintTask but with different input messages message1 and message2 . Note that two tasks have the same priority. Add 2 printing tasks","title":"5.2. Create 2 printing tasks"},{"location":"blog/stm32/free-rtos/reentrant/#53-define-messages-and-print-out","text":"Two different messages will be prepared. To make the issue happens, the length of messages will be chosen to be long enough, such as 128 bytes (comparing to 128 * 4 bytes of the task stack size). char * message1 = \"................................................................................................................................\" ; char * message2 = \"++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\" ; The function PrintTask() will print out a message along with the task name, the Reentrant config, an increasing counter to see new messages clearly. #include \"FreeRTOSConfig.h\" void PrintTask ( void * argument ) { char * name = pcTaskGetName ( NULL ); char * message = ( char * ) argument ; char counter = 0 ; /* Infinite loop */ for (;;) { printf ( \"%d %s: %03d %s \\r\\n \" , configUSE_NEWLIB_REENTRANT , name , counter ++ , message ); osDelay ( 500 ); } } A final step is to redirect printed data to an UART port, such as USART1 using the low-level _write() function: int _write ( int file , char * ptr , int len ) { // block write to UART if it is not ready while ( HAL_UART_GetState ( & huart1 ) != HAL_UART_STATE_READY ); HAL_StatusTypeDef hstatus ; hstatus = HAL_UART_Transmit ( & huart1 , ( uint8_t * ) ptr , len , HAL_MAX_DELAY ); if ( hstatus == HAL_OK ) { return len ; } else { return 0 ; } }","title":"5.3. Define messages and print out"},{"location":"blog/stm32/free-rtos/reentrant/#54-compile-and-run","text":"Build the project and run a target board, the output will be messed up as it can be seen that characters in the messages1 is printed in the line of the messages2 .","title":"5.4. Compile and Run"},{"location":"blog/stm32/free-rtos/reentrant/#55-turn-on-newlib-reentrant","text":"If set the configUSE_NEWLIB_REENTRANT = 1 , the issue will not happen! Different outputs on different reentrant settings","title":"5.5. Turn on Newlib reentrant"},{"location":"blog/stm32/free-rtos/reentrant/#56-debug-and-analyze","text":"Enable RTOS Kernel Awareness feature to seen task information and call stack when system is suspended. Select RTOS kernel awareness feature","title":"5.6. Debug and Analyze"},{"location":"blog/stm32/free-rtos/reentrant/#561-non-reentrant","text":"Step 1 : Task 1 formats its output string. Step 2 : Task 1 starts printing the formatted string saved at the address pointed by the ptr pointer. Step 3 : Task 1 is suspended, Task 2 formats its output string. Due to non-reentrant, printf saves the formatted string at a fixed location \u2014 the same location of formatted string in Task 1, causing an overwritten data . Step 4 : Task 2 cannot print as it has to wait for a ready flag. Step 5 : Task 1 is reactivated after a SysTick interruption, and Task 1 continues printing but the content of the formatted string is overwritten when Task2 formats its string . Non-reentrant debug step 1 Non-reentrant debug step 2 Non-reentrant debug step 3 Non-reentrant debug step 4 Non-reentrant debug step 5","title":"5.6.1. Non-reentrant"},{"location":"blog/stm32/free-rtos/reentrant/#562-reentrant","text":"When reentrant is enabled, each task has its own reentrant struct and uses its own stack for Newlib functions. As a result, there is no shared memory location used by both tasks, that avoid overwriting data. Task2 print stack Task1 print stack","title":"5.6.2. Reentrant"},{"location":"blog/stm32/free-rtos/reentrant/#6-integrate-newlib-memory-scheme","text":"As mentioned above, Dave Nadler provides a version for STM32 at heap_useNewlib_ST.c . It is not officially supported by ST. A method to ensure thread-safe for malloc() and free() is to wrap Newlib malloc-like functions to use FreeRTOS\u2019s porting memory management functions. However, FreeRTOS heap implementations do not support realloc() . The heap_usNewlib_ST scheme choose another method to solve malloc-like functions\u2019 thread-safe. This memory scheme implements thread-safe for malloc() and free() in Newlib, and then overwrites FreeRTOS\u2019s memory function to use Newlib\u2019s functions. Here are step to integrate heap_usNewlib_ST into STM32 project: Exclude sysmem.c file from build. This file provides an implementation of _sbrk() which is used by malloc() Exclude FreeRTOS heap management such as heap_4.c which implements pvPortMalloc() and vPortFree() Include heap_useNewlib_ST.c to project. Define 2 configs below to support ISR stack check #define configISR_STACK_SIZE_WORDS (128) // DRN in WORDS, must be valid constant for assembler #define configSUPPORT_ISR_STACK_CHECK 1 // DRN initialize and check ISR stack Set reentrant support using #define configUSE_NEWLIB_REENTRANT 1","title":"6. Integrate Newlib memory scheme"},{"location":"blog/stm32/free-rtos/reentrant/#7-references","text":"FreeRTOS Memory Management: https://www.freertos.org/a00111.html Newlib interface: http://pabigot.github.io/bspacm/Newlib.html Newlib FreeRTOS Memory Management: https://nadler.com/embedded/NewlibAndFreeRTOS.html Thread-safe in C library: https://developer.arm.com/documentation/dui0492/i/the-c-and-c---libraries/thread-safe-c-library-functions","title":"7. References"},{"location":"blog/stm32/free-rtos/stack/","text":"F411CE_FreeRTOS_StackOverflow.zip 1. Lab 0: Task Stack Overflow \u2693\ufe0e Each task maintains its own stack. This is where function calls store parameters, and functions store its local variable. Let\u2019s create a new project that has only one task and this task continues printing a counter value to an UART port. 1.1. Precondition \u2693\ufe0e Let\u2019s create a new FreeRTOS application using STM32CubeMX with below settings: Time base Source for HAL is moved to a general timer, such as TIM6 or TIM10, TIM11 An UART port is enabled, such as UART1 TX on the pin PA9 An LED output which is used as the heartbeat of the system FreeRTOS is enabled with configs: CMSIS V2 is selected Only need the default task 1.2. Redirect printf to UART \u2693\ufe0e The simplest way is to overwrite the low-level _write() function. Refer to UART Redirection for a full version, but it is not necessary for this lab. int _write ( int file , char * ptr , int len ) { // block write to UART if it is not ready while ( HAL_UART_GetState ( & huart1 ) != HAL_UART_STATE_READY ); HAL_StatusTypeDef hstatus = HAL_UART_Transmit ( & huart1 , ( uint8_t * ) ptr , len , HAL_MAX_DELAY ); return ( hstatus == HAL_OK ? len : 0 ); } 1.3. The default task \u2693\ufe0e In this default task, there is counter variable which will be counted up and printed out in the task main loop. The LED will be toggled every 1 second to indicate that the default task is running. Let\u2019s implement this in a simple way: void StartDefaultTask ( void * argument ) { uint32_t counter = 0xbeefbeef ; /* Infinite loop */ for (;;) { HAL_GPIO_TogglePin ( LED_GPIO_Port , LED_Pin ); printf ( \"Counting, %lu %lu %lu %lu. No problem? \\r\\n \" , counter ++ , counter ++ , counter ++ , counter ++ ); osDelay ( 1000 ); } } 1.4. Compile and Run \u2693\ufe0e This simple project can be compiled and run successfully. Messages are printed out successfully 1.5. Check the task stack \u2693\ufe0e Be default, the minimum stack size of a FreeRTOS task is 128 Words (128 x 4 = 512 Bytes). The settings of the default task Set a breakpoint at the beginning of the main loop in the function StartDefaultTask() and read the structure of the default task control block by casting the pointer defaultTaskHandle to type of TCB_t* pointer in Live Expression view. Note the below things: The start address of the Stack is stored in pxStack The end address of the Stack is stored in pxEndOfStack The whole stack is filled in a pattern 0xA5A5A5A5 The stack will be consumed from the end of the start back to the start address. The stack should never reach the start address to avoid stack overflow . Memory view before stack overflow The task is initialized by the function prvInitialiseNewTask() which stores the task name, set priority, container lists, and finally, it prepares the task\u2019s stack. The top of the stack is initialized based on how stack size is defined. Usually, task stack is fixed, it means stack size is not growing, determined by portSTACK_GROWTH = -1 . The top the stack will be changed, because the stack will be filled with some task information used for the task switching. The current top of the tack when a function is running is saved in the PSP register. 1.6. Step over the print function \u2693\ufe0e Set a breakpoint right after the printf() function to check the stack after the message is printout to UART. Now, look at the value stored at the start address of the stack. It\u2019s changed! Moreover, 8 bytes beyond the stack boundary are also changed. Stack Overflow does really occur . Memory view after stack overflow How did it happen? An address can be added as a watch point, to check if that address is read, written. Select the start address of the stack and add its address to the watch list: Adding a watch point by monitoring what writes into this memory The printing function takes more than 1 ms to complete. The top of the stack of the default tasks is at 0x20000E50 , and a SysTick fires, the SysTick_Handler() ISR is called, causing it uses the current stack. The ISR consumes the stack and overwrites the stack boundary, going beyond the stack start address. It is stack overflow. Stack overflow occurs when SysTick ISR is called The good thing in this lab is there is no important bytes outside the default task\u2019s stack. After SysTick is handled, system still runs normally, without any problem. 2. Catching Stack Overflow \u2693\ufe0e Stack overflow is a very common cause of application instability. FreeRTOS therefore provides two optional mechanisms that can be used to assist in the detection and correction of just such an occurrence. The option used is configured using the configCHECK_FOR_STACK_OVERFLOW configuration constant. Note that these options are only available on architectures where the memory map is not segmented. Also, some processors could generate a fault or exception in response to a stack corruption before the FreeRTOS kernel overflow check can occur. The application must provide a stack overflow hook function: void vApplicationStackOverflowHook ( TaskHandle_t xTask , signed char * pcTaskName ); The xTask and pcTaskName parameters pass to the hook function the handle and name of the offending task respectively. Note however, depending on the severity of the overflow, these parameters could themselves be corrupted, in which case the pxCurrentTCB variable can be inspected directly. Stack overflow checking introduces a context switch overhead so its use is only recommended during the development or testing phases. In the function vTaskSwitchContext() , before switching to another task, the current task stack will be checked. The macro taskCHECK_FOR_STACK_OVERFLOW() will be called based on the stack overflow detection configuration. 2.1. Stack Overflow Detection \u2014 Method 1 \u2693\ufe0e This simple method check the Top of Stack is still in the stack range. The stack overflow hook function is called if the stack pointer contain a value that is outside the valid stack range. This method is quick but not guaranteed to catch all stack overflows. Set configCHECK_FOR_STACK_OVERFLOW to 1 to use this method. #if( ( configCHECK_FOR_STACK_OVERFLOW == 1 ) && ( portSTACK_GROWTH < 0 ) ) define taskCHECK_FOR_STACK_OVERFLOW () \\ /* Is the currently saved stack pointer within the stack limit? */ \\ if ( pxCurrentTCB -> pxTopOfStack <= pxCurrentTCB -> pxStack ) \\ { \\ vApplicationStackOverflowHook ( ( TaskHandle_t ) pxCurrentTCB , \\ pxCurrentTCB -> pcTaskName ); \\ } \\ #endif /* configCHECK_FOR_STACK_OVERFLOW == 1 */ 2.2. Stack Overflow Detection \u2014 Method 2 \u2693\ufe0e When a task is first created its stack is filled with a known value. When swapping a task out of the Running state the FreeRTOS kernel can check the last 16 bytes within the valid stack range to ensure that these known values have not been overwritten by the task or interrupt activity. The stack overflow hook function is called should any of these 16 bytes not remain at their initial value. This method is less efficient than method one, but still fairly fast. It is very likely to catch stack overflows but is still not guaranteed to catch all overflows. #if( ( configCHECK_FOR_STACK_OVERFLOW > 1 ) && ( portSTACK_GROWTH < 0 ) ) #define taskCHECK_FOR_STACK_OVERFLOW() \\ { \\ const uint32_t* const pulStack = (uint32_t*) pxCurrentTCB->pxStack; \\ const uint32_t ulCheckValue = (uint32_t 0xa5a5a5a5; \\ /* check if boundary bytes are changed? */ \\ if( ( pulStack[ 0 ] != ulCheckValue ) || \\ ( pulStack[ 1 ] != ulCheckValue ) || \\ ( pulStack[ 2 ] != ulCheckValue ) || \\ ( pulStack[ 3 ] != ulCheckValue ) ) \\ { \\ vApplicationStackOverflowHook((TaskHandle_t) pxCurrentTCB, \\ pxCurrentTCB->pcTaskName ); \\ } \\ } #endif /* #if( configCHECK_FOR_STACK_OVERFLOW > 1 ) */ 2.3. Trap the Stack Overflow \u2693\ufe0e Firstly, enable a method to detect Stack Overflow by setting the configCHECK_FOR_STACK_OVERFLOW config. Enable Stack Overflow detection In the hook (callback) function, it can call to a soft breakpoint in Debug mode to stop debugger in the Stack Overflow hook function. In a release version, it is good idea to visually notify the system state by toggling a LED with a defined pattern. void vApplicationStackOverflowHook ( xTaskHandle xTask , signed char * pcTaskName ) { #ifdef CATCH_STACK_OVERFLOW #ifdef DEBUG __BKPT (); #else for (;;) { HAL_GPIO_TogglePin ( LED_GPIO_Port , LED_Pin ); HAL_Delay ( 100 ); } #endif #endif } If a stack overflow happens, use the pcTaskName parameter to note the task name, and examine the task information from the xTask handler. Solutions \u2693\ufe0e In the embedded world, especially in high reliability code (automotive, aircraft, space), it needs to do extensive code reviews and checking, following: Disallow recursion and cycles \u2014 enforced by policy and testing Keep code and stack far apart (code in flash, stack in RAM, and never the twain shall meet) Place guard bands around the stack \u2014 empty area of memory that is filled with a magic number (usually a software interrupt instruction, but there are many options here), and hundreds or thousands of times a second, do look at the guard bands to make sure they haven\u2019t been overwritten. Use memory protection (i.e., no execute on the stack, no read or write just outside the stack) Interrupts don\u2019t call secondary functions \u2014 they set flags, copy data, and let the application take care of processing it (otherwise it might get 8 deep in function call tree, have an interrupt, and then go out another few functions inside the interrupt, causing the blowout). It has several call trees \u2014 one for the main processes, and one for each interrupt.","title":"Stack Overflow"},{"location":"blog/stm32/free-rtos/stack/#1-lab-0-task-stack-overflow","text":"Each task maintains its own stack. This is where function calls store parameters, and functions store its local variable. Let\u2019s create a new project that has only one task and this task continues printing a counter value to an UART port.","title":"1. Lab 0: Task Stack Overflow"},{"location":"blog/stm32/free-rtos/stack/#11-precondition","text":"Let\u2019s create a new FreeRTOS application using STM32CubeMX with below settings: Time base Source for HAL is moved to a general timer, such as TIM6 or TIM10, TIM11 An UART port is enabled, such as UART1 TX on the pin PA9 An LED output which is used as the heartbeat of the system FreeRTOS is enabled with configs: CMSIS V2 is selected Only need the default task","title":"1.1. Precondition"},{"location":"blog/stm32/free-rtos/stack/#12-redirect-printf-to-uart","text":"The simplest way is to overwrite the low-level _write() function. Refer to UART Redirection for a full version, but it is not necessary for this lab. int _write ( int file , char * ptr , int len ) { // block write to UART if it is not ready while ( HAL_UART_GetState ( & huart1 ) != HAL_UART_STATE_READY ); HAL_StatusTypeDef hstatus = HAL_UART_Transmit ( & huart1 , ( uint8_t * ) ptr , len , HAL_MAX_DELAY ); return ( hstatus == HAL_OK ? len : 0 ); }","title":"1.2. Redirect printf to UART"},{"location":"blog/stm32/free-rtos/stack/#13-the-default-task","text":"In this default task, there is counter variable which will be counted up and printed out in the task main loop. The LED will be toggled every 1 second to indicate that the default task is running. Let\u2019s implement this in a simple way: void StartDefaultTask ( void * argument ) { uint32_t counter = 0xbeefbeef ; /* Infinite loop */ for (;;) { HAL_GPIO_TogglePin ( LED_GPIO_Port , LED_Pin ); printf ( \"Counting, %lu %lu %lu %lu. No problem? \\r\\n \" , counter ++ , counter ++ , counter ++ , counter ++ ); osDelay ( 1000 ); } }","title":"1.3. The default task"},{"location":"blog/stm32/free-rtos/stack/#14-compile-and-run","text":"This simple project can be compiled and run successfully. Messages are printed out successfully","title":"1.4. Compile and Run"},{"location":"blog/stm32/free-rtos/stack/#15-check-the-task-stack","text":"Be default, the minimum stack size of a FreeRTOS task is 128 Words (128 x 4 = 512 Bytes). The settings of the default task Set a breakpoint at the beginning of the main loop in the function StartDefaultTask() and read the structure of the default task control block by casting the pointer defaultTaskHandle to type of TCB_t* pointer in Live Expression view. Note the below things: The start address of the Stack is stored in pxStack The end address of the Stack is stored in pxEndOfStack The whole stack is filled in a pattern 0xA5A5A5A5 The stack will be consumed from the end of the start back to the start address. The stack should never reach the start address to avoid stack overflow . Memory view before stack overflow The task is initialized by the function prvInitialiseNewTask() which stores the task name, set priority, container lists, and finally, it prepares the task\u2019s stack. The top of the stack is initialized based on how stack size is defined. Usually, task stack is fixed, it means stack size is not growing, determined by portSTACK_GROWTH = -1 . The top the stack will be changed, because the stack will be filled with some task information used for the task switching. The current top of the tack when a function is running is saved in the PSP register.","title":"1.5. Check the task stack"},{"location":"blog/stm32/free-rtos/stack/#16-step-over-the-print-function","text":"Set a breakpoint right after the printf() function to check the stack after the message is printout to UART. Now, look at the value stored at the start address of the stack. It\u2019s changed! Moreover, 8 bytes beyond the stack boundary are also changed. Stack Overflow does really occur . Memory view after stack overflow How did it happen? An address can be added as a watch point, to check if that address is read, written. Select the start address of the stack and add its address to the watch list: Adding a watch point by monitoring what writes into this memory The printing function takes more than 1 ms to complete. The top of the stack of the default tasks is at 0x20000E50 , and a SysTick fires, the SysTick_Handler() ISR is called, causing it uses the current stack. The ISR consumes the stack and overwrites the stack boundary, going beyond the stack start address. It is stack overflow. Stack overflow occurs when SysTick ISR is called The good thing in this lab is there is no important bytes outside the default task\u2019s stack. After SysTick is handled, system still runs normally, without any problem.","title":"1.6. Step over the print function"},{"location":"blog/stm32/free-rtos/stack/#2-catching-stack-overflow","text":"Stack overflow is a very common cause of application instability. FreeRTOS therefore provides two optional mechanisms that can be used to assist in the detection and correction of just such an occurrence. The option used is configured using the configCHECK_FOR_STACK_OVERFLOW configuration constant. Note that these options are only available on architectures where the memory map is not segmented. Also, some processors could generate a fault or exception in response to a stack corruption before the FreeRTOS kernel overflow check can occur. The application must provide a stack overflow hook function: void vApplicationStackOverflowHook ( TaskHandle_t xTask , signed char * pcTaskName ); The xTask and pcTaskName parameters pass to the hook function the handle and name of the offending task respectively. Note however, depending on the severity of the overflow, these parameters could themselves be corrupted, in which case the pxCurrentTCB variable can be inspected directly. Stack overflow checking introduces a context switch overhead so its use is only recommended during the development or testing phases. In the function vTaskSwitchContext() , before switching to another task, the current task stack will be checked. The macro taskCHECK_FOR_STACK_OVERFLOW() will be called based on the stack overflow detection configuration.","title":"2. Catching Stack Overflow"},{"location":"blog/stm32/free-rtos/stack/#21-stack-overflow-detection--method-1","text":"This simple method check the Top of Stack is still in the stack range. The stack overflow hook function is called if the stack pointer contain a value that is outside the valid stack range. This method is quick but not guaranteed to catch all stack overflows. Set configCHECK_FOR_STACK_OVERFLOW to 1 to use this method. #if( ( configCHECK_FOR_STACK_OVERFLOW == 1 ) && ( portSTACK_GROWTH < 0 ) ) define taskCHECK_FOR_STACK_OVERFLOW () \\ /* Is the currently saved stack pointer within the stack limit? */ \\ if ( pxCurrentTCB -> pxTopOfStack <= pxCurrentTCB -> pxStack ) \\ { \\ vApplicationStackOverflowHook ( ( TaskHandle_t ) pxCurrentTCB , \\ pxCurrentTCB -> pcTaskName ); \\ } \\ #endif /* configCHECK_FOR_STACK_OVERFLOW == 1 */","title":"2.1. Stack Overflow Detection \u2014 Method 1"},{"location":"blog/stm32/free-rtos/stack/#22-stack-overflow-detection--method-2","text":"When a task is first created its stack is filled with a known value. When swapping a task out of the Running state the FreeRTOS kernel can check the last 16 bytes within the valid stack range to ensure that these known values have not been overwritten by the task or interrupt activity. The stack overflow hook function is called should any of these 16 bytes not remain at their initial value. This method is less efficient than method one, but still fairly fast. It is very likely to catch stack overflows but is still not guaranteed to catch all overflows. #if( ( configCHECK_FOR_STACK_OVERFLOW > 1 ) && ( portSTACK_GROWTH < 0 ) ) #define taskCHECK_FOR_STACK_OVERFLOW() \\ { \\ const uint32_t* const pulStack = (uint32_t*) pxCurrentTCB->pxStack; \\ const uint32_t ulCheckValue = (uint32_t 0xa5a5a5a5; \\ /* check if boundary bytes are changed? */ \\ if( ( pulStack[ 0 ] != ulCheckValue ) || \\ ( pulStack[ 1 ] != ulCheckValue ) || \\ ( pulStack[ 2 ] != ulCheckValue ) || \\ ( pulStack[ 3 ] != ulCheckValue ) ) \\ { \\ vApplicationStackOverflowHook((TaskHandle_t) pxCurrentTCB, \\ pxCurrentTCB->pcTaskName ); \\ } \\ } #endif /* #if( configCHECK_FOR_STACK_OVERFLOW > 1 ) */","title":"2.2. Stack Overflow Detection \u2014 Method 2"},{"location":"blog/stm32/free-rtos/stack/#23-trap-the-stack-overflow","text":"Firstly, enable a method to detect Stack Overflow by setting the configCHECK_FOR_STACK_OVERFLOW config. Enable Stack Overflow detection In the hook (callback) function, it can call to a soft breakpoint in Debug mode to stop debugger in the Stack Overflow hook function. In a release version, it is good idea to visually notify the system state by toggling a LED with a defined pattern. void vApplicationStackOverflowHook ( xTaskHandle xTask , signed char * pcTaskName ) { #ifdef CATCH_STACK_OVERFLOW #ifdef DEBUG __BKPT (); #else for (;;) { HAL_GPIO_TogglePin ( LED_GPIO_Port , LED_Pin ); HAL_Delay ( 100 ); } #endif #endif } If a stack overflow happens, use the pcTaskName parameter to note the task name, and examine the task information from the xTask handler.","title":"2.3. Trap the Stack Overflow"},{"location":"blog/stm32/free-rtos/stack/#solutions","text":"In the embedded world, especially in high reliability code (automotive, aircraft, space), it needs to do extensive code reviews and checking, following: Disallow recursion and cycles \u2014 enforced by policy and testing Keep code and stack far apart (code in flash, stack in RAM, and never the twain shall meet) Place guard bands around the stack \u2014 empty area of memory that is filled with a magic number (usually a software interrupt instruction, but there are many options here), and hundreds or thousands of times a second, do look at the guard bands to make sure they haven\u2019t been overwritten. Use memory protection (i.e., no execute on the stack, no read or write just outside the stack) Interrupts don\u2019t call secondary functions \u2014 they set flags, copy data, and let the application take care of processing it (otherwise it might get 8 deep in function call tree, have an interrupt, and then go out another few functions inside the interrupt, causing the blowout). It has several call trees \u2014 one for the main processes, and one for each interrupt.","title":"Solutions"},{"location":"blog/stm32/free-rtos/systick/","text":"1. SysTick \u2693\ufe0e When generating a new project from STM32CubeMX, there will be a popup saying that: Prompt asking about set another time base source What does this mean? SysTick SysTick is apart of the ARM Core, that counts down from the reload value to zero, and fire an interrupt to make a periodical event. SysTick is mainly used for delay function in non-RTOS firmware, and is used as the interrupt for RTOS scheduler. In case STM32 HAL code also uses SysTick as its time base, RTOS will be generated to use HAL\u2019s Handler. If STM32 HAL utilizes another timer as its time base, RTOS has its own right to initialize and handler SysTick. It is recommended to use SysTick for RTOS only, and set a basic timer as the time base for HAL. SysTick in different use cases 2. Delay \u2693\ufe0e The function osDelay() is part of CMSIS Library and uses vTaskDelay() internally to introduce delay with the difference that input argument of osDelay is delay time in milliseconds while the input argument of _vTaskDelay() is a number of Ticks to be delayed. Using this osDelay() function, OS will be notified about the delay and OS will change the status of task to blocked for that particular time period. The function HAL_Delay() is part of the hardware abstraction layer. It basically uses polling to introduce delay. Using this HAL_Delay() function, OS won\u2019t be notified about the delay, and the code is in polling mode. FreeRTOS delay functions: vTaskDelay() or vTaskDelayUntil() only take effect after the scheduler has started. Always use osDelay() when using RTOS.","title":"SysTick & Delay"},{"location":"blog/stm32/free-rtos/systick/#1-systick","text":"When generating a new project from STM32CubeMX, there will be a popup saying that: Prompt asking about set another time base source What does this mean? SysTick SysTick is apart of the ARM Core, that counts down from the reload value to zero, and fire an interrupt to make a periodical event. SysTick is mainly used for delay function in non-RTOS firmware, and is used as the interrupt for RTOS scheduler. In case STM32 HAL code also uses SysTick as its time base, RTOS will be generated to use HAL\u2019s Handler. If STM32 HAL utilizes another timer as its time base, RTOS has its own right to initialize and handler SysTick. It is recommended to use SysTick for RTOS only, and set a basic timer as the time base for HAL. SysTick in different use cases","title":"1. SysTick"},{"location":"blog/stm32/free-rtos/systick/#2-delay","text":"The function osDelay() is part of CMSIS Library and uses vTaskDelay() internally to introduce delay with the difference that input argument of osDelay is delay time in milliseconds while the input argument of _vTaskDelay() is a number of Ticks to be delayed. Using this osDelay() function, OS will be notified about the delay and OS will change the status of task to blocked for that particular time period. The function HAL_Delay() is part of the hardware abstraction layer. It basically uses polling to introduce delay. Using this HAL_Delay() function, OS won\u2019t be notified about the delay, and the code is in polling mode. FreeRTOS delay functions: vTaskDelay() or vTaskDelayUntil() only take effect after the scheduler has started. Always use osDelay() when using RTOS.","title":"2. Delay"},{"location":"blog/stm32/free-rtos/tasks/","text":"F411CE_FreeRTOS_Tasks.zip 1. A Task \u2693\ufe0e A task will do a specific functionality, such as toggling an LED, reading an input. The task function usually has an infinite loop, it means a task will continuously run and never returns. The Task Function is declared as: void taskFunctionName ( void * argument ) { for (;;) { // do things over and over } } In FreeRTOS, every task has its own stack that stores TCB (Task Control Block) and other stack-related operations while the task is being executed. It also stores processor context before a context switch (switching to other task). Stack size must be sufficient to accommodate all local variables and processor context. 2. Startup \u2693\ufe0e .md-typeset ol ol, .md-typeset ul ol { list-style-type: numeric; } Main Application sets up the System Clock and necessary Peripherals FreeRTOS is started by the osKernelStart() function in the main.c file from CMSIS_OS APIs: This calls to the vTaskStartScheduler() function from FreeRTOS APIs vTaskStartScheduler() creates an IDLE task using xTaskCreate() , then disables all interrupts by calling portDISABLE_INTERRUPTS() to be sure that no tick will happen before or during the call to xPortStartScheduler() function from FreeRTOS API xPortStartScheduler() configures the lowest priority level for SysTick and PendSV interrupts, then it starts the timer that generates the SysTick, enables FPU if presented (e.g. in CortexM4) and starts the first task using the prvPortStartFirstTask() function prvPortStartFirstTask() function (usually written in assembler) locates the stack and set MSP (used by the OS) to the start of the stack, then enables all interrupts. After this, it triggers software interrupt SVC 0 As the result of SVC interrupt, vPortSVCHandler() is called vPortSVCHandler() restores the context, loads TCB (Task Block Control) of the first task (the highest priority one) from the Ready list and starts executing this task 3. The IDLE Task \u2693\ufe0e The Idle task is created automatically when the scheduler is started: It is the portTASK_FUNCTION() function in the task.c file It performs the following operations (in endless loop): Check for deleted tasks to clean the memory Call taskYIELD() if not using preemption configUSE_PREEMPTION = 0 Call taskYIELD() if there is another task waiting and configIDLE_SHOULD_YIELD = 1 to not waste time Executes vApplicationIdleHook() if configUSE_IDLE_HOOK = 1 Perform low power entrance if configUSE_TICKLESS_IDLE != 0 The default task When using STM32CubeIDE to add FreeRTOS to project, there is a default task which is marked as can be modified, not be removed . This not the IDLE task mentioned above. User can configure it as a normal task, or even remove it in the main source code. 4. Task Lists \u2693\ufe0e Task List Description ReadyTasksList[] Prioritized ready tasks lists separate for each task priority up to configMAX_PRIORITIES TasksWaitingTermination List of tasks which have been deleted, but their memory pools are not freed yet. SuspendedTaskList List of tasks currently suspended PendingReadyTaskList Lists of tasks that have been read while the scheduler was suspended DelayedTaskList List of delayed tasks OverflowDelayedTaskList List of delayed tasks which have overflowed the current tick count There is no dedicated list for task in Running mode (as there is only one task in this state at the moment), but the currently run task ID is stored in variable pxCurrentTCB . 5. Task Functions \u2693\ufe0e A task will do a specific functionality, such as toggling an LED, reading an input. The task function usually has an infinite loop, it means a task will continuously run and never returns. The Task Function is declared as: void taskFunctionName ( void * argument ) { // do something first for (;;) { // do things over and over } } In FreeRTOS, every task has its own stack that stores TCB (Task Control Block) and other stack-related operations while the task is being executed. It also stores processor context before a context switch (switching to other task). Stack size must be sufficient to accommodate all local variables and processor context. A Task is created by calling osThreadNew() which indeed calls to: xTaskCreateStatic() if configSUPPORT_STATIC_ALLOCATION == 1 , or calls to xTaskCreate() if configSUPPORT_DYNAMIC_ALLOCATION == 1 . The argument passed to the Task Function is declared as a void* pointer. This help to pass any type of data into the function handler. 6. Task states \u2693\ufe0e Ready Task is ready to be executed but is not currently executing because a different task with equal or higher priority is running Running Task is actually running (only one can be in this state at the moment) Blocked Task is waiting for either a temporal or an external event Suspended Task not available for scheduling, but still being kept in memory Task states 7. Task priorities \u2693\ufe0e Each task is assigned a priority from tskIDLE_PRIORITY (defined in task.h ) to MAX_PRIORITIES \u2013 1 (defined in FreeRTOSConfig.h ). The order of execution of tasks depends on this priority. The scheduler activates the task that has the highest priority of all tasks in the READY state. A Task with higher priority can preempt the running task if configUSE_PREEMPTION = 1 (defined in FreeRTOSConfig.h ). Priority name Value Comment osPriorityIdle -3 priority: idle (lowest) osPriorityLow -2 priority: low osPriorityBelowNormal -1 priority: below normal osPriorityNormal 0 priority: normal (default) osPriorityAboveNormal 1 priority: above normal osPriorityHigh 2 priority: high osPriorityRealtime 3 priority: real-time (highest) osPriorityError 0x84 system cannot determine priority or thread has illegal priority Task priority and execution order 8. Task context switching \u2693\ufe0e The process of saving the context of a task that is being suspended and restoring the context of a task being resumed is called context switching. There are two 2 triggers that cause context switching: SysTick interrupt This interrupt is used as a periodical signal to check if system needs to switch to another task. The interrupt causes xPortSysTickHandler() run xPortSysTickHandler() will: blocks all interrupts (as its own priority is the lowest one) using portDISABLE_INTERRUPTS() activates the PendSV bit to trigger xPortPendSVHandler() : calls to vTaskSwitchContext() function which selects the highest priority task in the READY List using the macro taskSELECT_HIGHEST_PRIORITY_TASK() unblocks all interrupts using portENABLE_INTERRUPT() Task yield When a task has done its work, it can trigger a context switching by send a yield by calling to portYIELD() which will set the PendSV bit to trigger xPortPendSVHandler() and start the scheduler (see above sequence). Here are some cases that a task yield is called: The idle task is done its internal task, it calls to taskYIELD() When a task is in the block state, such as it has a delay or delay until function call, using portYIELD_WITHIN_API() When an interrupt unblocks a task using portYIELD_FROM_ISR() 9. Lab 0: Tasks \u2693\ufe0e Star a new project with FreeRTOS included in STM32CubeIDE. Refer to the Lab: Overview . At this time, tasks will be added manually in code, without using the code generation in STM32CubeMX. This project can be targeted on any MCU which has enough RAM to hold FreeRTOS. Here are the settings needed for the lab: HAL Time base is assigned to a general timer, let FreeRTOS use the SysTick UART1 is enabled for printing debug information, note the pinout. Select CMSIS_OS version 2, and use default FreeRTOS settings Enable re-entrant settings for using FreeRTOS with newlib . Read more in FreeRTOS Newlib reentrant . 9.1. Enable UART redirection \u2693\ufe0e It is useful to print out debug information, and to make it easier, UART redirection will be used. In this lab, it can be implemented in a minimal method by overriding the low-level _write function in the main file. Inside this function, a blocking call will be used to make sure all data is written in multi-thread. The correct method of synchronization will be discussed later. main.c int _write ( int file , char * ptr , int len ) { // block write to UART if it is not ready while ( HAL_UART_GetState ( & huart1 ) != HAL_UART_STATE_READY ); HAL_StatusTypeDef hstatus = HAL_UART_Transmit ( & huart1 , ( uint8_t * ) ptr , len , HAL_MAX_DELAY ); return ( hstatus == HAL_OK ? len : 0 ); } 9.2. Define a parameter for tasks \u2693\ufe0e In this example, two tasks will count characters in a range which is defined in a structure as below: typedef struct { uint8_t start ; uint8_t end ; } CounterRange_t ; The first task will count from 0 to 9 , while the second tasks will count from A to J . CounterRange_t Task1_CounterRange = { '0' , '9' }; CounterRange_t Task2_CounterRange = { 'A' , 'J' }; 9.3. Add 2 Tasks \u2693\ufe0e Define two tasks in the main file. At this moment, two tasks will have the same priority as osPriorityNormal level. main.c osThreadId_t Task1_Handle ; const osThreadAttr_t Task1_attributes = { . name = \"Task1\" , . stack_size = 128 * 4 , . priority = ( osPriority_t ) osPriorityNormal , }; osThreadId_t Task2_Handle ; const osThreadAttr_t Task2_attributes = { . name = \"Task2\" , . stack_size = 128 * 4 , . priority = ( osPriority_t ) osPriorityNormal , }; These two tasks will print out a sequence of character by using the same task CounterTask() which gets a CounterRange_t parameter from its task function\u2019s parameter: HAL_Delay() At the beginning of this lab, HAL_Delay() function is used to simulate a heavy work which is consuming CPU. Scheduler will never put these tasks to the Blocked state. void CounterTask ( void * argument ) { char * name = pcTaskGetName ( NULL ); CounterRange_t * range = ( CounterRange_t * ) argument ; printf ( \"%s: range = %c : %c \\r\\n \" , name , range -> start , range -> end ); uint8_t counter = range -> start ; /* Infinite loop */ for (;;) { printf ( \"%s: counter = %c \\r\\n \" , name , counter ++ ); if ( counter > range -> end ) counter = range -> start ; HAL_Delay ( 500 ); } } In the main function, create two tasks using the CounterTask() function with different delay parameters. Note that the pointer pointing to the int parameter is converted to a void* pointer. int main ( void ) { // Hardware init HAL_Init (); SystemClock_Config (); MX_GPIO_Init (); MX_USART1_UART_Init (); // FreeRTOS Init osKernelInitialize (); // Add Tasks Task1Handle = osThreadNew ( CounterTask , ( void * ) & Task1_CounterRange , & Task1_attributes ); Task2Handle = osThreadNew ( CounterTask , ( void * ) & Task2_CounterRange , & Task2_attributes ); //Start scheduler osKernelStart (); } 9.4. Build and Run \u2693\ufe0e Compile the project and connect the UART1 to PC, and check the result: At startup, tasks print out their name and counter range to confirm the attributes and the parameter Both tasks run and print their counter values Because the _write() is implemented as a blocking method (same as a mutex), each task can fully print out its messages. Two tasks are printing Note that, because two tasks have the same priority, they will be switched at every SysTick interruption (about 1 ms). Both tasks use HAL_Delay() which in fact consume CPU during the waiting time. Two tasks have the same priority 9.5. Change Priority \u2693\ufe0e Let change one of two tasks to use osPriorityHigh priority, and see how system works after that modification. The result is only high priority task can run because higher priory are requesting to use CPU all the time. const osThreadAttr_t Task1_attributes = { . name = \"Task1\" , . stack_size = 128 * 4 , . priority = ( osPriority_t ) osPriorityHigh , } Only Task 1 with High Priority is running const osThreadAttr_t Task2_attributes = { . name = \"Task2\" , . stack_size = 128 * 4 , . priority = ( osPriority_t ) osPriorityHigh , } Only Task 2 with High Priority is running Change priority in runtime There are two functions to get and set task priority in runtime: The function osThreadGetPriority() calls uxTaskPriorityGet() or uxTaskPriorityGetFromISR() defined in tasks.c file The function osThreadSetPriority() calls vTaskPrioritySet() defined in tasks.c file. After setting new priority, this function also trigger the task scheduler to re-arrange tasks in the scheduled lists. Two these functions must be enabled in Include definitions settings of FreeRTOS. 9.6. Use OS Delay \u2693\ufe0e Keep one task in high priority, how to run both tasks? The key of RTOS scheduler is whenever a task is not working, it can be moved to block state and other task, even in lower priority, can run. void CounterTask ( void * argument ) { char * name = pcTaskGetName ( NULL ); CounterRange_t * range = ( CounterRange_t * ) argument ; printf ( \"%s: range = %c : %c \\r\\n \" , name , range -> start , range -> end ); uint8_t counter = range -> start ; /* Infinite loop */ for (;;) { printf ( \"%s: counter = %c \\r\\n \" , name , counter ++ ); if ( counter > range -> end ) counter = range -> start ; osDelay ( 500 ); } } Here is the CPU load while using osDelay() . CPU is only busy when it prints out on UART, and move to IDLE state in which CPU does nothing and waits for SysTick interruption. This is much effective way to lower power consumption. CPU is in Idle when both tasks are in delay There are some more functions related to delay: osDelayUntil() which calls to vTaskDelayUntil() osAbortDelay() which calls to xTaskAbortDelay() The function osDelay() calls to vTaskDelay() function defined in tasks.c file to do below actions: Calls vTaskSuspendAll() to pause the scheduler without disabling interrupts. RTOS tick will be held pending until the scheduler has been resumed. Remove task from event list (running tasks) and move it to delayed list with given delay value using the function prvAddCurrentTaskToDelayedList() Resume the scheduler using xTaskResumeAll() function Trigger PendSV interrupt (using portYIELD_WITHIN_API() macro) to switch the context 10. Other Tasks functions \u2693\ufe0e Suspend and Resume A task can be put into Suspended State by calling to osThreadSuspend() which calls to vTaskSuspend() function. To resume a task, call to osThreadResume() function which actually calls to either vTaskResume() or xTaskResumeFromISR() function. Terminate a task Call to osThreadTerminate() function which indeed calls to vTaskDelete() defined in task.c file: Remove the task from the ready list using uxListRemove() and removes the task from waiting on an event tasks list. In case the task is deleting itself, this function will switch execution to the next task calling function by calling portYIELD_WITHIN_API() Memory allocated by the task code is not automatically freed and should be freed before the task is deleted. TCB and its original stack are freed by the IDLE Task. Task Yield When a task has done its job, and don\u2019t want to wait for a SysTick interruption, it can yield to scheduler to trigger context switching. Task 1 yield","title":"Tasks"},{"location":"blog/stm32/free-rtos/tasks/#1-a-task","text":"A task will do a specific functionality, such as toggling an LED, reading an input. The task function usually has an infinite loop, it means a task will continuously run and never returns. The Task Function is declared as: void taskFunctionName ( void * argument ) { for (;;) { // do things over and over } } In FreeRTOS, every task has its own stack that stores TCB (Task Control Block) and other stack-related operations while the task is being executed. It also stores processor context before a context switch (switching to other task). Stack size must be sufficient to accommodate all local variables and processor context.","title":"1. A Task"},{"location":"blog/stm32/free-rtos/tasks/#2-startup","text":".md-typeset ol ol, .md-typeset ul ol { list-style-type: numeric; } Main Application sets up the System Clock and necessary Peripherals FreeRTOS is started by the osKernelStart() function in the main.c file from CMSIS_OS APIs: This calls to the vTaskStartScheduler() function from FreeRTOS APIs vTaskStartScheduler() creates an IDLE task using xTaskCreate() , then disables all interrupts by calling portDISABLE_INTERRUPTS() to be sure that no tick will happen before or during the call to xPortStartScheduler() function from FreeRTOS API xPortStartScheduler() configures the lowest priority level for SysTick and PendSV interrupts, then it starts the timer that generates the SysTick, enables FPU if presented (e.g. in CortexM4) and starts the first task using the prvPortStartFirstTask() function prvPortStartFirstTask() function (usually written in assembler) locates the stack and set MSP (used by the OS) to the start of the stack, then enables all interrupts. After this, it triggers software interrupt SVC 0 As the result of SVC interrupt, vPortSVCHandler() is called vPortSVCHandler() restores the context, loads TCB (Task Block Control) of the first task (the highest priority one) from the Ready list and starts executing this task","title":"2. Startup"},{"location":"blog/stm32/free-rtos/tasks/#3-the-idle-task","text":"The Idle task is created automatically when the scheduler is started: It is the portTASK_FUNCTION() function in the task.c file It performs the following operations (in endless loop): Check for deleted tasks to clean the memory Call taskYIELD() if not using preemption configUSE_PREEMPTION = 0 Call taskYIELD() if there is another task waiting and configIDLE_SHOULD_YIELD = 1 to not waste time Executes vApplicationIdleHook() if configUSE_IDLE_HOOK = 1 Perform low power entrance if configUSE_TICKLESS_IDLE != 0 The default task When using STM32CubeIDE to add FreeRTOS to project, there is a default task which is marked as can be modified, not be removed . This not the IDLE task mentioned above. User can configure it as a normal task, or even remove it in the main source code.","title":"3. The IDLE Task"},{"location":"blog/stm32/free-rtos/tasks/#4-task-lists","text":"Task List Description ReadyTasksList[] Prioritized ready tasks lists separate for each task priority up to configMAX_PRIORITIES TasksWaitingTermination List of tasks which have been deleted, but their memory pools are not freed yet. SuspendedTaskList List of tasks currently suspended PendingReadyTaskList Lists of tasks that have been read while the scheduler was suspended DelayedTaskList List of delayed tasks OverflowDelayedTaskList List of delayed tasks which have overflowed the current tick count There is no dedicated list for task in Running mode (as there is only one task in this state at the moment), but the currently run task ID is stored in variable pxCurrentTCB .","title":"4. Task Lists"},{"location":"blog/stm32/free-rtos/tasks/#5-task-functions","text":"A task will do a specific functionality, such as toggling an LED, reading an input. The task function usually has an infinite loop, it means a task will continuously run and never returns. The Task Function is declared as: void taskFunctionName ( void * argument ) { // do something first for (;;) { // do things over and over } } In FreeRTOS, every task has its own stack that stores TCB (Task Control Block) and other stack-related operations while the task is being executed. It also stores processor context before a context switch (switching to other task). Stack size must be sufficient to accommodate all local variables and processor context. A Task is created by calling osThreadNew() which indeed calls to: xTaskCreateStatic() if configSUPPORT_STATIC_ALLOCATION == 1 , or calls to xTaskCreate() if configSUPPORT_DYNAMIC_ALLOCATION == 1 . The argument passed to the Task Function is declared as a void* pointer. This help to pass any type of data into the function handler.","title":"5. Task Functions"},{"location":"blog/stm32/free-rtos/tasks/#6-task-states","text":"Ready Task is ready to be executed but is not currently executing because a different task with equal or higher priority is running Running Task is actually running (only one can be in this state at the moment) Blocked Task is waiting for either a temporal or an external event Suspended Task not available for scheduling, but still being kept in memory Task states","title":"6. Task states"},{"location":"blog/stm32/free-rtos/tasks/#7-task-priorities","text":"Each task is assigned a priority from tskIDLE_PRIORITY (defined in task.h ) to MAX_PRIORITIES \u2013 1 (defined in FreeRTOSConfig.h ). The order of execution of tasks depends on this priority. The scheduler activates the task that has the highest priority of all tasks in the READY state. A Task with higher priority can preempt the running task if configUSE_PREEMPTION = 1 (defined in FreeRTOSConfig.h ). Priority name Value Comment osPriorityIdle -3 priority: idle (lowest) osPriorityLow -2 priority: low osPriorityBelowNormal -1 priority: below normal osPriorityNormal 0 priority: normal (default) osPriorityAboveNormal 1 priority: above normal osPriorityHigh 2 priority: high osPriorityRealtime 3 priority: real-time (highest) osPriorityError 0x84 system cannot determine priority or thread has illegal priority Task priority and execution order","title":"7. Task priorities"},{"location":"blog/stm32/free-rtos/tasks/#8-task-context-switching","text":"The process of saving the context of a task that is being suspended and restoring the context of a task being resumed is called context switching. There are two 2 triggers that cause context switching: SysTick interrupt This interrupt is used as a periodical signal to check if system needs to switch to another task. The interrupt causes xPortSysTickHandler() run xPortSysTickHandler() will: blocks all interrupts (as its own priority is the lowest one) using portDISABLE_INTERRUPTS() activates the PendSV bit to trigger xPortPendSVHandler() : calls to vTaskSwitchContext() function which selects the highest priority task in the READY List using the macro taskSELECT_HIGHEST_PRIORITY_TASK() unblocks all interrupts using portENABLE_INTERRUPT() Task yield When a task has done its work, it can trigger a context switching by send a yield by calling to portYIELD() which will set the PendSV bit to trigger xPortPendSVHandler() and start the scheduler (see above sequence). Here are some cases that a task yield is called: The idle task is done its internal task, it calls to taskYIELD() When a task is in the block state, such as it has a delay or delay until function call, using portYIELD_WITHIN_API() When an interrupt unblocks a task using portYIELD_FROM_ISR()","title":"8. Task context switching"},{"location":"blog/stm32/free-rtos/tasks/#9-lab-0-tasks","text":"Star a new project with FreeRTOS included in STM32CubeIDE. Refer to the Lab: Overview . At this time, tasks will be added manually in code, without using the code generation in STM32CubeMX. This project can be targeted on any MCU which has enough RAM to hold FreeRTOS. Here are the settings needed for the lab: HAL Time base is assigned to a general timer, let FreeRTOS use the SysTick UART1 is enabled for printing debug information, note the pinout. Select CMSIS_OS version 2, and use default FreeRTOS settings Enable re-entrant settings for using FreeRTOS with newlib . Read more in FreeRTOS Newlib reentrant .","title":"9. Lab 0: Tasks"},{"location":"blog/stm32/free-rtos/tasks/#91-enable-uart-redirection","text":"It is useful to print out debug information, and to make it easier, UART redirection will be used. In this lab, it can be implemented in a minimal method by overriding the low-level _write function in the main file. Inside this function, a blocking call will be used to make sure all data is written in multi-thread. The correct method of synchronization will be discussed later. main.c int _write ( int file , char * ptr , int len ) { // block write to UART if it is not ready while ( HAL_UART_GetState ( & huart1 ) != HAL_UART_STATE_READY ); HAL_StatusTypeDef hstatus = HAL_UART_Transmit ( & huart1 , ( uint8_t * ) ptr , len , HAL_MAX_DELAY ); return ( hstatus == HAL_OK ? len : 0 ); }","title":"9.1. Enable UART redirection"},{"location":"blog/stm32/free-rtos/tasks/#92-define-a-parameter-for-tasks","text":"In this example, two tasks will count characters in a range which is defined in a structure as below: typedef struct { uint8_t start ; uint8_t end ; } CounterRange_t ; The first task will count from 0 to 9 , while the second tasks will count from A to J . CounterRange_t Task1_CounterRange = { '0' , '9' }; CounterRange_t Task2_CounterRange = { 'A' , 'J' };","title":"9.2. Define a parameter for tasks"},{"location":"blog/stm32/free-rtos/tasks/#93-add-2-tasks","text":"Define two tasks in the main file. At this moment, two tasks will have the same priority as osPriorityNormal level. main.c osThreadId_t Task1_Handle ; const osThreadAttr_t Task1_attributes = { . name = \"Task1\" , . stack_size = 128 * 4 , . priority = ( osPriority_t ) osPriorityNormal , }; osThreadId_t Task2_Handle ; const osThreadAttr_t Task2_attributes = { . name = \"Task2\" , . stack_size = 128 * 4 , . priority = ( osPriority_t ) osPriorityNormal , }; These two tasks will print out a sequence of character by using the same task CounterTask() which gets a CounterRange_t parameter from its task function\u2019s parameter: HAL_Delay() At the beginning of this lab, HAL_Delay() function is used to simulate a heavy work which is consuming CPU. Scheduler will never put these tasks to the Blocked state. void CounterTask ( void * argument ) { char * name = pcTaskGetName ( NULL ); CounterRange_t * range = ( CounterRange_t * ) argument ; printf ( \"%s: range = %c : %c \\r\\n \" , name , range -> start , range -> end ); uint8_t counter = range -> start ; /* Infinite loop */ for (;;) { printf ( \"%s: counter = %c \\r\\n \" , name , counter ++ ); if ( counter > range -> end ) counter = range -> start ; HAL_Delay ( 500 ); } } In the main function, create two tasks using the CounterTask() function with different delay parameters. Note that the pointer pointing to the int parameter is converted to a void* pointer. int main ( void ) { // Hardware init HAL_Init (); SystemClock_Config (); MX_GPIO_Init (); MX_USART1_UART_Init (); // FreeRTOS Init osKernelInitialize (); // Add Tasks Task1Handle = osThreadNew ( CounterTask , ( void * ) & Task1_CounterRange , & Task1_attributes ); Task2Handle = osThreadNew ( CounterTask , ( void * ) & Task2_CounterRange , & Task2_attributes ); //Start scheduler osKernelStart (); }","title":"9.3. Add 2 Tasks"},{"location":"blog/stm32/free-rtos/tasks/#94-build-and-run","text":"Compile the project and connect the UART1 to PC, and check the result: At startup, tasks print out their name and counter range to confirm the attributes and the parameter Both tasks run and print their counter values Because the _write() is implemented as a blocking method (same as a mutex), each task can fully print out its messages. Two tasks are printing Note that, because two tasks have the same priority, they will be switched at every SysTick interruption (about 1 ms). Both tasks use HAL_Delay() which in fact consume CPU during the waiting time. Two tasks have the same priority","title":"9.4. Build and Run"},{"location":"blog/stm32/free-rtos/tasks/#95-change-priority","text":"Let change one of two tasks to use osPriorityHigh priority, and see how system works after that modification. The result is only high priority task can run because higher priory are requesting to use CPU all the time. const osThreadAttr_t Task1_attributes = { . name = \"Task1\" , . stack_size = 128 * 4 , . priority = ( osPriority_t ) osPriorityHigh , } Only Task 1 with High Priority is running const osThreadAttr_t Task2_attributes = { . name = \"Task2\" , . stack_size = 128 * 4 , . priority = ( osPriority_t ) osPriorityHigh , } Only Task 2 with High Priority is running Change priority in runtime There are two functions to get and set task priority in runtime: The function osThreadGetPriority() calls uxTaskPriorityGet() or uxTaskPriorityGetFromISR() defined in tasks.c file The function osThreadSetPriority() calls vTaskPrioritySet() defined in tasks.c file. After setting new priority, this function also trigger the task scheduler to re-arrange tasks in the scheduled lists. Two these functions must be enabled in Include definitions settings of FreeRTOS.","title":"9.5. Change Priority"},{"location":"blog/stm32/free-rtos/tasks/#96-use-os-delay","text":"Keep one task in high priority, how to run both tasks? The key of RTOS scheduler is whenever a task is not working, it can be moved to block state and other task, even in lower priority, can run. void CounterTask ( void * argument ) { char * name = pcTaskGetName ( NULL ); CounterRange_t * range = ( CounterRange_t * ) argument ; printf ( \"%s: range = %c : %c \\r\\n \" , name , range -> start , range -> end ); uint8_t counter = range -> start ; /* Infinite loop */ for (;;) { printf ( \"%s: counter = %c \\r\\n \" , name , counter ++ ); if ( counter > range -> end ) counter = range -> start ; osDelay ( 500 ); } } Here is the CPU load while using osDelay() . CPU is only busy when it prints out on UART, and move to IDLE state in which CPU does nothing and waits for SysTick interruption. This is much effective way to lower power consumption. CPU is in Idle when both tasks are in delay There are some more functions related to delay: osDelayUntil() which calls to vTaskDelayUntil() osAbortDelay() which calls to xTaskAbortDelay() The function osDelay() calls to vTaskDelay() function defined in tasks.c file to do below actions: Calls vTaskSuspendAll() to pause the scheduler without disabling interrupts. RTOS tick will be held pending until the scheduler has been resumed. Remove task from event list (running tasks) and move it to delayed list with given delay value using the function prvAddCurrentTaskToDelayedList() Resume the scheduler using xTaskResumeAll() function Trigger PendSV interrupt (using portYIELD_WITHIN_API() macro) to switch the context","title":"9.6. Use OS Delay"},{"location":"blog/stm32/free-rtos/tasks/#10-other-tasks-functions","text":"Suspend and Resume A task can be put into Suspended State by calling to osThreadSuspend() which calls to vTaskSuspend() function. To resume a task, call to osThreadResume() function which actually calls to either vTaskResume() or xTaskResumeFromISR() function. Terminate a task Call to osThreadTerminate() function which indeed calls to vTaskDelete() defined in task.c file: Remove the task from the ready list using uxListRemove() and removes the task from waiting on an event tasks list. In case the task is deleting itself, this function will switch execution to the next task calling function by calling portYIELD_WITHIN_API() Memory allocated by the task code is not automatically freed and should be freed before the task is deleted. TCB and its original stack are freed by the IDLE Task. Task Yield When a task has done its job, and don\u2019t want to wait for a SysTick interruption, it can yield to scheduler to trigger context switching. Task 1 yield","title":"10. Other Tasks functions"},{"location":"blog/stm32/gpio/","text":"Blink LED with Button Button interrupt GPIO notes Enable clock source on GPIO port when use it APB2 bus speed determines the sampling rate of all GPIO inputs Can select mode, speed, alternative function on a GPIO pin Can have external interruption Can lock a GPIO after initializing Disconnect a GPIO pin by setting it into input floating mode Save power by setting GPIO pins to Analog mode ( Schmitt trigger is disabled) 1. Hardware \u2693\ufe0e Each GPIO Pin has a complex structure to function as both input and output: Protection Diodes Pull-up and Pull-down resistors on input Schmitt triggers to convert input to digital value Open-Drain or Push-Pull gate on output Multiplexer for Alternate Function Input and Output data registers Control registers A GPIO pin structure 1.1. Voltage and Current \u2693\ufe0e Always assume that all GPIO pins are NOT 5V tolerant by default until find out in the datasheet (such as DS8668 for STM32F0x) that a specific pin is 5V tolerant, only then it can be used as a 5V pin. The maximum current that could be sourced or sunk into any GPIO pin is 25mA as mentioned in the datasheet. 1.2. Input mode \u2693\ufe0e Input Floating (Hi-Z) Input Pull-Up Input Pull-Down Read about Pull-Up/ Pull-Down When a GPIO pin is set to the input mode, the data present on the I/O pin is sampled into the Input Data Register (IDR) every APB2 clock cycle. This means the APB2 bus speed determines the input sampling speed for the GPIO pins. 1.3. Output mode \u2693\ufe0e Output Open-Drain Output Push-Pull Read about Open-Drain and Push-pull When a GPIO pin is set to the output mode, there is an option to configure the pin speed mode. Refer to datasheet (e.g. DS8668) to check the I/O AC characteristics table to note the maximum frequency in different conditions. 1.4. Output Speed \u2693\ufe0e GPIO speed is not related to switching frequency, it defines the slew rate of a GPIO, that is how fast it goes from the 0V level to VDD one, and vice versa. Below image shows the slew rate of 2 speed modes: Red line: high speed Blue line: low speed Slew rate of 2 speed modes 1.5. Bit atomic operation \u2693\ufe0e There is no need for the software to disable interrupts when programming the Output Data Register (ODR) at bit level. Use Bit Set/Reset Register ( BSRR ) to select individual bit operation. 1.6. Input interrupt \u2693\ufe0e When in input mode, all ports have external interrupt capability. Read more about Interrupt . 1.7. Alternate function \u2693\ufe0e Alternate Function Push-Pull Alternate Function Open-Drain Pin can be used for an alternate function from a peripheral by setting the Alternate Function register (AF). 1.8. Analog input/output \u2693\ufe0e In analog mode, pin is directly wired to an analog module (ADC, DAC) 1.9. Locking pin \u2693\ufe0e The locking mechanism allows the IO configuration to be frozen. When the LOCK sequence has been applied on a port bit, it is no longer possible to modify the value of the port bit until the next reset. 2. STM32CubeHAL Usage \u2693\ufe0e The Hardware Abstract Layer (HAL) is designed so that it abstracts from the specific peripheral memory mapping. But, it also provides a general and more user-friendly way to configure the peripheral, without forcing the programmers to now how to configure its registers in detail. Excerpt from Description of STM32F0 HAL and low-layer drivers How to use GPIO HAL Enable the GPIO AHB clock using the following function : __HAL_RCC_GPIOx_CLK_ENABLE() . Configure the GPIO pin(s) using HAL_GPIO_Init() . Configure the IO mode using Mode member from GPIO_InitTypeDef structure Analog mode is required when a pin is to be used as ADC channel or DAC output. In case of external interrupt/event, select the type (interrupt or event) and the corresponding trigger event (rising or falling or both). Activate Pull-up, Pull-down resistor using Pull member from GPIO_InitTypeDef structure. In case of Output or alternate function mode selection: the speed is configured through Speed member from GPIO_InitTypeDef structure. In alternate mode is selection, the alternate function connected to the IO is configured through Alternate member from GPIO_InitTypeDef structure. In case of external interrupt/event mode selection, configure NVIC IRQ priority mapped to the EXTI line using HAL_NVIC_SetPriority() and enable it using HAL_NVIC_EnableIRQ() . HAL_GPIO_DeInit allows setting register values to their reset value. It\u2019s also recommended using it to non-configure pin which was used as an external interrupt or in event mode. That\u2019s the only way to reset corresponding bit in EXTI & SYSCFG registers. To get the level of a pin configured in input mode use HAL_GPIO_ReadPin() . To set/reset the level of a pin configured in output mode use HAL_GPIO_WritePin() or HAL_GPIO_TogglePin() . To lock pin configuration until next reset use HAL_GPIO_LockPin() . During and just after reset, the alternate functions are not active and the GPIO pins are configured in input floating mode (except JTAG pins). The LSE oscillator pins OSC32_IN and OSC32_OUT can be used as general purpose ( PC14 and PC15 ,respectively) when the LSE oscillator is off. The LSE has priority over the GPIO function. The HSE oscillator pins OSC_IN and OSC_OUT can be used as general purpose PF0 and PF1 , respectively, when the HSE oscillator is off. The HSE has priority over the GPIO function. 3. Lab 1: Blink Led \u2693\ufe0e Requirement An LED and a Push button Blink the LED every 100ms when press and hold a button Blink the LED every 500ms when the button is released Target board Any board that has GPIOs connected to an LED and a button. In this tutorial, a STM32F0 Discovery board will be used, the schematic shows below connection: STM32F051R8 Mode External peripheral PC8 Output Push Pull, No Pull-up and No Pull-down Blue LED PA0 Input, No Pull-up and No Pull-down Push button, active High The Blue LED and the Push button on STM32F0 Discovery board 3.1. Setup new project \u2693\ufe0e Before starting to write code to blink the LED, there are some steps need to be done to set up the MCU. It is easy to do with support from STM32CubeMX. Select the MCU The STM32F0 Discovery board has STM32F051R8 MCU. Set up clocks Under the Clock Configuration tab: PLL Source is HSI , with PLL Multiplier is 12 Set HCLK to 48 MHz Set up debugger To program code to the target MCU, go to the System Core under the Pinout & Configuration tab to select SYS module: Enable Debug Serial Wire This will automatically assign PA14 to SWCLK and PA13 to SWDIO, which are pins to communicate with debugger on SWD interface 3.2. Setup LED and Button \u2693\ufe0e Under the Pinout View, Left-click on PC8 and set as a GPIO_Output , on PA0 and set as a GPIO_Input . Right-click on these pins to set new name for them, such as LED and BUTTON . Set GPIO mode for pins 3.3. Generated source code \u2693\ufe0e Save the STM32CubeMX settings by Ctrl + S ,and then press Alt + K to start generating source code. Custom defines Any custom name for a pin will be defined in main.h : main.h #define BUTTON_Pin GPIO_PIN_0 #define BUTTON_GPIO_Port GPIOA #define LED_Pin GPIO_PIN_8 #define LED_GPIO_Port GPIOC Initializing functions In the main.c , IDE generates SystemClock_Config() to set up system clocks, and MX_GPIO_Init() to initialize GPIOs. main.c static void MX_GPIO_Init ( void ) { GPIO_InitTypeDef GPIO_InitStruct = { 0 }; /* GPIO Ports Clock Enable */ __HAL_RCC_GPIOA_CLK_ENABLE (); __HAL_RCC_GPIOC_CLK_ENABLE (); /*Configure GPIO pin Output Level */ HAL_GPIO_WritePin ( LED_GPIO_Port , LED_Pin , GPIO_PIN_RESET ); /*Configure GPIO pin : BUTTON_Pin */ GPIO_InitStruct . Pin = BUTTON_Pin ; GPIO_InitStruct . Mode = GPIO_MODE_INPUT ; GPIO_InitStruct . Pull = GPIO_NOPULL ; HAL_GPIO_Init ( BUTTON_GPIO_Port , & GPIO_InitStruct ); /*Configure GPIO pin : LED_Pin */ GPIO_InitStruct . Pin = LED_Pin ; GPIO_InitStruct . Mode = GPIO_MODE_OUTPUT_PP ; GPIO_InitStruct . Pull = GPIO_NOPULL ; GPIO_InitStruct . Speed = GPIO_SPEED_FREQ_LOW ; HAL_GPIO_Init ( LED_GPIO_Port , & GPIO_InitStruct ); } 3.4. User code \u2693\ufe0e Add some lines of code to implement the application requirements in the main while loop. Note that, the button is active high, it means if the button is pressed, it pulls the input pin to a High logic level. int main ( void ) { while ( 1 ) { if ( HAL_GPIO_ReadPin ( BUTTON_GPIO_Port , BUTTON_Pin ) == GPIO_PIN_SET ) { HAL_GPIO_WritePin ( LED_GPIO_Port , LED_Pin , GPIO_PIN_SET ); HAL_Delay ( 100 ); HAL_GPIO_WritePin ( LED_GPIO_Port , LED_Pin , GPIO_PIN_RESET ); HAL_Delay ( 100 ); } else { HAL_GPIO_WritePin ( LED_GPIO_Port , LED_Pin , GPIO_PIN_SET ); HAL_Delay ( 500 ); HAL_GPIO_WritePin ( LED_GPIO_Port , LED_Pin , GPIO_PIN_RESET ); HAL_Delay ( 500 ); } } } 3.5. Download to the board \u2693\ufe0e After compiling, download the firmware to the board and observe the LED in action with the button. There is some delay between the blink pattern (500ms to 100ms), because in current source code, the delay function prevents MCU to react immediately to user\u2019s action. 4. Lab 2: Button interrupt \u2693\ufe0e Requirement An LED and A Push button Press on the button to toggle and print out the number of raising edges Target board Any board that has GPIOs connected to an LED and a button. In this tutorial, a STM32F0 Discovery board with the connection being the same as the previous lab. 4.1. Setup new project \u2693\ufe0e Start a new project in the same steps described in the previous section. 4.2. Setup external interrupt \u2693\ufe0e To detect the raising edge, button has to be configured as an External Interrupt Mode with Raising Edge trigger detection . To enable interrupt, under the NVIC tab, check on the EXTI line 0 and line 1 interrupt option. Enable External Interrupt mode on the button pin 4.3. Generated code \u2693\ufe0e Note that the generated function to set up GPIO has changed to configure the Button pin to interrupt mode, and enable the external interrupt line. Read more in Interrupt . static void MX_GPIO_Init ( void ) { ... /*Configure GPIO pin : BUTTON_Pin */ GPIO_InitStruct . Pin = BUTTON_Pin ; GPIO_InitStruct . Mode = GPIO_MODE_IT_RISING ; GPIO_InitStruct . Pull = GPIO_NOPULL ; HAL_GPIO_Init ( BUTTON_GPIO_Port , & GPIO_InitStruct ); ... HAL_NVIC_SetPriority ( EXTI0_1_IRQn , 0 , 0 ); HAL_NVIC_EnableIRQ ( EXTI0_1_IRQn ); } In the file stm32f0xx_it.c , there is an implementation of the interrupt handler EXTI0_1_IRQHandler() which calls to HAL function HAL_GPIO_EXTI_IRQHandler() to clear the pending interrupt flag and finally transfer the work to user\u2019s application if there is an overridden function HAL_GPIO_EXTI_Callback() . 4.4. Handler interrupt \u2693\ufe0e As mentioned above, the HAL_GPIO_EXTI_Callback() will be called to transfer the right to user\u2019s application to handle the interrupt. Firstly, whenever the raising edge is detected, the callback will be called to increase a counter: void HAL_GPIO_EXTI_Callback ( uint16_t GPIO_Pin ) { HAL_GPIO_TogglePin ( LED_GPIO_Port , LED_Pin ); } Inside the main while loop, just repeatedly delay in 1000ms. int main () { while ( 1 ) { HAL_Delay ( 1000 ); } } Run the program, and slowly press the button, the LED sometimes does not toggle the state. Using a logic analyzer to see that The logic level is unstable during the transition, it causes multiple raising and falling edge before coming to stable. This is called Bouncing input . To eliminate it, debouncing the input by additional hardware or an internal timer. Bouncing input on button","title":"GPIO"},{"location":"blog/stm32/gpio/#1-hardware","text":"Each GPIO Pin has a complex structure to function as both input and output: Protection Diodes Pull-up and Pull-down resistors on input Schmitt triggers to convert input to digital value Open-Drain or Push-Pull gate on output Multiplexer for Alternate Function Input and Output data registers Control registers A GPIO pin structure","title":"1. Hardware"},{"location":"blog/stm32/gpio/#11-voltage-and-current","text":"Always assume that all GPIO pins are NOT 5V tolerant by default until find out in the datasheet (such as DS8668 for STM32F0x) that a specific pin is 5V tolerant, only then it can be used as a 5V pin. The maximum current that could be sourced or sunk into any GPIO pin is 25mA as mentioned in the datasheet.","title":"1.1. Voltage and Current"},{"location":"blog/stm32/gpio/#12-input-mode","text":"Input Floating (Hi-Z) Input Pull-Up Input Pull-Down Read about Pull-Up/ Pull-Down When a GPIO pin is set to the input mode, the data present on the I/O pin is sampled into the Input Data Register (IDR) every APB2 clock cycle. This means the APB2 bus speed determines the input sampling speed for the GPIO pins.","title":"1.2. Input mode"},{"location":"blog/stm32/gpio/#13-output-mode","text":"Output Open-Drain Output Push-Pull Read about Open-Drain and Push-pull When a GPIO pin is set to the output mode, there is an option to configure the pin speed mode. Refer to datasheet (e.g. DS8668) to check the I/O AC characteristics table to note the maximum frequency in different conditions.","title":"1.3. Output mode"},{"location":"blog/stm32/gpio/#14-output-speed","text":"GPIO speed is not related to switching frequency, it defines the slew rate of a GPIO, that is how fast it goes from the 0V level to VDD one, and vice versa. Below image shows the slew rate of 2 speed modes: Red line: high speed Blue line: low speed Slew rate of 2 speed modes","title":"1.4. Output Speed"},{"location":"blog/stm32/gpio/#15-bit-atomic-operation","text":"There is no need for the software to disable interrupts when programming the Output Data Register (ODR) at bit level. Use Bit Set/Reset Register ( BSRR ) to select individual bit operation.","title":"1.5. Bit atomic operation"},{"location":"blog/stm32/gpio/#16-input-interrupt","text":"When in input mode, all ports have external interrupt capability. Read more about Interrupt .","title":"1.6. Input interrupt"},{"location":"blog/stm32/gpio/#17-alternate-function","text":"Alternate Function Push-Pull Alternate Function Open-Drain Pin can be used for an alternate function from a peripheral by setting the Alternate Function register (AF).","title":"1.7. Alternate function"},{"location":"blog/stm32/gpio/#18-analog-inputoutput","text":"In analog mode, pin is directly wired to an analog module (ADC, DAC)","title":"1.8. Analog input/output"},{"location":"blog/stm32/gpio/#19-locking-pin","text":"The locking mechanism allows the IO configuration to be frozen. When the LOCK sequence has been applied on a port bit, it is no longer possible to modify the value of the port bit until the next reset.","title":"1.9. Locking pin"},{"location":"blog/stm32/gpio/#2-stm32cubehal-usage","text":"The Hardware Abstract Layer (HAL) is designed so that it abstracts from the specific peripheral memory mapping. But, it also provides a general and more user-friendly way to configure the peripheral, without forcing the programmers to now how to configure its registers in detail. Excerpt from Description of STM32F0 HAL and low-layer drivers How to use GPIO HAL Enable the GPIO AHB clock using the following function : __HAL_RCC_GPIOx_CLK_ENABLE() . Configure the GPIO pin(s) using HAL_GPIO_Init() . Configure the IO mode using Mode member from GPIO_InitTypeDef structure Analog mode is required when a pin is to be used as ADC channel or DAC output. In case of external interrupt/event, select the type (interrupt or event) and the corresponding trigger event (rising or falling or both). Activate Pull-up, Pull-down resistor using Pull member from GPIO_InitTypeDef structure. In case of Output or alternate function mode selection: the speed is configured through Speed member from GPIO_InitTypeDef structure. In alternate mode is selection, the alternate function connected to the IO is configured through Alternate member from GPIO_InitTypeDef structure. In case of external interrupt/event mode selection, configure NVIC IRQ priority mapped to the EXTI line using HAL_NVIC_SetPriority() and enable it using HAL_NVIC_EnableIRQ() . HAL_GPIO_DeInit allows setting register values to their reset value. It\u2019s also recommended using it to non-configure pin which was used as an external interrupt or in event mode. That\u2019s the only way to reset corresponding bit in EXTI & SYSCFG registers. To get the level of a pin configured in input mode use HAL_GPIO_ReadPin() . To set/reset the level of a pin configured in output mode use HAL_GPIO_WritePin() or HAL_GPIO_TogglePin() . To lock pin configuration until next reset use HAL_GPIO_LockPin() . During and just after reset, the alternate functions are not active and the GPIO pins are configured in input floating mode (except JTAG pins). The LSE oscillator pins OSC32_IN and OSC32_OUT can be used as general purpose ( PC14 and PC15 ,respectively) when the LSE oscillator is off. The LSE has priority over the GPIO function. The HSE oscillator pins OSC_IN and OSC_OUT can be used as general purpose PF0 and PF1 , respectively, when the HSE oscillator is off. The HSE has priority over the GPIO function.","title":"2. STM32CubeHAL Usage"},{"location":"blog/stm32/gpio/#3-lab-1-blink-led","text":"Requirement An LED and a Push button Blink the LED every 100ms when press and hold a button Blink the LED every 500ms when the button is released Target board Any board that has GPIOs connected to an LED and a button. In this tutorial, a STM32F0 Discovery board will be used, the schematic shows below connection: STM32F051R8 Mode External peripheral PC8 Output Push Pull, No Pull-up and No Pull-down Blue LED PA0 Input, No Pull-up and No Pull-down Push button, active High The Blue LED and the Push button on STM32F0 Discovery board","title":"3. Lab 1: Blink Led"},{"location":"blog/stm32/gpio/#31-setup-new-project","text":"Before starting to write code to blink the LED, there are some steps need to be done to set up the MCU. It is easy to do with support from STM32CubeMX. Select the MCU The STM32F0 Discovery board has STM32F051R8 MCU. Set up clocks Under the Clock Configuration tab: PLL Source is HSI , with PLL Multiplier is 12 Set HCLK to 48 MHz Set up debugger To program code to the target MCU, go to the System Core under the Pinout & Configuration tab to select SYS module: Enable Debug Serial Wire This will automatically assign PA14 to SWCLK and PA13 to SWDIO, which are pins to communicate with debugger on SWD interface","title":"3.1. Setup new project"},{"location":"blog/stm32/gpio/#32-setup-led-and-button","text":"Under the Pinout View, Left-click on PC8 and set as a GPIO_Output , on PA0 and set as a GPIO_Input . Right-click on these pins to set new name for them, such as LED and BUTTON . Set GPIO mode for pins","title":"3.2. Setup LED and Button"},{"location":"blog/stm32/gpio/#33-generated-source-code","text":"Save the STM32CubeMX settings by Ctrl + S ,and then press Alt + K to start generating source code. Custom defines Any custom name for a pin will be defined in main.h : main.h #define BUTTON_Pin GPIO_PIN_0 #define BUTTON_GPIO_Port GPIOA #define LED_Pin GPIO_PIN_8 #define LED_GPIO_Port GPIOC Initializing functions In the main.c , IDE generates SystemClock_Config() to set up system clocks, and MX_GPIO_Init() to initialize GPIOs. main.c static void MX_GPIO_Init ( void ) { GPIO_InitTypeDef GPIO_InitStruct = { 0 }; /* GPIO Ports Clock Enable */ __HAL_RCC_GPIOA_CLK_ENABLE (); __HAL_RCC_GPIOC_CLK_ENABLE (); /*Configure GPIO pin Output Level */ HAL_GPIO_WritePin ( LED_GPIO_Port , LED_Pin , GPIO_PIN_RESET ); /*Configure GPIO pin : BUTTON_Pin */ GPIO_InitStruct . Pin = BUTTON_Pin ; GPIO_InitStruct . Mode = GPIO_MODE_INPUT ; GPIO_InitStruct . Pull = GPIO_NOPULL ; HAL_GPIO_Init ( BUTTON_GPIO_Port , & GPIO_InitStruct ); /*Configure GPIO pin : LED_Pin */ GPIO_InitStruct . Pin = LED_Pin ; GPIO_InitStruct . Mode = GPIO_MODE_OUTPUT_PP ; GPIO_InitStruct . Pull = GPIO_NOPULL ; GPIO_InitStruct . Speed = GPIO_SPEED_FREQ_LOW ; HAL_GPIO_Init ( LED_GPIO_Port , & GPIO_InitStruct ); }","title":"3.3. Generated source code"},{"location":"blog/stm32/gpio/#34-user-code","text":"Add some lines of code to implement the application requirements in the main while loop. Note that, the button is active high, it means if the button is pressed, it pulls the input pin to a High logic level. int main ( void ) { while ( 1 ) { if ( HAL_GPIO_ReadPin ( BUTTON_GPIO_Port , BUTTON_Pin ) == GPIO_PIN_SET ) { HAL_GPIO_WritePin ( LED_GPIO_Port , LED_Pin , GPIO_PIN_SET ); HAL_Delay ( 100 ); HAL_GPIO_WritePin ( LED_GPIO_Port , LED_Pin , GPIO_PIN_RESET ); HAL_Delay ( 100 ); } else { HAL_GPIO_WritePin ( LED_GPIO_Port , LED_Pin , GPIO_PIN_SET ); HAL_Delay ( 500 ); HAL_GPIO_WritePin ( LED_GPIO_Port , LED_Pin , GPIO_PIN_RESET ); HAL_Delay ( 500 ); } } }","title":"3.4. User code"},{"location":"blog/stm32/gpio/#35-download-to-the-board","text":"After compiling, download the firmware to the board and observe the LED in action with the button. There is some delay between the blink pattern (500ms to 100ms), because in current source code, the delay function prevents MCU to react immediately to user\u2019s action.","title":"3.5. Download to the board"},{"location":"blog/stm32/gpio/#4-lab-2-button-interrupt","text":"Requirement An LED and A Push button Press on the button to toggle and print out the number of raising edges Target board Any board that has GPIOs connected to an LED and a button. In this tutorial, a STM32F0 Discovery board with the connection being the same as the previous lab.","title":"4. Lab 2: Button interrupt"},{"location":"blog/stm32/gpio/#41-setup-new-project","text":"Start a new project in the same steps described in the previous section.","title":"4.1. Setup new project"},{"location":"blog/stm32/gpio/#42-setup-external-interrupt","text":"To detect the raising edge, button has to be configured as an External Interrupt Mode with Raising Edge trigger detection . To enable interrupt, under the NVIC tab, check on the EXTI line 0 and line 1 interrupt option. Enable External Interrupt mode on the button pin","title":"4.2. Setup external interrupt"},{"location":"blog/stm32/gpio/#43-generated-code","text":"Note that the generated function to set up GPIO has changed to configure the Button pin to interrupt mode, and enable the external interrupt line. Read more in Interrupt . static void MX_GPIO_Init ( void ) { ... /*Configure GPIO pin : BUTTON_Pin */ GPIO_InitStruct . Pin = BUTTON_Pin ; GPIO_InitStruct . Mode = GPIO_MODE_IT_RISING ; GPIO_InitStruct . Pull = GPIO_NOPULL ; HAL_GPIO_Init ( BUTTON_GPIO_Port , & GPIO_InitStruct ); ... HAL_NVIC_SetPriority ( EXTI0_1_IRQn , 0 , 0 ); HAL_NVIC_EnableIRQ ( EXTI0_1_IRQn ); } In the file stm32f0xx_it.c , there is an implementation of the interrupt handler EXTI0_1_IRQHandler() which calls to HAL function HAL_GPIO_EXTI_IRQHandler() to clear the pending interrupt flag and finally transfer the work to user\u2019s application if there is an overridden function HAL_GPIO_EXTI_Callback() .","title":"4.3. Generated code"},{"location":"blog/stm32/gpio/#44-handler-interrupt","text":"As mentioned above, the HAL_GPIO_EXTI_Callback() will be called to transfer the right to user\u2019s application to handle the interrupt. Firstly, whenever the raising edge is detected, the callback will be called to increase a counter: void HAL_GPIO_EXTI_Callback ( uint16_t GPIO_Pin ) { HAL_GPIO_TogglePin ( LED_GPIO_Port , LED_Pin ); } Inside the main while loop, just repeatedly delay in 1000ms. int main () { while ( 1 ) { HAL_Delay ( 1000 ); } } Run the program, and slowly press the button, the LED sometimes does not toggle the state. Using a logic analyzer to see that The logic level is unstable during the transition, it causes multiple raising and falling edge before coming to stable. This is called Bouncing input . To eliminate it, debouncing the input by additional hardware or an internal timer. Bouncing input on button","title":"4.4. Handler interrupt"},{"location":"blog/stm32/i2c-spi/","text":"F051R8_I2C_Scanner.zip 1. I2C \u2693\ufe0e The Inter-Integrated Circuit (I2C) is a multi-slave, half-duplex, single-ended 8-bit oriented serial bus specification, which uses only two wires to interconnect a given number of slave devices to a master. An I2C bus Like SPI, I2C is synchronous, so the output of bits is synchronized to the sampling of bits by a clock signal shared between the master and the slave. The clock signal is always controlled by the master. The two wires forming an I2C bus are bidirectional open-drain lines, named Serial Data Line ( SDA ) and Serial Clock Line ( SCL ) respectively. The I2C protocol specifies that these two lines need to be pulled up with resistors. It is quite common to use resistors with a value close to 4.7 K\u03a9. Refer to this guide to calculate the resistors in different use cases. Modern microcontrollers, like STM32 ones, allow configuring GPIO lines as open-drain pull-up , enabling internal pull-up resistors. However, the internal pull-up resistors have a value close to 20 K\u03a9 to avoid unwanted power leaks. Such a value increases the time needed by the bus to reach the HIGH state, reducing the transmission speed. Therefore, it is strongly suggested to use external and dedicated pull-up resistors and disable the internal ones. Being a protocol based on just two wires, there should be a way to address an individual slave device on the same bus. For this reason, I2C defines that each slave device provides a unique slave address for the given bus. The address may be 7- or 10-bit wide (this last option is quite uncommon). I2C works on different speed rate as below: Standard : 100 Kbps Fast mode : 400 Kbps Fast mode plus : 1 Mbps High speed mode : 3.4 Mbps Ultra fast mode : 5 Mbps In the I2C protocol all transactions are always initiated and completed by the master. This is one of the few rules of this communication protocol to keep in mind while programming (and, especially, debugging) I2C devices. All messages exchanged over the I2C bus are broken up into two types of frame: An address frame, where the master indicates to which slave the message is being sent, and one or more data frames, which are 8-bit data messages passed from master to slave or vice versa. Data is placed on the SDA line after SCL goes low, and it is sampled after the SCL line goes high. The time between clock edges and data read/write is defined by devices on the bus, and it varies from chip to chip. An I2C Message The least significant bit (LSB) in the Address byte is the Read/Write mode. 1 means Read , while 0 means Write . Therefore, when refer to the address of I2C device, usually, it is known as the Write Address (8-bit address mode). Sometimes, it is written as 7-bit and needed to add one bit for Read/Write mode. For example:Device Address = 0xEE means Write address is 0xEE and Read Address is 0xEF . Some people will write Device Address = 0x77 (in 7-bit mode), then do calculation (0x77 << 1) + 0 = 0xEE for write mode, and do (0x77 << 1) + 1 = 0xEF for read mode. The number of bytes that can be transmitted per transfer is unrestricted. Each byte must be followed by an Acknowledgment ( ACK ) bit. Data is transferred with the Most Significant Bit (MSB) first. The ACK takes place after every byte. The ACK bit allows the receiver to signal the transmitter that the byte was successfully received, and another byte may be sent. The master generates all clock pulses over the SCL line, including the ACK ninth clock pulse. 2. SPI \u2693\ufe0e The Serial Peripheral Interface (SPI) is a specification about serial, synchronous and full-duplex communications between a master controller and several slave devices. The nature of the SPI interface allows full duplex as well as half duplex communications over the same bus. Different from the I2C protocol, the SPI specification does not force a given message protocol over its bus, but it is limited to bus signaling giving to slave devices total freedom about the structure of exchanged messages. An SPI bus In SPI, only one side generates the clock signal (usually called CLK or SCK for Serial Clock). The side that generates the clock is called the \u201cmaster\u201d, and the other side is called the \u201cslave\u201d. There is always only one master (which is almost always a microcontroller), but there can be multiple slaves (more on this in a bit). When data is sent from the master to a slave, it\u2019s sent on a data line called MOSI , for \u201cMaster Out / Slave In\u201d. If the slave needs to send a response back to the master, the master will continue to generate a prearranged number of clock cycles, and the slave will put the data onto a third data line called MISO , for \u201cMaster In / Slave Out\u201d. SCK : this signal I/O is used to generate the clock to synchronize data transfer over the SPI bus. It is generated by the master device, and this means that in an SPI bus every transfer is always started by the master. Different from the I2C specification, the SPI is intrinsically faster and the SPI clock speed is usually several MHz. Nowadays is quite common to find SPI devices able to exchange data at a rate up to 100MHz. Moreover, the SPI protocol allows to devices with different communication speeds to coexist over the same bus. MOSI : the name of this signal I/O stands for Master Output Slave Input , and it is used to send data from the master device to a slave one. Different from the I2C bus, where just one wire is used to exchange data both the ways, the SPI protocol defines two distinct lines to exchange data between master and slaves. MISO : it stands for Master Input Slave Output , and it corresponds to the I/O line used to send data from a slave device to the master. SSn : it stands for Slave Select and in a typical SPI bus there exist n separated lines used to address the specific SPI devices involved in a transaction. Different from the I2C protocol, the SPI does not use slave addresses to select devices, but it demands this operation to a physical line that is asserted LOW to perform a selection. In a typical SPI bus only one slave device can be active at same time by asserting low its SS line. This is the reason why devices with different communication speed can coexist on the same bus Half-duplex data exchange on SPI bus Full-duplex data exchange on SPI bus Reading data Notice it\u2019s said \u201cprearranged\u201d in the above description. Because the master always generates the clock signal, it must know in advance when a slave needs to return data and how much data will be returned. This is very different than asynchronous serial, where random amounts of data can be sent in either direction at any time. In practice this isn\u2019t a problem, as SPI is generally used to talk to sensors that have a very specific command structure. In cases of a variable amount of data, slave could always return one or two bytes specifying the length of the data and then have the master retrieve the full amount after that. Note that SPI is \u201cfull duplex\u201d (has separate send and receive lines), and, thus, in certain situations, SPI can transmit and receive data at the same time (for example, requesting a new sensor reading while retrieving the data from the previous one). In addition to setting the bus clock frequency, the master and slaves must also agree on the clock polarity and phase with respect to the data exchanged over MOSI and MISO lines. At CPOL=0 the base value of the clock is zero, i.e. the active state is 1 and idle state is 0. For CPHA=0 , data is captured on the SCK rising edge (LOW \u2192 HIGH transition) and data is output on a falling edge (HIGH \u2192 LOW clock transition). For CPHA=1 , data is captured on the SCK falling edge and data is output on a rising edge. At CPOL=1 the base value of the clock is one (inversion of CPOL=0), i.e. the active state is 0 and idle state is 1. For CPHA=0 , data is captured on SCK falling edge and data is output on a rising edge. For CPHA=1 , data is captured on SCK rising edge and data is output on a falling edge. Clock timing for data capture in difference of CPOL and CPHA 3. I2C vs SPI \u2693\ufe0e Here are important differences between I2C and SPI protocols. Advantages are in bold text. I2C SPI Multi-master and multi-slave Single-master and multi-slave Two wires At least 4 wires Half-duplex Full-duplex Clock stretching If the slave cannot be able to send data fast enough then it suppresses the clock to stop the communication N/A Slow speed High speed Less susceptible to noise More susceptible to noise Acknowledgment bit after each byte \u2192 More reliable N/A Extra overhead due to start and stop bits No overhead , no start-stop bits Long distance Short distance Why is I2C slower than SPI? Firstly, at the same bit rate, I2C has overhead of extra bits for the address byte, start and stop bit, and an ack for every data byte. SPI does not have those information. Secondary, a hardware problem, I2C use open-collector lines which means the transmitter only drives the line to low. The speed on the I2C lines depends on the capacitance and the pull-up resistor. 4. Working modes \u2693\ufe0e Like other peripheral, both I2C and SPI support Polling, Interrupt and DMA mode. In high bit rate, DMA should be used to avoid overlapped interrupts. SPI is dropped when using Interrupt at high bit rate Take an example of SPI on 10 Mbps, which will generate 1.25 millions interrupts per second (!) in case of 8-bit transfer. An STM32L4xx running at 80 MHz will have a room of only 64 cycles to process an Interrupt. However, calling an interrupt takes 12 cycle, exiting an interrupt costs 10 cycles (ideal state without waiting). Therefore, an interrupt code must be served in only 42 cycles ! Should use DMA when the bit rate is high, because DMA only causes 2 interrupts: \u201cHalf-transfer\u201d and \u201cTransfer-Complete\u201d in a routine of transfer a large data buffer. Maximum SPI frequency in different modes Excerpt from source code stm32xxxx_hal_spi.c DataSize = SPI_DATASIZE_8BIT: +----------------------------------------------------------------------------------------------+ | | | 2Lines Fullduplex | 2Lines RxOnly | 1Line | | Process | Transfer mode |---------------------|----------------------|----------------------| | | | Master | Slave | Master | Slave | Master | Slave | |==============================================================================================| | T | Polling | Fpclk/4 | Fpclk/8 | NA | NA | NA | NA | | X |----------------|----------|----------|-----------|----------|-----------|----------| | / | Interrupt | Fpclk/4 | Fpclk/16 | NA | NA | NA | NA | | R |----------------|----------|----------|-----------|----------|-----------|----------| | X | DMA | Fpclk/2 | Fpclk/2 | NA | NA | NA | NA | |=========|================|==========|==========|===========|==========|===========|==========| | | Polling | Fpclk/4 | Fpclk/8 | Fpclk/16 | Fpclk/8 | Fpclk/8 | Fpclk/8 | | |----------------|----------|----------|-----------|----------|-----------|----------| | R | Interrupt | Fpclk/8 | Fpclk/16 | Fpclk/8 | Fpclk/8 | Fpclk/8 | Fpclk/4 | | X |----------------|----------|----------|-----------|----------|-----------|----------| | | DMA | Fpclk/4 | Fpclk/2 | Fpclk/2 | Fpclk/16 | Fpclk/2 | Fpclk/16 | |=========|================|==========|==========|===========|==========|===========|==========| | | Polling | Fpclk/8 | Fpclk/2 | NA | NA | Fpclk/8 | Fpclk/8 | | |----------------|----------|----------|-----------|----------|-----------|----------| | T | Interrupt | Fpclk/2 | Fpclk/4 | NA | NA | Fpclk/16 | Fpclk/8 | | X |----------------|----------|----------|-----------|----------|-----------|----------| | | DMA | Fpclk/2 | Fpclk/2 | NA | NA | Fpclk/8 | Fpclk/16 | +----------------------------------------------------------------------------------------------+ DataSize = SPI_DATASIZE_16BIT: +----------------------------------------------------------------------------------------------+ | | | 2Lines Fullduplex | 2Lines RxOnly | 1Line | | Process | Transfer mode |---------------------|----------------------|----------------------| | | | Master | Slave | Master | Slave | Master | Slave | |==============================================================================================| | T | Polling | Fpclk/4 | Fpclk/8 | NA | NA | NA | NA | | X |----------------|----------|----------|-----------|----------|-----------|----------| | / | Interrupt | Fpclk/4 | Fpclk/16 | NA | NA | NA | NA | | R |----------------|----------|----------|-----------|----------|-----------|----------| | X | DMA | Fpclk/2 | Fpclk/2 | NA | NA | NA | NA | |=========|================|==========|==========|===========|==========|===========|==========| | | Polling | Fpclk/4 | Fpclk/8 | Fpclk/16 | Fpclk/8 | Fpclk/8 | Fpclk/8 | | |----------------|----------|----------|-----------|----------|-----------|----------| | R | Interrupt | Fpclk/8 | Fpclk/16 | Fpclk/8 | Fpclk/8 | Fpclk/8 | Fpclk/4 | | X |----------------|----------|----------|-----------|----------|-----------|----------| | | DMA | Fpclk/4 | Fpclk/2 | Fpclk/2 | Fpclk/16 | Fpclk/2 | Fpclk/16 | |=========|================|==========|==========|===========|==========|===========|==========| | | Polling | Fpclk/8 | Fpclk/2 | NA | NA | Fpclk/8 | Fpclk/8 | | |----------------|----------|----------|-----------|----------|-----------|----------| | T | Interrupt | Fpclk/2 | Fpclk/4 | NA | NA | Fpclk/16 | Fpclk/8 | | X |----------------|----------|----------|-----------|----------|-----------|----------| | | DMA | Fpclk/2 | Fpclk/2 | NA | NA | Fpclk/8 | Fpclk/16 | +----------------------------------------------------------------------------------------------+ 5. STM32CubeHAL Usage \u2693\ufe0e The Hardware Abstract Layer (HAL) is designed so that it abstracts from the specific peripheral memory mapping. But, it also provides a general and more user-friendly way to configure the peripheral, without forcing the programmers to now how to configure its registers in detail. Excerpt from Description of STM32F0 HAL and low-layer drivers 5.1. I2C HAL \u2693\ufe0e Declare a I2C_HandleTypeDef handle structure, for example: I2C_HandleTypeDef hi2c ; Initialize the I2C low level resources by implementing the HAL_I2C_MspInit() API: Enable the I2Cx interface clock I2C pins configuration Enable the clock for the I2C GPIOs Configure I2C pins as alternate function open-drain NVIC configuration if you need to use interrupt process Configure the I2Cx interrupt priority Enable the NVIC I2C IRQ Channel DMA Configuration if you need to use DMA process Declare a DMA_HandleTypeDef handle structure for to transmit or receive channel Enable the DMAx interface clock using Configure the DMA handle parameters Configure the DMA Tx or Rx channel Associate the initialized DMA handle to the hi2c DMA Tx or Rx handle Configure the priority and enable the NVIC for the transfer complete interrupt on the DMA Tx or Rx channel Configure the Communication Clock Timing , Own Address1 , Master Addressing mode , Dual Addressing mode , Own Address2 , Own Address2 Mask , General call and No-Stretch mode in the hi2c structure. Initialize the I2C registers by calling the HAL_I2C_Init() , configures also the low level Hardware (GPIO, CLOCK, NVIC\u2026etc.) by calling the customized HAL_I2C_MspInit(&hi2c) API. To check if target device is ready for communication, use the function HAL_I2C_IsDeviceReady() For I2C IO and IO MEM operations, three operation modes are available within this driver: Polling mode IO operation Transmit in master mode an amount of data in blocking mode using HAL_I2C_Master_Transmit() Receive in master mode an amount of data in blocking mode using HAL_I2C_Master_Receive() Transmit in slave mode an amount of data in blocking mode using HAL_I2C_Slave_Transmit() Receive in slave mode an amount of data in blocking mode using HAL_I2C_Slave_Receive() Polling mode IO MEM operation Write an amount of data in blocking mode to a specific memory address using HAL_I2C_Mem_Write() Read an amount of data in blocking mode from a specific memory address using HAL_I2C_Mem_Read() Interrupt mode IO operation Transmit in master mode an amount of data in non-blocking mode using HAL_I2C_Master_Transmit_IT() At transmission end of transfer, HAL_I2C_MasterTxCpltCallback() is executed and user can add his own code by customization of function pointer HAL_I2C_MasterTxCpltCallback() Receive in master mode an amount of data in non-blocking mode using HAL_I2C_Master_Receive_IT() At reception end of transfer, HAL_I2C_MasterRxCpltCallback() is executed and user can add his own code by customization of function pointer HAL_I2C_MasterRxCpltCallback() Transmit in slave mode an amount of data in non-blocking mode using HAL_I2C_Slave_Transmit_IT() At transmission end of transfer, HAL_I2C_SlaveTxCpltCallback() is executed and user can add his own code by customization of function pointer HAL_I2C_SlaveTxCpltCallback() Receive in slave mode an amount of data in non-blocking mode using HAL_I2C_Slave_Receive_IT() At reception end of transfer, HAL_I2C_SlaveRxCpltCallback() is executed and user can add his own code by customization of function pointer HAL_I2C_SlaveRxCpltCallback() In case of transfer Error, HAL_I2C_ErrorCallback() function is executed and user can add his own code by customization of function pointer HAL_I2C_ErrorCallback() Abort a master I2C process communication with Interrupt using HAL_I2C_Master_Abort_IT() End of abort process, HAL_I2C_AbortCpltCallback() is executed and user can add his own code by customization of function pointer HAL_I2C_AbortCpltCallback() Discard a slave I2C process communication using __HAL_I2C_GENERATE_NACK() macro. This action will inform Master to generate a Stop condition to discard the communication. 5.2. SPI HAL \u2693\ufe0e Declare a SPI_HandleTypeDef handle structure, for example: SPI_HandleTypeDef hspi; Initialize the SPI low level resources by implementing the HAL_SPI_MspInit() API: Enable the SPIx interface clock SPI pins configuration Enable the clock for the SPI GPIOs Configure these SPI pins as alternate function push-pull NVIC configuration if you need to use interrupt process Configure the SPIx interrupt priority Enable the NVIC SPI IRQ handle DMA Configuration if you need to use DMA process Declare a DMA_HandleTypeDef handle structure to transmit or receive Stream/Channel Enable the DMAx clock Configure the DMA handle parameters Configure the DMA Tx or Rx Stream/Channel Associate the initialized hdma_tx handle to the hspi DMA Tx or Rx handle Configure the priority and enable the NVIC for the transfer complete interrupt on the DMA Tx or Rx Stream/Channel Program the Mode, Bidirectional Mode, Data size, Baud rate Pre-scaler, NSS management, Clock polarity and phase, First Bit and CRC configuration in the hspi initial structure. Initialize the SPI registers by calling the HAL_SPI_Init() API: This API configures also the low level hardware (GPIO, CLOCK, CORTEX\u2026etc.) by calling the customized HAL_SPI_MspInit() API. Circular mode restriction: The DMA circular mode cannot be used when the SPI is configured in these modes: Master 2 Lines Rx Only Master 1 Line Rx The CRC feature is not managed when the DMA circular mode is enabled When the SPI DMA Pause/Stop features are used, you must use the following APIs the HAL_SPI_DMAPause() / HAL_SPI_DMAStop() only under the SPI callbacks Master Receive mode restriction: In Master unidirectional receive-only mode ( MSTR=1 , BIDIMODE=0 , RXONLY=0 ) or bidirectional receive mode ( MSTR=1 , BIDIMODE=1 , BIDIOE=0 ), to ensure that the SPI does not initiate a new transfer the following procedure has to be respected: HAL_SPI_DeInit() HAL_SPI_Init() Data buffer address alignment restriction: In case more than 1 byte is requested to be transferred, the HAL SPI uses 16-bit access for data buffer. But there is no support for unaligned accesses on the Cortex-M0 processor. So, if the user wants to transfer more than 1 byte, it shall ensure that 16-bit aligned address is used for: pData parameter in HAL_SPI_Transmit() , HAL_SPI_Transmit_IT() , HAL_SPI_Receive() and HAL_SPI_Receive_IT() pTxData and pRxData parameters in HAL_SPI_TransmitReceive() and HAL_SPI_TransmitReceive_IT() There is no such restriction when going through DMA by using HAL_SPI_Transmit_DMA() , HAL_SPI_Receive_DMA() and HAL_SPI_TransmitReceive_DMA() . The HAL drivers do not allow reaching all supported SPI frequencies in the different SPI modes. Refer to the source code ( stm32xxxx_hal_spi.c header) to get a summary of the maximum SPI frequency that can be reached with a data size of 8 or 16 bits, depending on the APBx peripheral clock frequency ( fPCLK ) used by the SPI instance. Example projects Refer to SSD1306 OLED to see examples using I2C and SPI protocol.","title":"I2C - SPI"},{"location":"blog/stm32/i2c-spi/#1-i2c","text":"The Inter-Integrated Circuit (I2C) is a multi-slave, half-duplex, single-ended 8-bit oriented serial bus specification, which uses only two wires to interconnect a given number of slave devices to a master. An I2C bus Like SPI, I2C is synchronous, so the output of bits is synchronized to the sampling of bits by a clock signal shared between the master and the slave. The clock signal is always controlled by the master. The two wires forming an I2C bus are bidirectional open-drain lines, named Serial Data Line ( SDA ) and Serial Clock Line ( SCL ) respectively. The I2C protocol specifies that these two lines need to be pulled up with resistors. It is quite common to use resistors with a value close to 4.7 K\u03a9. Refer to this guide to calculate the resistors in different use cases. Modern microcontrollers, like STM32 ones, allow configuring GPIO lines as open-drain pull-up , enabling internal pull-up resistors. However, the internal pull-up resistors have a value close to 20 K\u03a9 to avoid unwanted power leaks. Such a value increases the time needed by the bus to reach the HIGH state, reducing the transmission speed. Therefore, it is strongly suggested to use external and dedicated pull-up resistors and disable the internal ones. Being a protocol based on just two wires, there should be a way to address an individual slave device on the same bus. For this reason, I2C defines that each slave device provides a unique slave address for the given bus. The address may be 7- or 10-bit wide (this last option is quite uncommon). I2C works on different speed rate as below: Standard : 100 Kbps Fast mode : 400 Kbps Fast mode plus : 1 Mbps High speed mode : 3.4 Mbps Ultra fast mode : 5 Mbps In the I2C protocol all transactions are always initiated and completed by the master. This is one of the few rules of this communication protocol to keep in mind while programming (and, especially, debugging) I2C devices. All messages exchanged over the I2C bus are broken up into two types of frame: An address frame, where the master indicates to which slave the message is being sent, and one or more data frames, which are 8-bit data messages passed from master to slave or vice versa. Data is placed on the SDA line after SCL goes low, and it is sampled after the SCL line goes high. The time between clock edges and data read/write is defined by devices on the bus, and it varies from chip to chip. An I2C Message The least significant bit (LSB) in the Address byte is the Read/Write mode. 1 means Read , while 0 means Write . Therefore, when refer to the address of I2C device, usually, it is known as the Write Address (8-bit address mode). Sometimes, it is written as 7-bit and needed to add one bit for Read/Write mode. For example:Device Address = 0xEE means Write address is 0xEE and Read Address is 0xEF . Some people will write Device Address = 0x77 (in 7-bit mode), then do calculation (0x77 << 1) + 0 = 0xEE for write mode, and do (0x77 << 1) + 1 = 0xEF for read mode. The number of bytes that can be transmitted per transfer is unrestricted. Each byte must be followed by an Acknowledgment ( ACK ) bit. Data is transferred with the Most Significant Bit (MSB) first. The ACK takes place after every byte. The ACK bit allows the receiver to signal the transmitter that the byte was successfully received, and another byte may be sent. The master generates all clock pulses over the SCL line, including the ACK ninth clock pulse.","title":"1. I2C"},{"location":"blog/stm32/i2c-spi/#2-spi","text":"The Serial Peripheral Interface (SPI) is a specification about serial, synchronous and full-duplex communications between a master controller and several slave devices. The nature of the SPI interface allows full duplex as well as half duplex communications over the same bus. Different from the I2C protocol, the SPI specification does not force a given message protocol over its bus, but it is limited to bus signaling giving to slave devices total freedom about the structure of exchanged messages. An SPI bus In SPI, only one side generates the clock signal (usually called CLK or SCK for Serial Clock). The side that generates the clock is called the \u201cmaster\u201d, and the other side is called the \u201cslave\u201d. There is always only one master (which is almost always a microcontroller), but there can be multiple slaves (more on this in a bit). When data is sent from the master to a slave, it\u2019s sent on a data line called MOSI , for \u201cMaster Out / Slave In\u201d. If the slave needs to send a response back to the master, the master will continue to generate a prearranged number of clock cycles, and the slave will put the data onto a third data line called MISO , for \u201cMaster In / Slave Out\u201d. SCK : this signal I/O is used to generate the clock to synchronize data transfer over the SPI bus. It is generated by the master device, and this means that in an SPI bus every transfer is always started by the master. Different from the I2C specification, the SPI is intrinsically faster and the SPI clock speed is usually several MHz. Nowadays is quite common to find SPI devices able to exchange data at a rate up to 100MHz. Moreover, the SPI protocol allows to devices with different communication speeds to coexist over the same bus. MOSI : the name of this signal I/O stands for Master Output Slave Input , and it is used to send data from the master device to a slave one. Different from the I2C bus, where just one wire is used to exchange data both the ways, the SPI protocol defines two distinct lines to exchange data between master and slaves. MISO : it stands for Master Input Slave Output , and it corresponds to the I/O line used to send data from a slave device to the master. SSn : it stands for Slave Select and in a typical SPI bus there exist n separated lines used to address the specific SPI devices involved in a transaction. Different from the I2C protocol, the SPI does not use slave addresses to select devices, but it demands this operation to a physical line that is asserted LOW to perform a selection. In a typical SPI bus only one slave device can be active at same time by asserting low its SS line. This is the reason why devices with different communication speed can coexist on the same bus Half-duplex data exchange on SPI bus Full-duplex data exchange on SPI bus Reading data Notice it\u2019s said \u201cprearranged\u201d in the above description. Because the master always generates the clock signal, it must know in advance when a slave needs to return data and how much data will be returned. This is very different than asynchronous serial, where random amounts of data can be sent in either direction at any time. In practice this isn\u2019t a problem, as SPI is generally used to talk to sensors that have a very specific command structure. In cases of a variable amount of data, slave could always return one or two bytes specifying the length of the data and then have the master retrieve the full amount after that. Note that SPI is \u201cfull duplex\u201d (has separate send and receive lines), and, thus, in certain situations, SPI can transmit and receive data at the same time (for example, requesting a new sensor reading while retrieving the data from the previous one). In addition to setting the bus clock frequency, the master and slaves must also agree on the clock polarity and phase with respect to the data exchanged over MOSI and MISO lines. At CPOL=0 the base value of the clock is zero, i.e. the active state is 1 and idle state is 0. For CPHA=0 , data is captured on the SCK rising edge (LOW \u2192 HIGH transition) and data is output on a falling edge (HIGH \u2192 LOW clock transition). For CPHA=1 , data is captured on the SCK falling edge and data is output on a rising edge. At CPOL=1 the base value of the clock is one (inversion of CPOL=0), i.e. the active state is 0 and idle state is 1. For CPHA=0 , data is captured on SCK falling edge and data is output on a rising edge. For CPHA=1 , data is captured on SCK rising edge and data is output on a falling edge. Clock timing for data capture in difference of CPOL and CPHA","title":"2. SPI"},{"location":"blog/stm32/i2c-spi/#3-i2c-vs-spi","text":"Here are important differences between I2C and SPI protocols. Advantages are in bold text. I2C SPI Multi-master and multi-slave Single-master and multi-slave Two wires At least 4 wires Half-duplex Full-duplex Clock stretching If the slave cannot be able to send data fast enough then it suppresses the clock to stop the communication N/A Slow speed High speed Less susceptible to noise More susceptible to noise Acknowledgment bit after each byte \u2192 More reliable N/A Extra overhead due to start and stop bits No overhead , no start-stop bits Long distance Short distance Why is I2C slower than SPI? Firstly, at the same bit rate, I2C has overhead of extra bits for the address byte, start and stop bit, and an ack for every data byte. SPI does not have those information. Secondary, a hardware problem, I2C use open-collector lines which means the transmitter only drives the line to low. The speed on the I2C lines depends on the capacitance and the pull-up resistor.","title":"3. I2C vs SPI"},{"location":"blog/stm32/i2c-spi/#4-working-modes","text":"Like other peripheral, both I2C and SPI support Polling, Interrupt and DMA mode. In high bit rate, DMA should be used to avoid overlapped interrupts. SPI is dropped when using Interrupt at high bit rate Take an example of SPI on 10 Mbps, which will generate 1.25 millions interrupts per second (!) in case of 8-bit transfer. An STM32L4xx running at 80 MHz will have a room of only 64 cycles to process an Interrupt. However, calling an interrupt takes 12 cycle, exiting an interrupt costs 10 cycles (ideal state without waiting). Therefore, an interrupt code must be served in only 42 cycles ! Should use DMA when the bit rate is high, because DMA only causes 2 interrupts: \u201cHalf-transfer\u201d and \u201cTransfer-Complete\u201d in a routine of transfer a large data buffer. Maximum SPI frequency in different modes Excerpt from source code stm32xxxx_hal_spi.c DataSize = SPI_DATASIZE_8BIT: +----------------------------------------------------------------------------------------------+ | | | 2Lines Fullduplex | 2Lines RxOnly | 1Line | | Process | Transfer mode |---------------------|----------------------|----------------------| | | | Master | Slave | Master | Slave | Master | Slave | |==============================================================================================| | T | Polling | Fpclk/4 | Fpclk/8 | NA | NA | NA | NA | | X |----------------|----------|----------|-----------|----------|-----------|----------| | / | Interrupt | Fpclk/4 | Fpclk/16 | NA | NA | NA | NA | | R |----------------|----------|----------|-----------|----------|-----------|----------| | X | DMA | Fpclk/2 | Fpclk/2 | NA | NA | NA | NA | |=========|================|==========|==========|===========|==========|===========|==========| | | Polling | Fpclk/4 | Fpclk/8 | Fpclk/16 | Fpclk/8 | Fpclk/8 | Fpclk/8 | | |----------------|----------|----------|-----------|----------|-----------|----------| | R | Interrupt | Fpclk/8 | Fpclk/16 | Fpclk/8 | Fpclk/8 | Fpclk/8 | Fpclk/4 | | X |----------------|----------|----------|-----------|----------|-----------|----------| | | DMA | Fpclk/4 | Fpclk/2 | Fpclk/2 | Fpclk/16 | Fpclk/2 | Fpclk/16 | |=========|================|==========|==========|===========|==========|===========|==========| | | Polling | Fpclk/8 | Fpclk/2 | NA | NA | Fpclk/8 | Fpclk/8 | | |----------------|----------|----------|-----------|----------|-----------|----------| | T | Interrupt | Fpclk/2 | Fpclk/4 | NA | NA | Fpclk/16 | Fpclk/8 | | X |----------------|----------|----------|-----------|----------|-----------|----------| | | DMA | Fpclk/2 | Fpclk/2 | NA | NA | Fpclk/8 | Fpclk/16 | +----------------------------------------------------------------------------------------------+ DataSize = SPI_DATASIZE_16BIT: +----------------------------------------------------------------------------------------------+ | | | 2Lines Fullduplex | 2Lines RxOnly | 1Line | | Process | Transfer mode |---------------------|----------------------|----------------------| | | | Master | Slave | Master | Slave | Master | Slave | |==============================================================================================| | T | Polling | Fpclk/4 | Fpclk/8 | NA | NA | NA | NA | | X |----------------|----------|----------|-----------|----------|-----------|----------| | / | Interrupt | Fpclk/4 | Fpclk/16 | NA | NA | NA | NA | | R |----------------|----------|----------|-----------|----------|-----------|----------| | X | DMA | Fpclk/2 | Fpclk/2 | NA | NA | NA | NA | |=========|================|==========|==========|===========|==========|===========|==========| | | Polling | Fpclk/4 | Fpclk/8 | Fpclk/16 | Fpclk/8 | Fpclk/8 | Fpclk/8 | | |----------------|----------|----------|-----------|----------|-----------|----------| | R | Interrupt | Fpclk/8 | Fpclk/16 | Fpclk/8 | Fpclk/8 | Fpclk/8 | Fpclk/4 | | X |----------------|----------|----------|-----------|----------|-----------|----------| | | DMA | Fpclk/4 | Fpclk/2 | Fpclk/2 | Fpclk/16 | Fpclk/2 | Fpclk/16 | |=========|================|==========|==========|===========|==========|===========|==========| | | Polling | Fpclk/8 | Fpclk/2 | NA | NA | Fpclk/8 | Fpclk/8 | | |----------------|----------|----------|-----------|----------|-----------|----------| | T | Interrupt | Fpclk/2 | Fpclk/4 | NA | NA | Fpclk/16 | Fpclk/8 | | X |----------------|----------|----------|-----------|----------|-----------|----------| | | DMA | Fpclk/2 | Fpclk/2 | NA | NA | Fpclk/8 | Fpclk/16 | +----------------------------------------------------------------------------------------------+","title":"4. Working modes"},{"location":"blog/stm32/i2c-spi/#5-stm32cubehal-usage","text":"The Hardware Abstract Layer (HAL) is designed so that it abstracts from the specific peripheral memory mapping. But, it also provides a general and more user-friendly way to configure the peripheral, without forcing the programmers to now how to configure its registers in detail. Excerpt from Description of STM32F0 HAL and low-layer drivers","title":"5. STM32CubeHAL Usage"},{"location":"blog/stm32/i2c-spi/#51-i2c-hal","text":"Declare a I2C_HandleTypeDef handle structure, for example: I2C_HandleTypeDef hi2c ; Initialize the I2C low level resources by implementing the HAL_I2C_MspInit() API: Enable the I2Cx interface clock I2C pins configuration Enable the clock for the I2C GPIOs Configure I2C pins as alternate function open-drain NVIC configuration if you need to use interrupt process Configure the I2Cx interrupt priority Enable the NVIC I2C IRQ Channel DMA Configuration if you need to use DMA process Declare a DMA_HandleTypeDef handle structure for to transmit or receive channel Enable the DMAx interface clock using Configure the DMA handle parameters Configure the DMA Tx or Rx channel Associate the initialized DMA handle to the hi2c DMA Tx or Rx handle Configure the priority and enable the NVIC for the transfer complete interrupt on the DMA Tx or Rx channel Configure the Communication Clock Timing , Own Address1 , Master Addressing mode , Dual Addressing mode , Own Address2 , Own Address2 Mask , General call and No-Stretch mode in the hi2c structure. Initialize the I2C registers by calling the HAL_I2C_Init() , configures also the low level Hardware (GPIO, CLOCK, NVIC\u2026etc.) by calling the customized HAL_I2C_MspInit(&hi2c) API. To check if target device is ready for communication, use the function HAL_I2C_IsDeviceReady() For I2C IO and IO MEM operations, three operation modes are available within this driver: Polling mode IO operation Transmit in master mode an amount of data in blocking mode using HAL_I2C_Master_Transmit() Receive in master mode an amount of data in blocking mode using HAL_I2C_Master_Receive() Transmit in slave mode an amount of data in blocking mode using HAL_I2C_Slave_Transmit() Receive in slave mode an amount of data in blocking mode using HAL_I2C_Slave_Receive() Polling mode IO MEM operation Write an amount of data in blocking mode to a specific memory address using HAL_I2C_Mem_Write() Read an amount of data in blocking mode from a specific memory address using HAL_I2C_Mem_Read() Interrupt mode IO operation Transmit in master mode an amount of data in non-blocking mode using HAL_I2C_Master_Transmit_IT() At transmission end of transfer, HAL_I2C_MasterTxCpltCallback() is executed and user can add his own code by customization of function pointer HAL_I2C_MasterTxCpltCallback() Receive in master mode an amount of data in non-blocking mode using HAL_I2C_Master_Receive_IT() At reception end of transfer, HAL_I2C_MasterRxCpltCallback() is executed and user can add his own code by customization of function pointer HAL_I2C_MasterRxCpltCallback() Transmit in slave mode an amount of data in non-blocking mode using HAL_I2C_Slave_Transmit_IT() At transmission end of transfer, HAL_I2C_SlaveTxCpltCallback() is executed and user can add his own code by customization of function pointer HAL_I2C_SlaveTxCpltCallback() Receive in slave mode an amount of data in non-blocking mode using HAL_I2C_Slave_Receive_IT() At reception end of transfer, HAL_I2C_SlaveRxCpltCallback() is executed and user can add his own code by customization of function pointer HAL_I2C_SlaveRxCpltCallback() In case of transfer Error, HAL_I2C_ErrorCallback() function is executed and user can add his own code by customization of function pointer HAL_I2C_ErrorCallback() Abort a master I2C process communication with Interrupt using HAL_I2C_Master_Abort_IT() End of abort process, HAL_I2C_AbortCpltCallback() is executed and user can add his own code by customization of function pointer HAL_I2C_AbortCpltCallback() Discard a slave I2C process communication using __HAL_I2C_GENERATE_NACK() macro. This action will inform Master to generate a Stop condition to discard the communication.","title":"5.1. I2C HAL"},{"location":"blog/stm32/i2c-spi/#52-spi-hal","text":"Declare a SPI_HandleTypeDef handle structure, for example: SPI_HandleTypeDef hspi; Initialize the SPI low level resources by implementing the HAL_SPI_MspInit() API: Enable the SPIx interface clock SPI pins configuration Enable the clock for the SPI GPIOs Configure these SPI pins as alternate function push-pull NVIC configuration if you need to use interrupt process Configure the SPIx interrupt priority Enable the NVIC SPI IRQ handle DMA Configuration if you need to use DMA process Declare a DMA_HandleTypeDef handle structure to transmit or receive Stream/Channel Enable the DMAx clock Configure the DMA handle parameters Configure the DMA Tx or Rx Stream/Channel Associate the initialized hdma_tx handle to the hspi DMA Tx or Rx handle Configure the priority and enable the NVIC for the transfer complete interrupt on the DMA Tx or Rx Stream/Channel Program the Mode, Bidirectional Mode, Data size, Baud rate Pre-scaler, NSS management, Clock polarity and phase, First Bit and CRC configuration in the hspi initial structure. Initialize the SPI registers by calling the HAL_SPI_Init() API: This API configures also the low level hardware (GPIO, CLOCK, CORTEX\u2026etc.) by calling the customized HAL_SPI_MspInit() API. Circular mode restriction: The DMA circular mode cannot be used when the SPI is configured in these modes: Master 2 Lines Rx Only Master 1 Line Rx The CRC feature is not managed when the DMA circular mode is enabled When the SPI DMA Pause/Stop features are used, you must use the following APIs the HAL_SPI_DMAPause() / HAL_SPI_DMAStop() only under the SPI callbacks Master Receive mode restriction: In Master unidirectional receive-only mode ( MSTR=1 , BIDIMODE=0 , RXONLY=0 ) or bidirectional receive mode ( MSTR=1 , BIDIMODE=1 , BIDIOE=0 ), to ensure that the SPI does not initiate a new transfer the following procedure has to be respected: HAL_SPI_DeInit() HAL_SPI_Init() Data buffer address alignment restriction: In case more than 1 byte is requested to be transferred, the HAL SPI uses 16-bit access for data buffer. But there is no support for unaligned accesses on the Cortex-M0 processor. So, if the user wants to transfer more than 1 byte, it shall ensure that 16-bit aligned address is used for: pData parameter in HAL_SPI_Transmit() , HAL_SPI_Transmit_IT() , HAL_SPI_Receive() and HAL_SPI_Receive_IT() pTxData and pRxData parameters in HAL_SPI_TransmitReceive() and HAL_SPI_TransmitReceive_IT() There is no such restriction when going through DMA by using HAL_SPI_Transmit_DMA() , HAL_SPI_Receive_DMA() and HAL_SPI_TransmitReceive_DMA() . The HAL drivers do not allow reaching all supported SPI frequencies in the different SPI modes. Refer to the source code ( stm32xxxx_hal_spi.c header) to get a summary of the maximum SPI frequency that can be reached with a data size of 8 or 16 bits, depending on the APBx peripheral clock frequency ( fPCLK ) used by the SPI instance. Example projects Refer to SSD1306 OLED to see examples using I2C and SPI protocol.","title":"5.2. SPI HAL"},{"location":"blog/stm32/interrupt/","text":"1. NVIC Controller \u2693\ufe0e Nested Vectored Interrupt Controller (NVIC) is a method of prioritizing interrupts, improving the MCU\u2019s performance and reducing interrupt latency. NVIC also provides implementation schemes for handling interrupts that occur when other interrupts are being executed or when the CPU is in the process of restoring its previous state and resuming its suspended process. NVIC module in STM32 MCUs Clock Security System (CSS) interrupt is connected to Non-Maskable Interrupt (NMI) lines Peripheral interrupts are connected to Interrupt Requests (IRQ) lines GPIO interrupts are connected to an External Interrupt/Event Controller (EXTI) before connecting to the IRQ lines External Interrupt lines External Interrupts are grouped by lines which connect to GPIO. As processor may have many GPIOs, an EXTI line is shared by multiple pins. In one line (group), only one pin can be set to generate interrupt, and software must be able to discriminate which lines generated the interrupt. The external interrupt can be fired on rising edge , or falling edge , or both . Whenever an interrupt happens, the processor stops the current code, and handle the interrupt by running an Interrupt Service Routines (ISR) which is located in a pre-defined table called Vector Interrupt Table (VIC) . Number Exception Type Priority Function 1 Reset -3 Reset 2 NMI -2 Non-Maskable Interrupt 3 Hard Fault -1 All faults that hang the processor 4 Memory Fault Configurable Memory issue 5 Bus Fault Configurable Data bus issue 6 Usage Fault Configurable Data bus issue 7 ~ 10 Reserved \u2014 Reserved 11 SVCall Configurable System service call (SVC instruction) 12 Debug Configurable Debug monitor (via SWD) 13 Reserved \u2014 Reserved 14 PendSV Configurable Pending request for System Service call 15 SysTick Configurable System Timer 16 ~ 240 IRQ Configurable Interrupt Request This table is declared in assembly code in the startup file of MCU startup_*.s . startup_stm32f051r8tx.s g_pfnVectors : . word _estack . word Reset_Handler . word NMI_Handler . word HardFault_Handler . word 0 . word 0 . word 0 . word 0 . word 0 . word 0 . word 0 . word SVC_Handler . word 0 . word 0 . word PendSV_Handler . word SysTick_Handler . word WWDG_IRQHandler /* Window WatchDog */ . word PVD_IRQHandler /* PVD through EXTI Line detect */ . word RTC_IRQHandler /* RTC through the EXTI line */ . word FLASH_IRQHandler /* FLASH */ . word RCC_CRS_IRQHandler /* RCC and CRS */ . word EXTI0_1_IRQHandler /* EXTI Line 0 and 1 */ . word EXTI2_3_IRQHandler /* EXTI Line 2 and 3 */ . word EXTI4_15_IRQHandler /* EXTI Line 4 to 15 */ . word TSC_IRQHandler /* TSC */ . word DMA1_Channel1_IRQHandler /* DMA1 Channel 1 */ . word DMA1_Channel2_3_IRQHandler /* DMA1 Channel 2 and Channel 3 */ . word DMA1_Channel4_5_IRQHandler /* DMA1 Channel 4 and Channel 5 */ . word ADC1_COMP_IRQHandler /* ADC1, COMP1 and COMP2 */ . word TIM1_BRK_UP_TRG_COM_IRQHandler /* TIM1 Break/Update/Trigger/Commutation */ . word TIM1_CC_IRQHandler /* TIM1 Capture Compare */ . word TIM2_IRQHandler /* TIM2 */ . word TIM3_IRQHandler /* TIM3 */ . word TIM6_DAC_IRQHandler /* TIM6 and DAC */ . word 0 /* Reserved */ . word TIM14_IRQHandler /* TIM14 */ . word TIM15_IRQHandler /* TIM15 */ . word TIM16_IRQHandler /* TIM16 */ . word TIM17_IRQHandler /* TIM17 */ . word I2C1_IRQHandler /* I2C1 */ . word I2C2_IRQHandler /* I2C2 */ . word SPI1_IRQHandler /* SPI1 */ . word SPI2_IRQHandler /* SPI2 */ . word USART1_IRQHandler /* USART1 */ . word USART2_IRQHandler /* USART2 */ . word 0 /* Reserved */ . word CEC_CAN_IRQHandler /* CEC and CAN */ . word 0 /* Reserved */ By convention, the vector table starts at the hardware address 0x00000000 in all Cortex-M based processors. If the vector table resides in the internal flash memory (this is what usually happens), and since the flash in all STM32 MCUs is mapped from 0x08000000 address, it is placed starting from the 0x08000000 address, which is aliased to 0x00000000 when the CPU boots up. Read about the Boot mode in the Reference Manual Entry zero of this array is the address of the Main Stack Pointer (MSP) inside the SRAM. Usually, this address corresponds to the end of the SRAM _estack . Vector Interrupt Table in ARM cores 2. Processor Mode \u2693\ufe0e The processor mode can change when exceptions occur. And it can be in one of the following modes: Thread Mode : Which is entered on reset, and application run on this mode. Handler Mode : Which is entered on all other exceptions The interrupt entry and exit are hardware implemented in order to reduce the latency and speed up the response. The hardware will do: Automatically saves and restores processor context (registers, flags) Allows late determination of the highest priority pending interrupt Allows another pending interrupt to be serviced without a full restore/save for processor context (this feature is called tail-chaining) 3. Preemption \u2693\ufe0e The Preemption happens when a task is abandoned (gets interrupted) in order to handle an exception. The currently running instruction stream is said to be Preempted. When multiple exceptions with the same priority levels are pending, the one with the lowest exception number gets serviced first. And once an exception is active and being serviced by the processor, only exceptions with a higher priority level can Preempt it. Lower priority level has higher priority of execution. Consider the following example, where 3 exceptions/interrupts are fired with different priority levels. IRQ1 Preempted IRQ2 and forced IRQ3 to pend until IRQ1 completion. After IRQ1 ISR completion, ISR2 continues where it left off when IRQ1 Preempted it. And finally, after ISR2 completion, ISR3 starts executions. And the context is restored to the main program (foreground). Preemption allow IRQ1 to be executed 4. Interrupts Tail-Chaining \u2693\ufe0e When an interrupt (exception) is fired, the main (foreground) code context is saved (pushed) to the stack and the processor branches to the corresponding interrupt vector to start executing the ISR handler. At the end of the ISR, the context saved in the stack is popped out, so the processor can resume the main (foreground) code instructions. However, and if a new exception is already pended, the context push & pop are skipped. And the processor handler the second ISR without any additional overhead. This is called Tail-Chaining . And it requires 6 cycles on Cortex-M3/M4 processors. Which is a huge speedup in the performance and enhanced the interrupt response time greatly (reduces the interrupt latency). Here is an example of what happens if the CPU receives a 2 nd interrupt request (IRQ2) while it\u2019s servicing the 1 st one (IRQ1). Tail chaining when IRQ2 comes while IRQ1 is executing 5. Interrupt Late Arrival \u2693\ufe0e The ARM core can detect a higher priority exception while in the exception entry phase (stacking caller registers & fetching the ISR routine vector to be executed) of another exception. A late arriving interrupt is detected during this period. The higher priority ISR can be fetched and executed but the context saving that has been already done can be skipped. This reduces the latency for the higher priority interrupt and, upon completion of the late-arriving exception handler, the processor can then tail-chain into the initial exception that was going to be serviced (the lower priority one). Late arrival is detected when IRQ1 comes while IRQ2 is about to start A pending higher-priority exception is handled before an already pending lower-priority exception even after the exception entry sequence has started. The lower-priority exception is handled after the higher-priority exception. 6. Interrupt Lifecycle \u2693\ufe0e An interrupt can: Either be disabled (default behavior) or enabled ; either be pending (a request is waiting to be served) or not pending ; either be in an active (being served) or inactive state. When an interrupt fires, it is marked as pending until the processor can serve it. If no other interrupts are currently being processed, it\u2019s pending state is automatically cleared by the processor, then it starts get served. ISR A then ISR B The lower priority ISR has to wait in pending state until no higher priority ISR is being processed. It can be put into inactive state when it is preempted by a higher priority ISR. ISR A preempts ISR B An interrupt can be forced to fire again during its execution, simply setting its pending bit again. In the same way, the execution of an interrupt can be canceled clearing its pending bit while it is in pending state ISR A then ISR A ISR B canceled 7. Reset Behavior \u2693\ufe0e When a reset occurs (Reset input is asserted): The MSP (main stack pointer) register loads the initial value from the address 0x00000000 which contains the end address of RAM _estack The reset handler address is loaded from address 0x00000004 . The reset handler gets executed in thread mode. The reset handler branches to the main program. 8. Exception Behavior \u2693\ufe0e When an exception occurs, the current instruction stream is stopped and the processor accesses the exceptions vector table: The vector address of that exception is loaded from the vector table. The exception handler starts to be executed in handler mode. The exception handler returns to main (assuming no further nesting). Here are more details: 1. Interrupt Stacking (Context Saving) The processor will finish the current instruction as long as it\u2019s not a multi-cycle instruction The processor state (context) is automatically saved to the stack. Eight registers are pushed (PC, R0-R3, R12, LR, xPSR). During or after context saving, the address of the corresponding ISR is loaded from the exception/interrupt vector table The link register is modified for return after interrupt The first instruction of the ISR starts to be executed by the CPU. For Cortex-M3/M4, the whole latency this process takes is 12 cycles. However, IRQ latency is improved if late-arrival or tail-chaining has occurred. 2. Interrupt Service Routine (ISR) Handling ISR should clear the interrupt source flag if required Interrupt nesting won\u2019t affect the way the ISR is written however, attention should be paid to the main stack overflow that may occur. Given that certain exceptions/interrupts are to be serviced hundreds or thousands of times per second. So it must run so quickly and no delays are permitted within ISR handlers 3. Return From ISR (Context Restoration) Detect tail-chaining interrupt, if you have, call to the ISR without restoring the context to speed up The EXC_RETURN instruction is fetched and gets executed to restore the PC and pop the CPU registers. The return from interrupt (context restoration) on ARM Cortex-M3/M4 requires 10 clock cycles 9. The Peripheral Pending bit \u2693\ufe0e When an interrupt takes place, the most of STM32 peripherals assert a specific signal connected to the NVIC, which is mapped in the peripheral memory through a dedicated bit. This Peripheral Pending bit will be held high until it is manually cleared by the application code. The ISR Pending bit is different to the Peripheral Pending bit. When the processor starts servicing the ISR, the ISR pending bit is cleared automatically, but the peripheral IRQ pending bit will be held high until it is cleared by the application code. If the Peripheral Pending bit is not clear, the interrupt will be fired again and the ISR will run again It is able to manually set the Peripheral Pending bit to force the ISR run External Peripheral Pending set Manually Peripheral Pending set 10. Configure Interrupts \u2693\ufe0e After a reset: When an STM32 MCU boots up, only Reset , NMI and Hard Fault exceptions are enabled by default. The rest of exceptions and peripheral interrupts are disabled, and they have to be enabled on request. When configuring a peripheral to work in Interrupt mode, the user application has to: Enable interrupt on the interrupt line, e.g. pin PA0 on the EXTI0 line Implement the interrupt handler which is declared in the startup file, e.g. EXTI0_1_IRQHandler for handle EXTI Line 0 and 1 Inside the handle: Check the interrupt source Clear interrupt flag Call a callback if needed 11. STM32CubeMX Usage \u2693\ufe0e NVIC can be configured using STM32CubeMX, in the Pinout & Configuration tab. This screen list all interrupts in the system and provides options to set up interrupts: Enable or Disable an interrupt: as mentioned above, some interrupts are always enabled, such as NMI, Hard fault, SVC. Note that STM32CubeMX forces to enable SysTick because HAL needs it to handle delay functions Set Preemption Priority for each interrupt Generate IRQ handlers (in *_it.c ) and call to HAL callbacks those will clear the pending bit, do something, and finally will call to a weak callback which can be overridden by users. Interrupt can be configured in each peripheral setting screen. For example, if user enables an external interrupt on a pin, NVIC tab will be available to quickly enable or disable the peripheral interrupt. NVIC configuration in STM32CubeMX 12. STM32CubeHAL Usage \u2693\ufe0e To enable an IRQ, the STM32CubeHAL provides the following function: void HAL_NVIC_EnableIRQ ( IRQn_Type IRQn ); Where the IRQn_Type is an enumeration of all exceptions and interrupts defined for that specific MCU. The IRQn_Type enum is part of the ST Device HAL, and it is defined inside a header file specific for the given STM32 MCU named stm32fxxxx.h . For example, for an STM32F030R8 MCU the right filename is stm32f030x8.h (the pattern name of these files is the same of start-up files). The corresponding function to disable an IRQ is the: void HAL_NVIC_DisableIRQ ( IRQn_Type IRQn ); Note that the above function enable the interrupt line at the NVIC level. A single peripheral must be properly configured to work in interrupt mode to cause it assert the corresponding peripheral interrupt level. Configure the NVIC Priority Grouping using HAL_NVIC_SetPriorityGrouping() function if using Group Priority, then use HAL_NVIC_SetPriority() to set the priority of the selected IRQ. When the NVIC_PRIORITYGROUP_0 is selected, IRQ preemption is no more possible. The pending IRQ priority will be managed only by the sub priority. Since the presence of the IRQ pending bit is peripheral dependent, it is a good design practice to clear peripherals IRQ pending status bit as their ISR start to be serviced. The processor core does not keep track of multiple interrupts (it does not queue interrupts), so if clearing the peripheral pending bit at the end of an ISR may lose important IRQs that fire in the middle. To see if an interrupt is pending (that is, fired but not running): uint32_t HAL_NVIC_GetPendingIRQ ( IRQn_Type IRQn ); To programmatically set the pending bit of an IRQ which causes the interrupt to fire, as it would be generated by the hardware: void HAL_NVIC_SetPendingIRQ ( IRQn_Type IRQn ); Instead, to programmatically clear the pending bit of an IRQ void HAL_NVIC_ClearPendingIRQ ( IRQn_Type IRQn ); To check if an ISR is active (IRQ being serviced): uint32_t HAL_NVIC_GetActive ( IRQn_Type IRQn );","title":"Interrupt"},{"location":"blog/stm32/interrupt/#1-nvic-controller","text":"Nested Vectored Interrupt Controller (NVIC) is a method of prioritizing interrupts, improving the MCU\u2019s performance and reducing interrupt latency. NVIC also provides implementation schemes for handling interrupts that occur when other interrupts are being executed or when the CPU is in the process of restoring its previous state and resuming its suspended process. NVIC module in STM32 MCUs Clock Security System (CSS) interrupt is connected to Non-Maskable Interrupt (NMI) lines Peripheral interrupts are connected to Interrupt Requests (IRQ) lines GPIO interrupts are connected to an External Interrupt/Event Controller (EXTI) before connecting to the IRQ lines External Interrupt lines External Interrupts are grouped by lines which connect to GPIO. As processor may have many GPIOs, an EXTI line is shared by multiple pins. In one line (group), only one pin can be set to generate interrupt, and software must be able to discriminate which lines generated the interrupt. The external interrupt can be fired on rising edge , or falling edge , or both . Whenever an interrupt happens, the processor stops the current code, and handle the interrupt by running an Interrupt Service Routines (ISR) which is located in a pre-defined table called Vector Interrupt Table (VIC) . Number Exception Type Priority Function 1 Reset -3 Reset 2 NMI -2 Non-Maskable Interrupt 3 Hard Fault -1 All faults that hang the processor 4 Memory Fault Configurable Memory issue 5 Bus Fault Configurable Data bus issue 6 Usage Fault Configurable Data bus issue 7 ~ 10 Reserved \u2014 Reserved 11 SVCall Configurable System service call (SVC instruction) 12 Debug Configurable Debug monitor (via SWD) 13 Reserved \u2014 Reserved 14 PendSV Configurable Pending request for System Service call 15 SysTick Configurable System Timer 16 ~ 240 IRQ Configurable Interrupt Request This table is declared in assembly code in the startup file of MCU startup_*.s . startup_stm32f051r8tx.s g_pfnVectors : . word _estack . word Reset_Handler . word NMI_Handler . word HardFault_Handler . word 0 . word 0 . word 0 . word 0 . word 0 . word 0 . word 0 . word SVC_Handler . word 0 . word 0 . word PendSV_Handler . word SysTick_Handler . word WWDG_IRQHandler /* Window WatchDog */ . word PVD_IRQHandler /* PVD through EXTI Line detect */ . word RTC_IRQHandler /* RTC through the EXTI line */ . word FLASH_IRQHandler /* FLASH */ . word RCC_CRS_IRQHandler /* RCC and CRS */ . word EXTI0_1_IRQHandler /* EXTI Line 0 and 1 */ . word EXTI2_3_IRQHandler /* EXTI Line 2 and 3 */ . word EXTI4_15_IRQHandler /* EXTI Line 4 to 15 */ . word TSC_IRQHandler /* TSC */ . word DMA1_Channel1_IRQHandler /* DMA1 Channel 1 */ . word DMA1_Channel2_3_IRQHandler /* DMA1 Channel 2 and Channel 3 */ . word DMA1_Channel4_5_IRQHandler /* DMA1 Channel 4 and Channel 5 */ . word ADC1_COMP_IRQHandler /* ADC1, COMP1 and COMP2 */ . word TIM1_BRK_UP_TRG_COM_IRQHandler /* TIM1 Break/Update/Trigger/Commutation */ . word TIM1_CC_IRQHandler /* TIM1 Capture Compare */ . word TIM2_IRQHandler /* TIM2 */ . word TIM3_IRQHandler /* TIM3 */ . word TIM6_DAC_IRQHandler /* TIM6 and DAC */ . word 0 /* Reserved */ . word TIM14_IRQHandler /* TIM14 */ . word TIM15_IRQHandler /* TIM15 */ . word TIM16_IRQHandler /* TIM16 */ . word TIM17_IRQHandler /* TIM17 */ . word I2C1_IRQHandler /* I2C1 */ . word I2C2_IRQHandler /* I2C2 */ . word SPI1_IRQHandler /* SPI1 */ . word SPI2_IRQHandler /* SPI2 */ . word USART1_IRQHandler /* USART1 */ . word USART2_IRQHandler /* USART2 */ . word 0 /* Reserved */ . word CEC_CAN_IRQHandler /* CEC and CAN */ . word 0 /* Reserved */ By convention, the vector table starts at the hardware address 0x00000000 in all Cortex-M based processors. If the vector table resides in the internal flash memory (this is what usually happens), and since the flash in all STM32 MCUs is mapped from 0x08000000 address, it is placed starting from the 0x08000000 address, which is aliased to 0x00000000 when the CPU boots up. Read about the Boot mode in the Reference Manual Entry zero of this array is the address of the Main Stack Pointer (MSP) inside the SRAM. Usually, this address corresponds to the end of the SRAM _estack . Vector Interrupt Table in ARM cores","title":"1. NVIC Controller"},{"location":"blog/stm32/interrupt/#2-processor-mode","text":"The processor mode can change when exceptions occur. And it can be in one of the following modes: Thread Mode : Which is entered on reset, and application run on this mode. Handler Mode : Which is entered on all other exceptions The interrupt entry and exit are hardware implemented in order to reduce the latency and speed up the response. The hardware will do: Automatically saves and restores processor context (registers, flags) Allows late determination of the highest priority pending interrupt Allows another pending interrupt to be serviced without a full restore/save for processor context (this feature is called tail-chaining)","title":"2. Processor Mode"},{"location":"blog/stm32/interrupt/#3-preemption","text":"The Preemption happens when a task is abandoned (gets interrupted) in order to handle an exception. The currently running instruction stream is said to be Preempted. When multiple exceptions with the same priority levels are pending, the one with the lowest exception number gets serviced first. And once an exception is active and being serviced by the processor, only exceptions with a higher priority level can Preempt it. Lower priority level has higher priority of execution. Consider the following example, where 3 exceptions/interrupts are fired with different priority levels. IRQ1 Preempted IRQ2 and forced IRQ3 to pend until IRQ1 completion. After IRQ1 ISR completion, ISR2 continues where it left off when IRQ1 Preempted it. And finally, after ISR2 completion, ISR3 starts executions. And the context is restored to the main program (foreground). Preemption allow IRQ1 to be executed","title":"3. Preemption"},{"location":"blog/stm32/interrupt/#4-interrupts-tail-chaining","text":"When an interrupt (exception) is fired, the main (foreground) code context is saved (pushed) to the stack and the processor branches to the corresponding interrupt vector to start executing the ISR handler. At the end of the ISR, the context saved in the stack is popped out, so the processor can resume the main (foreground) code instructions. However, and if a new exception is already pended, the context push & pop are skipped. And the processor handler the second ISR without any additional overhead. This is called Tail-Chaining . And it requires 6 cycles on Cortex-M3/M4 processors. Which is a huge speedup in the performance and enhanced the interrupt response time greatly (reduces the interrupt latency). Here is an example of what happens if the CPU receives a 2 nd interrupt request (IRQ2) while it\u2019s servicing the 1 st one (IRQ1). Tail chaining when IRQ2 comes while IRQ1 is executing","title":"4. Interrupts Tail-Chaining"},{"location":"blog/stm32/interrupt/#5-interrupt-late-arrival","text":"The ARM core can detect a higher priority exception while in the exception entry phase (stacking caller registers & fetching the ISR routine vector to be executed) of another exception. A late arriving interrupt is detected during this period. The higher priority ISR can be fetched and executed but the context saving that has been already done can be skipped. This reduces the latency for the higher priority interrupt and, upon completion of the late-arriving exception handler, the processor can then tail-chain into the initial exception that was going to be serviced (the lower priority one). Late arrival is detected when IRQ1 comes while IRQ2 is about to start A pending higher-priority exception is handled before an already pending lower-priority exception even after the exception entry sequence has started. The lower-priority exception is handled after the higher-priority exception.","title":"5. Interrupt Late Arrival"},{"location":"blog/stm32/interrupt/#6-interrupt-lifecycle","text":"An interrupt can: Either be disabled (default behavior) or enabled ; either be pending (a request is waiting to be served) or not pending ; either be in an active (being served) or inactive state. When an interrupt fires, it is marked as pending until the processor can serve it. If no other interrupts are currently being processed, it\u2019s pending state is automatically cleared by the processor, then it starts get served. ISR A then ISR B The lower priority ISR has to wait in pending state until no higher priority ISR is being processed. It can be put into inactive state when it is preempted by a higher priority ISR. ISR A preempts ISR B An interrupt can be forced to fire again during its execution, simply setting its pending bit again. In the same way, the execution of an interrupt can be canceled clearing its pending bit while it is in pending state ISR A then ISR A ISR B canceled","title":"6. Interrupt Lifecycle"},{"location":"blog/stm32/interrupt/#7-reset-behavior","text":"When a reset occurs (Reset input is asserted): The MSP (main stack pointer) register loads the initial value from the address 0x00000000 which contains the end address of RAM _estack The reset handler address is loaded from address 0x00000004 . The reset handler gets executed in thread mode. The reset handler branches to the main program.","title":"7. Reset Behavior"},{"location":"blog/stm32/interrupt/#8-exception-behavior","text":"When an exception occurs, the current instruction stream is stopped and the processor accesses the exceptions vector table: The vector address of that exception is loaded from the vector table. The exception handler starts to be executed in handler mode. The exception handler returns to main (assuming no further nesting). Here are more details: 1. Interrupt Stacking (Context Saving) The processor will finish the current instruction as long as it\u2019s not a multi-cycle instruction The processor state (context) is automatically saved to the stack. Eight registers are pushed (PC, R0-R3, R12, LR, xPSR). During or after context saving, the address of the corresponding ISR is loaded from the exception/interrupt vector table The link register is modified for return after interrupt The first instruction of the ISR starts to be executed by the CPU. For Cortex-M3/M4, the whole latency this process takes is 12 cycles. However, IRQ latency is improved if late-arrival or tail-chaining has occurred. 2. Interrupt Service Routine (ISR) Handling ISR should clear the interrupt source flag if required Interrupt nesting won\u2019t affect the way the ISR is written however, attention should be paid to the main stack overflow that may occur. Given that certain exceptions/interrupts are to be serviced hundreds or thousands of times per second. So it must run so quickly and no delays are permitted within ISR handlers 3. Return From ISR (Context Restoration) Detect tail-chaining interrupt, if you have, call to the ISR without restoring the context to speed up The EXC_RETURN instruction is fetched and gets executed to restore the PC and pop the CPU registers. The return from interrupt (context restoration) on ARM Cortex-M3/M4 requires 10 clock cycles","title":"8. Exception Behavior"},{"location":"blog/stm32/interrupt/#9-the-peripheral-pending-bit","text":"When an interrupt takes place, the most of STM32 peripherals assert a specific signal connected to the NVIC, which is mapped in the peripheral memory through a dedicated bit. This Peripheral Pending bit will be held high until it is manually cleared by the application code. The ISR Pending bit is different to the Peripheral Pending bit. When the processor starts servicing the ISR, the ISR pending bit is cleared automatically, but the peripheral IRQ pending bit will be held high until it is cleared by the application code. If the Peripheral Pending bit is not clear, the interrupt will be fired again and the ISR will run again It is able to manually set the Peripheral Pending bit to force the ISR run External Peripheral Pending set Manually Peripheral Pending set","title":"9. The Peripheral Pending bit"},{"location":"blog/stm32/interrupt/#10-configure-interrupts","text":"After a reset: When an STM32 MCU boots up, only Reset , NMI and Hard Fault exceptions are enabled by default. The rest of exceptions and peripheral interrupts are disabled, and they have to be enabled on request. When configuring a peripheral to work in Interrupt mode, the user application has to: Enable interrupt on the interrupt line, e.g. pin PA0 on the EXTI0 line Implement the interrupt handler which is declared in the startup file, e.g. EXTI0_1_IRQHandler for handle EXTI Line 0 and 1 Inside the handle: Check the interrupt source Clear interrupt flag Call a callback if needed","title":"10. Configure Interrupts"},{"location":"blog/stm32/interrupt/#11-stm32cubemx-usage","text":"NVIC can be configured using STM32CubeMX, in the Pinout & Configuration tab. This screen list all interrupts in the system and provides options to set up interrupts: Enable or Disable an interrupt: as mentioned above, some interrupts are always enabled, such as NMI, Hard fault, SVC. Note that STM32CubeMX forces to enable SysTick because HAL needs it to handle delay functions Set Preemption Priority for each interrupt Generate IRQ handlers (in *_it.c ) and call to HAL callbacks those will clear the pending bit, do something, and finally will call to a weak callback which can be overridden by users. Interrupt can be configured in each peripheral setting screen. For example, if user enables an external interrupt on a pin, NVIC tab will be available to quickly enable or disable the peripheral interrupt. NVIC configuration in STM32CubeMX","title":"11. STM32CubeMX Usage"},{"location":"blog/stm32/interrupt/#12-stm32cubehal-usage","text":"To enable an IRQ, the STM32CubeHAL provides the following function: void HAL_NVIC_EnableIRQ ( IRQn_Type IRQn ); Where the IRQn_Type is an enumeration of all exceptions and interrupts defined for that specific MCU. The IRQn_Type enum is part of the ST Device HAL, and it is defined inside a header file specific for the given STM32 MCU named stm32fxxxx.h . For example, for an STM32F030R8 MCU the right filename is stm32f030x8.h (the pattern name of these files is the same of start-up files). The corresponding function to disable an IRQ is the: void HAL_NVIC_DisableIRQ ( IRQn_Type IRQn ); Note that the above function enable the interrupt line at the NVIC level. A single peripheral must be properly configured to work in interrupt mode to cause it assert the corresponding peripheral interrupt level. Configure the NVIC Priority Grouping using HAL_NVIC_SetPriorityGrouping() function if using Group Priority, then use HAL_NVIC_SetPriority() to set the priority of the selected IRQ. When the NVIC_PRIORITYGROUP_0 is selected, IRQ preemption is no more possible. The pending IRQ priority will be managed only by the sub priority. Since the presence of the IRQ pending bit is peripheral dependent, it is a good design practice to clear peripherals IRQ pending status bit as their ISR start to be serviced. The processor core does not keep track of multiple interrupts (it does not queue interrupts), so if clearing the peripheral pending bit at the end of an ISR may lose important IRQs that fire in the middle. To see if an interrupt is pending (that is, fired but not running): uint32_t HAL_NVIC_GetPendingIRQ ( IRQn_Type IRQn ); To programmatically set the pending bit of an IRQ which causes the interrupt to fire, as it would be generated by the hardware: void HAL_NVIC_SetPendingIRQ ( IRQn_Type IRQn ); Instead, to programmatically clear the pending bit of an IRQ void HAL_NVIC_ClearPendingIRQ ( IRQn_Type IRQn ); To check if an ISR is active (IRQ being serviced): uint32_t HAL_NVIC_GetActive ( IRQn_Type IRQn );","title":"12. STM32CubeHAL Usage"},{"location":"blog/stm32/intro/","text":"1. ARM Cortex-M processors \u2693\ufe0e .red { color: red; } ARM (Advanced RISC Machines) processors use Reduced Instruction Set Computing (RISC) architectures, and nowadays have many revisions (ARMv6, ARMv6-M, ARMv7, ARMv7-A, etc.). ARM Cortex is a wide set of 32/64-bit core architectures, which are based on ARM architecture revisions. For example, a processor based on the Cortex-M4 core is designed on the ARMv7-M architecture. ARM Cortex microcontrollers are divided into three main subfamilies: Cortex-A which stands for A pplication Cortex-R which stand for R eal-Time Cortex-M which stands for E M bedded 1.1. Core Registers \u2693\ufe0e Like all RISC architectures, Cortex-M processors are load/store machines, which perform operations only on CPU registers except for two categories of instructions: load and store , used to transfer data between CPU registers and memory locations Processor register set on ARM Cortex-M Microprocessor R0 ~ R12 are general-purpose registers, and can be used as operands for ARM instructions. Some general-purpose registers, however, can be used by the compiler as registers with special functions. R13 is the Stack Pointer (SP) register, which is also said to be banked. This means that the register content changes according to the current CPU mode ( privileged or unprivileged ). This function is typically used by Real Time Operating Systems (RTOS) to do context switching. R14 is the Link Register (LR) register, which is a special-purpose register which holds the address to return to when a function call completes. This is more efficient than the more traditional scheme of storing return addresses on a call stack, sometimes called a machine stack. The link register does not require the writes and reads of the memory containing the stack which can save a considerable percentage of execution time with repeated calls of small subroutines. R15 is the Program Counter (PC) register, which has the address of the next instruction to be executed from memory. Usually, the PC is incremented after fetching an instruction. However, control transfer instructions can change the sequence by placing a new value in the PC register. 1.2. Memory Map \u2693\ufe0e ARM defines a standardized memory address space common to all Cortex-M cores, which ensures code portability among different silicon manufacturer. The address space is 4 GB wide (due to 32-bit address line), and it is organized in several sub-regions with different logical functionalities. Fixed memory map for ARM cores The first 512 MB are dedicated to code area: All Cortex-M processors map the code area starting at address 0x00000000 . This area also includes the pointer to the beginning of the stack (usually placed in SRAM) and the system interrupt vector table. An area starting at address 0x08000000 is bound to the internal MCU flash memory, and it is the area where program code resides. With a specific boot configuration, this area is also aliased from address 0x00000000 . This means that it is perfectly possible to refer to the content of the flash memory both starting at address 0x08000000 and 0x00000000 . System Memory is a ROM region filled with official pre-programmed Boot Loader which can be used to load code from several peripherals, including USARTs, USB and CAN bus. Option Bytes region contains a series of bit flags which can be used to configure several aspects of the MCU (such as flash read protection, hardware watchdog, boot mode and so on) and are related to a specific microcontroller. Next 512 MB is mapped to Internal SRAM: It starts at address 0x20000000 and can potentially extend to 0x3FFFFFFF . This area also can be aliased to the start-up address at 0x00000000 . Other memory regions are mapped to external RAM, peripherals and the internal core registers. All Cortex processor registers are at fixed locations for all Cortex-based microcontrollers. This allows code to be more easily ported between different core variants and indeed other vendors\u2019 Cortex-based microcontrollers. Memory Map for Code Area 1.3. Bit-Banding \u2693\ufe0e In embedded applications, it is quite common to work with a single bit of a word using bit-masking. For example: uint8_t flags = 0 ; flags |= 0x4 ; // set the 4-th bit generates assembly code : 0 x0a: 79 fb ldrb r3 , [ r7 , # 7 ] 0 x0c: f043 0304 orr.w r3 , r3 , # 4 0 x10: 71 fb strb r3 , [ r7 , # 7 ] Such a simple operation requires three assembly instructions (fetch, modify, save). This leads to a problem if an interruption happens between processing bit mask. Bit-banding is the ability to map each bit of a given area of memory to a whole word in the aliased bit-banding memory region, allowing atomic access to such bit. Memory Map of an address in a bit-banding region ARM defines two bit-band regions for Cortex-M based MCUs, each one is 1 MB wide and mapped to a 32Mbit bit-band alias region. The first one starts at 0x20000000 and ends at 0x200FFFFF , and it is aliased from 0x22000000 to 0x23FFFFFF . It is dedicated to the bit access of SRAM memory locations. Another bit-banding region starts at 0x40000000 and ends at 0x400FFFFF , which is dedicated to the memory mapping of peripherals, from 0x42000000 to 0x43FFFFFF . Define two macros in C that allow to easily compute bit-band alias addresses: /* MEMORY BIT-BANDING */ // Define base address of bit-band #define BITBAND_SRAM_BASE 0x20000000 // Define base address of alias band #define ALIAS_SRAM_BASE 0x22000000 // Convert SRAM address to alias region #define BITBAND_SRAM(a,b) ((ALIAS_SRAM_BASE + ((uint32_t)&(a)-BITBAND_SRAM_BASE)*32 + (b*4))) /* PERIPHERAL BIT-BANDING */ // Define base address of peripheral bit-band #define BITBAND_PERI_BASE 0x40000000 // Define base address of peripheral alias band #define ALIAS_PERI_BASE 0x42000000 // Convert PERI address to alias region #define BITBAND_PERI(a,b) ((ALIAS_PERI_BASE + ((uint32_t)a-BITBAND_PERI_BASE)*32 + (b*4))) Example that quickly modifies the state of PIN5 of the GPIOA port as follows: #define GPIOA_PERH_ADDR 0x40020000 #define ODR_ADDR_OFF 0x14 uint32_t * GPIOA_ODR = GPIOA_PERH_ADDR + ODR_ADDR_OFF uint32_t * GPIOA_PIN5 = BITBAND_PERI ( GPIOA_ODR , 5 ); * GPIOA_PIN5 = 0x1 ; // Turns GPIO HIGH Memory Map for Bit-banding Area 1.4. Thumb Instruction Set \u2693\ufe0e ARM Cortex-M processors provide a 32-bit instruction set, not only allows for a rich set of instructions, but also guarantees the best performance. However, memory footprint of the firmware has bigger cost. To address such issues, ARM introduced the Thumb 16-bit instruction set which is transparently expanded to full 32-bit ARM instructions in real time, without performance loss. Afterwards, ARM introduced the Thumb-2 instruction set, which is a mix of 16 and 32-bit instruction sets in one operation state. 1.5. Instruction pipeline \u2693\ufe0e Before an instruction is executed, the CPU has to fetch it from memory and decode it. So, it has 3 stages to complete an instruction. Modern CPUs introduce a way to parallelize these operations in order to increase their instructions\u2019 throughput. The basic instruction cycle is broken up into a series of steps, as if the instructions traveled along a pipeline . 3-stage instruction pipeline When dealing with pipelines, branching is an issue to be addressed. When branching causes the invalidation of pipeline streams, the last two instructions which have been loaded into the pipeline will be discarded. 1.6. Memory alignment \u2693\ufe0e Aligned and Unaligned memory access ARM based CPUs are traditionally capable of accessing byte (8-bit), half word (16-bit) and word (32-bit) signed and unsigned variables, without increasing the number of assembly instructions as it happens on 8-bit MCU architectures which reads byte by byte. Aligned memory access causes a waste of memory locations. 1.7. Interrupts and Exceptions \u2693\ufe0e Interrupts and exceptions are asynchronous events that alter the program flow. When an exception or an interrupt occurs, the CPU suspends the execution of the current task, saves its context (that is, its stack pointer) and starts the execution of a routine designed to handle the interrupting event. This routine is called Exception Handler in case of exceptions and Interrupt Service Routine (ISR) in case of an interrupt. After the exception or interrupt has been handled, the CPU resumes the previous execution flow, and the previous task can continue its execution. In the ARM architecture, interrupts are one type of exception. Interrupts are usually generated from on-chip peripherals (e.g., a timer) or external inputs (e.g. a tactile switch connected to a GPIO), and in some cases they can be triggered by software. Exceptions are, instead, related to software execution, and the CPU itself can be a source of exceptions. Each exception (and hence interrupt) has a number which uniquely identifies it. Cortex-M cores has pre-defined exception table which contains the addresses of function to handle those exceptions. Number Exception Type Priority Function 1 Reset -3 Reset 2 NMI -2 Non-Maskable Interrupt 3 Hard Fault -1 All faults that hang the processor 4 Memory Fault Configurable Memory issue 5 Bus Fault Configurable Data bus issue 6 Usage Fault Configurable Data bus issue 7 ~ 10 Reserved \u2014 Reserved 11 SVCall Configurable System service call (SVC instruction) 12 Debug Configurable Debug monitor (via SWD) 13 Reserved \u2014 Reserved 14 PendSV Configurable Pending request for System Service call 15 SysTick Configurable System Timer 16 ~ 240 IRQ Configurable Interrupt Request 1.8. System Timer \u2693\ufe0e Cortex-M based processors can optionally provide a System Timer, also known as SysTick which is a 24-bit down-counting timer used to provide a system tick for Real Time Operating Systems (RTOS). It is used to generate periodic interrupts to scheduled tasks, or measure delay. When the timer reach zero, it fires an interrupt number 15, as seen in the Interrupt Table above. 1.9. Clock source and power mode \u2693\ufe0e Cortex-M processors provide several levels of power management which can be set via System Control Register (SCR) . Run mode : full clock speed, all using peripherals are activated Sleep mode : reduced clock speed, some peripherals are suspended Deep sleep mode : clock is stopped, need external event to wake-up 1.10. CMSIS for SW development \u2693\ufe0e Cortex Microcontroller Software Interface Standard (CMSIS) is a vendor-independent hardware abstraction layer for the Cortex-M processor series and specifies debugger interfaces. The CMSIS consists of the following components: CMSIS-CORE : API for the Cortex-M processor core and peripherals CMSIS-Driver : defines generic peripheral driver interfaces for middleware making them reusable across supported devices CMSIS-DSP : API for process signal and data such as fixed-point, single precision floating-point CMSIS-RTOS API: Common API for Real-Time Operating Systems CMSIS-Pack : a set of collections which includes source, header, library files, documentation, flash programming algorithms, source code templates and example projects CMSIS-SVD : System View Description for Peripherals CMSIS-DAP : Debug Access Port 2. STM32 Microcontrollers \u2693\ufe0e STM32 is a broad range of ARM Cortex-M microcontrollers divided in nine sub-families. Internally, each microcontroller consists of the processor core, static RAM, flash memory, debugging interface, and various peripherals. Here are advantages of using STM32 MCUs: Cortex-M based MCUs have a large community, supported by free tool-chain, and is written in many shared knowledge articles The Pin-to-Pin compatibility for most of STM32 MCUs helps to change the MCU while keeping pin assignments Almost pins are 5V tolerant, that means it can interface with other devices which do not use 3.3V without using level shifter Cheap is an advantage of using STM32 MCUs with ARM based processors and supported RTOS Integrated bootloader is shipped with internal ROM which allows to reprogram the internal flash memory using some communication peripherals STM32 F051 Discovery Board STM32 L0538 Discovery Board STM32 Nucleo family boards 2.1. Cortex-M comparison \u2693\ufe0e A table excerpted from ARM website. Feature Cortex-M0 Cortex-M0+ Cortex-M3 Cortex-M4 Cortex-M33 Cortex-M7 ISA Armv6-M Armv6-M Armv7-M Armv7-M Armv8-M Mainline Armv7-M Thumb, Thumb-2 Pipeline stages 3 2 3 3 3 6 Memory Protection Unit No Yes Yes Yes Yes Yes Maximum MPU regions 0 8 8 8 16 16 Trace (ETM or MTB) No MTB ETMv3 ETMv3 MTB and/or ETMv4 ETMv4 DSP No No No Yes Yes Yes Floating point hardware No No No Yes Yes Yes Bus protocol AHB Lite AHB Lite AHB Lite, APB AHB Lite, APB AHB5 AXI4, AHB Lite, APB, TCM Maximum # external interrupts 32 32 240 240 480 240 CMSIS Support Yes 2.2. STM32 MCUs comparison \u2693\ufe0e Compare the core, frequency and memory Type Family Core Max Frequency Flash High Performance STM32H7 Cortex-M7 / Cortex -M4 480 MHz / 240 MHz 1 to 2 MB STM32F7 Cortex-M7 216 MHz 256 KB to 2 MB STM32F4 Cortex-M4 180 MHz 64 KB to 2 MB STM32F2 Cortex-M3 120 MHz 128 KB to 1 MB Mainstream STM32G4 Cortex-M4 170 MHz 32 to 512 KB STM32F3 Cortex-M4 72 MHz 16 to 512 KB STM32F1 Cortex-M3 72 MHz 16 KB to 1 MB STM32G0 Cortex-M0+ 64 MHz 16 to 512 KB STM32F0 Cortex-M0 48 MHz 16 to 256 KB Ultra-low-power STM32L5 Cortex-M33 110 MHz 256 to 512 KB STM32L4+ Cortex-M4 120 MHz 512 KB to 2 MB STM32L4 Cortex-M4 80 MHz 64 KB to 1 MB STM32L1 Cortex-M3 32 MHz 32 to 512 KB STM32L0 Cortex-M0+ 32 MHz 8 to 192 KB Wireless STM32WB Cortex-M4 / Cortex-M0+ 64 MHz / 32 MHz 256 KB to 1 MB STM32WL Cortex-M4 48 MHz 64 KB to 256 KB","title":"Introduction"},{"location":"blog/stm32/intro/#1-arm-cortex-m-processors","text":".red { color: red; } ARM (Advanced RISC Machines) processors use Reduced Instruction Set Computing (RISC) architectures, and nowadays have many revisions (ARMv6, ARMv6-M, ARMv7, ARMv7-A, etc.). ARM Cortex is a wide set of 32/64-bit core architectures, which are based on ARM architecture revisions. For example, a processor based on the Cortex-M4 core is designed on the ARMv7-M architecture. ARM Cortex microcontrollers are divided into three main subfamilies: Cortex-A which stands for A pplication Cortex-R which stand for R eal-Time Cortex-M which stands for E M bedded","title":"1. ARM Cortex-M processors"},{"location":"blog/stm32/intro/#11-core-registers","text":"Like all RISC architectures, Cortex-M processors are load/store machines, which perform operations only on CPU registers except for two categories of instructions: load and store , used to transfer data between CPU registers and memory locations Processor register set on ARM Cortex-M Microprocessor R0 ~ R12 are general-purpose registers, and can be used as operands for ARM instructions. Some general-purpose registers, however, can be used by the compiler as registers with special functions. R13 is the Stack Pointer (SP) register, which is also said to be banked. This means that the register content changes according to the current CPU mode ( privileged or unprivileged ). This function is typically used by Real Time Operating Systems (RTOS) to do context switching. R14 is the Link Register (LR) register, which is a special-purpose register which holds the address to return to when a function call completes. This is more efficient than the more traditional scheme of storing return addresses on a call stack, sometimes called a machine stack. The link register does not require the writes and reads of the memory containing the stack which can save a considerable percentage of execution time with repeated calls of small subroutines. R15 is the Program Counter (PC) register, which has the address of the next instruction to be executed from memory. Usually, the PC is incremented after fetching an instruction. However, control transfer instructions can change the sequence by placing a new value in the PC register.","title":"1.1. Core Registers"},{"location":"blog/stm32/intro/#12-memory-map","text":"ARM defines a standardized memory address space common to all Cortex-M cores, which ensures code portability among different silicon manufacturer. The address space is 4 GB wide (due to 32-bit address line), and it is organized in several sub-regions with different logical functionalities. Fixed memory map for ARM cores The first 512 MB are dedicated to code area: All Cortex-M processors map the code area starting at address 0x00000000 . This area also includes the pointer to the beginning of the stack (usually placed in SRAM) and the system interrupt vector table. An area starting at address 0x08000000 is bound to the internal MCU flash memory, and it is the area where program code resides. With a specific boot configuration, this area is also aliased from address 0x00000000 . This means that it is perfectly possible to refer to the content of the flash memory both starting at address 0x08000000 and 0x00000000 . System Memory is a ROM region filled with official pre-programmed Boot Loader which can be used to load code from several peripherals, including USARTs, USB and CAN bus. Option Bytes region contains a series of bit flags which can be used to configure several aspects of the MCU (such as flash read protection, hardware watchdog, boot mode and so on) and are related to a specific microcontroller. Next 512 MB is mapped to Internal SRAM: It starts at address 0x20000000 and can potentially extend to 0x3FFFFFFF . This area also can be aliased to the start-up address at 0x00000000 . Other memory regions are mapped to external RAM, peripherals and the internal core registers. All Cortex processor registers are at fixed locations for all Cortex-based microcontrollers. This allows code to be more easily ported between different core variants and indeed other vendors\u2019 Cortex-based microcontrollers. Memory Map for Code Area","title":"1.2. Memory Map"},{"location":"blog/stm32/intro/#13-bit-banding","text":"In embedded applications, it is quite common to work with a single bit of a word using bit-masking. For example: uint8_t flags = 0 ; flags |= 0x4 ; // set the 4-th bit generates assembly code : 0 x0a: 79 fb ldrb r3 , [ r7 , # 7 ] 0 x0c: f043 0304 orr.w r3 , r3 , # 4 0 x10: 71 fb strb r3 , [ r7 , # 7 ] Such a simple operation requires three assembly instructions (fetch, modify, save). This leads to a problem if an interruption happens between processing bit mask. Bit-banding is the ability to map each bit of a given area of memory to a whole word in the aliased bit-banding memory region, allowing atomic access to such bit. Memory Map of an address in a bit-banding region ARM defines two bit-band regions for Cortex-M based MCUs, each one is 1 MB wide and mapped to a 32Mbit bit-band alias region. The first one starts at 0x20000000 and ends at 0x200FFFFF , and it is aliased from 0x22000000 to 0x23FFFFFF . It is dedicated to the bit access of SRAM memory locations. Another bit-banding region starts at 0x40000000 and ends at 0x400FFFFF , which is dedicated to the memory mapping of peripherals, from 0x42000000 to 0x43FFFFFF . Define two macros in C that allow to easily compute bit-band alias addresses: /* MEMORY BIT-BANDING */ // Define base address of bit-band #define BITBAND_SRAM_BASE 0x20000000 // Define base address of alias band #define ALIAS_SRAM_BASE 0x22000000 // Convert SRAM address to alias region #define BITBAND_SRAM(a,b) ((ALIAS_SRAM_BASE + ((uint32_t)&(a)-BITBAND_SRAM_BASE)*32 + (b*4))) /* PERIPHERAL BIT-BANDING */ // Define base address of peripheral bit-band #define BITBAND_PERI_BASE 0x40000000 // Define base address of peripheral alias band #define ALIAS_PERI_BASE 0x42000000 // Convert PERI address to alias region #define BITBAND_PERI(a,b) ((ALIAS_PERI_BASE + ((uint32_t)a-BITBAND_PERI_BASE)*32 + (b*4))) Example that quickly modifies the state of PIN5 of the GPIOA port as follows: #define GPIOA_PERH_ADDR 0x40020000 #define ODR_ADDR_OFF 0x14 uint32_t * GPIOA_ODR = GPIOA_PERH_ADDR + ODR_ADDR_OFF uint32_t * GPIOA_PIN5 = BITBAND_PERI ( GPIOA_ODR , 5 ); * GPIOA_PIN5 = 0x1 ; // Turns GPIO HIGH Memory Map for Bit-banding Area","title":"1.3. Bit-Banding"},{"location":"blog/stm32/intro/#14-thumb-instruction-set","text":"ARM Cortex-M processors provide a 32-bit instruction set, not only allows for a rich set of instructions, but also guarantees the best performance. However, memory footprint of the firmware has bigger cost. To address such issues, ARM introduced the Thumb 16-bit instruction set which is transparently expanded to full 32-bit ARM instructions in real time, without performance loss. Afterwards, ARM introduced the Thumb-2 instruction set, which is a mix of 16 and 32-bit instruction sets in one operation state.","title":"1.4. Thumb Instruction Set"},{"location":"blog/stm32/intro/#15-instruction-pipeline","text":"Before an instruction is executed, the CPU has to fetch it from memory and decode it. So, it has 3 stages to complete an instruction. Modern CPUs introduce a way to parallelize these operations in order to increase their instructions\u2019 throughput. The basic instruction cycle is broken up into a series of steps, as if the instructions traveled along a pipeline . 3-stage instruction pipeline When dealing with pipelines, branching is an issue to be addressed. When branching causes the invalidation of pipeline streams, the last two instructions which have been loaded into the pipeline will be discarded.","title":"1.5. Instruction pipeline"},{"location":"blog/stm32/intro/#16-memory-alignment","text":"Aligned and Unaligned memory access ARM based CPUs are traditionally capable of accessing byte (8-bit), half word (16-bit) and word (32-bit) signed and unsigned variables, without increasing the number of assembly instructions as it happens on 8-bit MCU architectures which reads byte by byte. Aligned memory access causes a waste of memory locations.","title":"1.6. Memory alignment"},{"location":"blog/stm32/intro/#17-interrupts-and-exceptions","text":"Interrupts and exceptions are asynchronous events that alter the program flow. When an exception or an interrupt occurs, the CPU suspends the execution of the current task, saves its context (that is, its stack pointer) and starts the execution of a routine designed to handle the interrupting event. This routine is called Exception Handler in case of exceptions and Interrupt Service Routine (ISR) in case of an interrupt. After the exception or interrupt has been handled, the CPU resumes the previous execution flow, and the previous task can continue its execution. In the ARM architecture, interrupts are one type of exception. Interrupts are usually generated from on-chip peripherals (e.g., a timer) or external inputs (e.g. a tactile switch connected to a GPIO), and in some cases they can be triggered by software. Exceptions are, instead, related to software execution, and the CPU itself can be a source of exceptions. Each exception (and hence interrupt) has a number which uniquely identifies it. Cortex-M cores has pre-defined exception table which contains the addresses of function to handle those exceptions. Number Exception Type Priority Function 1 Reset -3 Reset 2 NMI -2 Non-Maskable Interrupt 3 Hard Fault -1 All faults that hang the processor 4 Memory Fault Configurable Memory issue 5 Bus Fault Configurable Data bus issue 6 Usage Fault Configurable Data bus issue 7 ~ 10 Reserved \u2014 Reserved 11 SVCall Configurable System service call (SVC instruction) 12 Debug Configurable Debug monitor (via SWD) 13 Reserved \u2014 Reserved 14 PendSV Configurable Pending request for System Service call 15 SysTick Configurable System Timer 16 ~ 240 IRQ Configurable Interrupt Request","title":"1.7. Interrupts and Exceptions"},{"location":"blog/stm32/intro/#18-system-timer","text":"Cortex-M based processors can optionally provide a System Timer, also known as SysTick which is a 24-bit down-counting timer used to provide a system tick for Real Time Operating Systems (RTOS). It is used to generate periodic interrupts to scheduled tasks, or measure delay. When the timer reach zero, it fires an interrupt number 15, as seen in the Interrupt Table above.","title":"1.8. System Timer"},{"location":"blog/stm32/intro/#19-clock-source-and-power-mode","text":"Cortex-M processors provide several levels of power management which can be set via System Control Register (SCR) . Run mode : full clock speed, all using peripherals are activated Sleep mode : reduced clock speed, some peripherals are suspended Deep sleep mode : clock is stopped, need external event to wake-up","title":"1.9. Clock source and power mode"},{"location":"blog/stm32/intro/#110-cmsis-for-sw-development","text":"Cortex Microcontroller Software Interface Standard (CMSIS) is a vendor-independent hardware abstraction layer for the Cortex-M processor series and specifies debugger interfaces. The CMSIS consists of the following components: CMSIS-CORE : API for the Cortex-M processor core and peripherals CMSIS-Driver : defines generic peripheral driver interfaces for middleware making them reusable across supported devices CMSIS-DSP : API for process signal and data such as fixed-point, single precision floating-point CMSIS-RTOS API: Common API for Real-Time Operating Systems CMSIS-Pack : a set of collections which includes source, header, library files, documentation, flash programming algorithms, source code templates and example projects CMSIS-SVD : System View Description for Peripherals CMSIS-DAP : Debug Access Port","title":"1.10. CMSIS for SW development"},{"location":"blog/stm32/intro/#2-stm32-microcontrollers","text":"STM32 is a broad range of ARM Cortex-M microcontrollers divided in nine sub-families. Internally, each microcontroller consists of the processor core, static RAM, flash memory, debugging interface, and various peripherals. Here are advantages of using STM32 MCUs: Cortex-M based MCUs have a large community, supported by free tool-chain, and is written in many shared knowledge articles The Pin-to-Pin compatibility for most of STM32 MCUs helps to change the MCU while keeping pin assignments Almost pins are 5V tolerant, that means it can interface with other devices which do not use 3.3V without using level shifter Cheap is an advantage of using STM32 MCUs with ARM based processors and supported RTOS Integrated bootloader is shipped with internal ROM which allows to reprogram the internal flash memory using some communication peripherals STM32 F051 Discovery Board STM32 L0538 Discovery Board STM32 Nucleo family boards","title":"2. STM32 Microcontrollers"},{"location":"blog/stm32/intro/#21-cortex-m-comparison","text":"A table excerpted from ARM website. Feature Cortex-M0 Cortex-M0+ Cortex-M3 Cortex-M4 Cortex-M33 Cortex-M7 ISA Armv6-M Armv6-M Armv7-M Armv7-M Armv8-M Mainline Armv7-M Thumb, Thumb-2 Pipeline stages 3 2 3 3 3 6 Memory Protection Unit No Yes Yes Yes Yes Yes Maximum MPU regions 0 8 8 8 16 16 Trace (ETM or MTB) No MTB ETMv3 ETMv3 MTB and/or ETMv4 ETMv4 DSP No No No Yes Yes Yes Floating point hardware No No No Yes Yes Yes Bus protocol AHB Lite AHB Lite AHB Lite, APB AHB Lite, APB AHB5 AXI4, AHB Lite, APB, TCM Maximum # external interrupts 32 32 240 240 480 240 CMSIS Support Yes","title":"2.1. Cortex-M comparison"},{"location":"blog/stm32/intro/#22-stm32-mcus-comparison","text":"Compare the core, frequency and memory Type Family Core Max Frequency Flash High Performance STM32H7 Cortex-M7 / Cortex -M4 480 MHz / 240 MHz 1 to 2 MB STM32F7 Cortex-M7 216 MHz 256 KB to 2 MB STM32F4 Cortex-M4 180 MHz 64 KB to 2 MB STM32F2 Cortex-M3 120 MHz 128 KB to 1 MB Mainstream STM32G4 Cortex-M4 170 MHz 32 to 512 KB STM32F3 Cortex-M4 72 MHz 16 to 512 KB STM32F1 Cortex-M3 72 MHz 16 KB to 1 MB STM32G0 Cortex-M0+ 64 MHz 16 to 512 KB STM32F0 Cortex-M0 48 MHz 16 to 256 KB Ultra-low-power STM32L5 Cortex-M33 110 MHz 256 to 512 KB STM32L4+ Cortex-M4 120 MHz 512 KB to 2 MB STM32L4 Cortex-M4 80 MHz 64 KB to 1 MB STM32L1 Cortex-M3 32 MHz 32 to 512 KB STM32L0 Cortex-M0+ 32 MHz 8 to 192 KB Wireless STM32WB Cortex-M4 / Cortex-M0+ 64 MHz / 32 MHz 256 KB to 1 MB STM32WL Cortex-M4 48 MHz 64 KB to 256 KB","title":"2.2. STM32 MCUs comparison"},{"location":"blog/stm32/j-link-rtt/","text":"F051R8 J-Link RTT F411CE J-Link RTT SEGGER_RTT_V720a.zip 1. Real Time Transfer \u2693\ufe0e Visit the Official J-Link RTT page on SEGGER website for more information. J-Link Real Time Transfer \u2014 Manual SEGGER\u2019s J-Link RTT utilizes the background memory access feature on Debug Access Port (DAP) on Cortex-M and RX MCUs to communicate between the MCU and the PC\u2019s host application, through J-Link probes. RTT supports multiple channels in both directions, up to the host and down to the target, which can be used for different purposes and provide the most possible freedom to the user. The default implementation uses one channel per direction, which are meant for printable terminal input and output. With the J-Link RTT Viewer this channel can be used for multiple \u201cvirtual\u201d terminals, allowing to print to multiple windows (e.g. one for standard output, one for error output, one for debugging output) with just one target buffer. An additional up (to host) channel can for example be used to send profiling or event tracing data. 1.1. How RTT Works \u2693\ufe0e Real Time Transfer uses a SEGGER RTT Control Block structure in the target\u2019s memory to manage data reads and writes. The control block contains an ID to make it findable in memory by a connected J-Link and a ring buffer structure for each available channel, describing the channel buffer and its state. The maximum number of available channels can be configured at compile time and each buffer can be configured and added by the application at run time. Up and down buffers can be handled separately. Each channel can be configured to be blocking or non-blocking. In blocking mode the application will wait when the buffer is full, until all memory could be written, resulting in a blocked application state but preventing data from getting lost. In non-blocking mode only data which fits into the buffer, or none at all, will be written, and the rest will be discarded. This allows running in real time, even when no debugger is connected. The developer does not have to create a special debug version and the code can stay in place in a release application. When RTT is active on the host computer, J-Link automatically searches for the SEGGER RTT Control Block in the target\u2019s known RAM regions. The RAM regions or the specific address of the Control Block can also be set via the host applications to speed up detection or the block cannot be found automatically. There may be any number of \u201cUp Buffer Descriptors\u201d (Target \u2192 Host), as well as any number of \u201cDown Buffer Descriptors\u201d (Host \u2192 Target). Each buffer size can be configured individually. The gray areas in the buffers are the areas that contain valid data. For Up buffers, the Write Pointer is written by the target, the Read Pointer is written by the debug probe (J-Link, Host). When Read and Write Pointers point to the same element, the buffer is empty. This assures there is never a race condition. SEGGER RTT does not need any additional pin or hardware, despite a J-Link connected via the standard debug port to the target. It does not require any configuration of the target or in the debugging environment and can even be used with varying target speeds. RTT can be used in parallel to a running debug session, without intrusion, as well as without any IDE or debugger at all. 1.2. RTT Performance \u2693\ufe0e The performance of SEGGER RTT is significantly higher than any other technology used to output data to a host PC. An average line of text can be output in one microsecond or less. Basically only the time to do a single memcopy() . RTT Performance in comparison with SemiHosting and SWO The maximum speed at which output data can be sent to the host depends on the target buffer size and target interface speed. Even with a small target buffer of 512 Bytes an RTT speed of up to 1 MiB/s is possible with a high interface speed and 0.5 MiB/s are possible with a regular J-Link model. 1.3. RTT APIs \u2693\ufe0e The SEGGER RTT implementation is written in ANSI C and can be integrated into any embedded application. RTT can be used via a simple and easy to use API. It is even possible to override the standard printf() functions to use RTT. Using RTT reduces the time taken for printf() to a minimum and allows printing debug information to the host PC, while the application is performing time critical, real time tasks. The SEGGER RTT implementation includes a simple implementation of printf() which can be used to write a formatted string via RTT. SEGGER_RTT_Printf() is smaller than most standard library printf implementations and does not require heap and only a configurable amount of stack. However, it does not support printing double or float numbers. Function Name Description SEGGER_RTT_Read() Read data from an input buffer. SEGGER_RTT_Write() Write data to an output buffer. SEGGER_RTT_WriteString() Write a zero-terminated string to an output buffer. SEGGER_RTT_printf() Write a formatted string to an output buffer. SEGGER_RTT_GetKey() Get one character from input buffer 0. SEGGER_RTT_HasKey() Check if a character is available in input buffer 0. SEGGER_RTT_WaitKey() Wait for a character to be available in input buffer 0 and get it. SEGGER_RTT_ConfigUpBuffer() Configure an up (output) buffer. SEGGER_RTT_ConfigDownBuffer() Configure a down (input) buffer. SEGGER_RTT_Init() Initialize RTT Control Block structure when using RAM only targets. SEGGER_RTT_SetTerminal() Set the \u201cvirtual\u201d Terminal to use for output on channel 0 via Write and WriteString . SEGGER_RTT_TerminalOut() Send a zero-terminated string via a \u201cvirtual\u201d terminal. 1.4. RTT Viewer \u2693\ufe0e J-Link RTT Viewer is the main Windows GUI application to use all features of RTT on the debugging host. RTT Viewer can be used stand-alone, opening an own connection to J-Link and target or in parallel to a running debug session, attaching to it and using this existing J-Link connection. RTT Viewer supports all major features of RTT: Terminal output on Channel 0 Sending text input to Channel 0 Up to 16 virtual Terminals with only one target channel Controlling text output: Colored text, erasing the console Logging data on Channel 1 2. RTT Integration \u2693\ufe0e RTT in the target MCU is provided freely. Firstly, download the J-Link software and install it. Under the installation folder, the source code of RTT on MCU is found in Samples\\\\RTT . At the time of writing this guide, the version of J-Link is 7.20, therefore, user can find the SEGGER_RTT_V720a.zip file there. \u2502 License.txt \u2502 README.txt \u2502 \u251c\u2500RTT \u2502 SEGGER_RTT_Conf.h # Configuration \u2502 SEGGER_RTT.h # Main header \u2502 SEGGER_RTT.c # Main implementation \u2502 SEGGER_RTT_printf.c # Print functions \u2502 SEGGER_RTT_ASM_ARMv7M.S # for Cortex-M3/M4 \u2502 \u251c\u2500Syscalls \u2502 SEGGER_RTT_Syscalls_GCC.c # redirection for GCC and newlib \u2502 SEGGER_RTT_Syscalls_IAR.c # redirection for IAR \u2502 SEGGER_RTT_Syscalls_KEIL.c # redirection for KEIL ARM \u2502 SEGGER_RTT_Syscalls_SES.c # redirection for Segger Embedded System \u2502 \u2514\u2500Examples Main_RTT_InputEchoApp.c # echo characters Main_RTT_MenuApp.c # use character to select an option Main_RTT_PrintfTest.c # print log with format Main_RTT_SpeedTestApp.c # measure execution time To integrate RTT into a project, copy the folder RTT from the SEGGER_RTT_V720a.zip to the project folder. It\u2019s recommend to put header files into Inc folder, and all source file into Src folder, as they will need to add into Build\u2019s Path and Symbols. 3. Lab: Print out with RTT \u2693\ufe0e This lab will guide on how to add RTT into the Build\u2019s Path and Symbols of the project and print log on the Terminal channel 0. 3.1. Start a new project \u2693\ufe0e RTT supports all Cortex-M MCUs, in this lab, an F411CE MCU will be used. To use RTT, just need to enable the SWD interface on pin PA13 (SWDIO) and pin PA14 (SWCLK). 3.2. Import RTT files \u2693\ufe0e As mentioned above, the RTT source folder can be added into project like below: \u251c\u2500Core \u251c\u2500Drivers \u251c\u2500Segger | \u251c\u2500Inc \u2502 | SEGGER_RTT_Conf.h # Configuration \u2502 | SEGGER_RTT.h # Header \u2502 \u2514\u2500Src \u2502 SEGGER_RTT.c # Implementation \u2502 SEGGER_RTT_printf.c # Print functions \u2502 SEGGER_RTT_ASM_ARMv7M.S # for Cortex-M3/M4 Add RTT files Add Include Paths Open the Project Properties and select C/C++ Build \u00bb Settings . Then add ../Segger/Inc into to include paths of both GCC Assembler and GCC Compiler Add source files To make RTT source files get compiled, add the folder /Segger into the Source Location list in the Paths and Symbols setting under the C/C++ General property. Add Include path Add source files 3.3. Add RTT print \u2693\ufe0e In the main.c file, include the SEGGER_RTT.h firstly to import RTT APIs. Inside the int main () function, call to SEGGER_RTT_Init() to initialize the SEGGER RTT Control Block and the Channel 0. Then, it is ok to start using print API, such SEGGER_RTT_printf() to write strings. main.c #include <stdio.h> #ifdef CONFIG_USE_RTT #include \"SEGGER_RTT.h\" #endif unsigned char counter = 0 ; int main ( void ) { #ifdef CONFIG_USE_RTT SEGGER_RTT_Init (); #endif while ( 1 ) { counter ++ ; #ifdef REDIRECT_TO_RTT SEGGER_RTT_printf ( 0 , \"S: counter = %d \\r\\n \" , counter ); #endif HAL_Delay ( 500 ); } } That\u2019s it. It is very simple to use RTT APIs. Compile and flash the firmware into the target MCU and power it up. 4. Start RTT Viewer \u2693\ufe0e Connect any J-Link probe into the SWD interface of the target MCU. Then start the J-Link RTT Viewer in the J-Link software package. J-Link Pro Cloned J-Link OB J-Link JTAG connection J-Link SWD connection Convert ST-LINK to J-LINK SEGGER offers a firmware upgrading the ST-LINK on-board on the Nucleo and Discovery Boards to a J-LINK On-Board debugger. The configuration dialog will show up, select USB mode, and select the Target device from the list of supported devices. RTT Viewer Configs Then the viewer will open the Default Channel 0 to display RTT strings. RTT Viewer 5. Redirect Standard IO to RTT \u2693\ufe0e With the same method to redirect standard IO to UART or VCOM , two low-level function _write() and _read() should be overridden to redirect to RTT. #ifdef REDIRECT_TO_RTT int _read ( int file , char * ptr , int len ) { * ptr = SEGGER_RTT_WaitKey (); return 1 ; } int _write ( int file , char * ptr , int len ) { SEGGER_RTT_Write ( 0 , ptr , len ); return len ; } #endif Blocking input The function SEGGER_RTT_WaitKey() intensionally block the application to read a character. Once a character is available, it is read and this function returns. Here is an example of reading a number using RTT redirection: Use RTT redirection for scanf","title":"J-Link RTT"},{"location":"blog/stm32/j-link-rtt/#1-real-time-transfer","text":"Visit the Official J-Link RTT page on SEGGER website for more information. J-Link Real Time Transfer \u2014 Manual SEGGER\u2019s J-Link RTT utilizes the background memory access feature on Debug Access Port (DAP) on Cortex-M and RX MCUs to communicate between the MCU and the PC\u2019s host application, through J-Link probes. RTT supports multiple channels in both directions, up to the host and down to the target, which can be used for different purposes and provide the most possible freedom to the user. The default implementation uses one channel per direction, which are meant for printable terminal input and output. With the J-Link RTT Viewer this channel can be used for multiple \u201cvirtual\u201d terminals, allowing to print to multiple windows (e.g. one for standard output, one for error output, one for debugging output) with just one target buffer. An additional up (to host) channel can for example be used to send profiling or event tracing data.","title":"1. Real Time Transfer"},{"location":"blog/stm32/j-link-rtt/#11-how-rtt-works","text":"Real Time Transfer uses a SEGGER RTT Control Block structure in the target\u2019s memory to manage data reads and writes. The control block contains an ID to make it findable in memory by a connected J-Link and a ring buffer structure for each available channel, describing the channel buffer and its state. The maximum number of available channels can be configured at compile time and each buffer can be configured and added by the application at run time. Up and down buffers can be handled separately. Each channel can be configured to be blocking or non-blocking. In blocking mode the application will wait when the buffer is full, until all memory could be written, resulting in a blocked application state but preventing data from getting lost. In non-blocking mode only data which fits into the buffer, or none at all, will be written, and the rest will be discarded. This allows running in real time, even when no debugger is connected. The developer does not have to create a special debug version and the code can stay in place in a release application. When RTT is active on the host computer, J-Link automatically searches for the SEGGER RTT Control Block in the target\u2019s known RAM regions. The RAM regions or the specific address of the Control Block can also be set via the host applications to speed up detection or the block cannot be found automatically. There may be any number of \u201cUp Buffer Descriptors\u201d (Target \u2192 Host), as well as any number of \u201cDown Buffer Descriptors\u201d (Host \u2192 Target). Each buffer size can be configured individually. The gray areas in the buffers are the areas that contain valid data. For Up buffers, the Write Pointer is written by the target, the Read Pointer is written by the debug probe (J-Link, Host). When Read and Write Pointers point to the same element, the buffer is empty. This assures there is never a race condition. SEGGER RTT does not need any additional pin or hardware, despite a J-Link connected via the standard debug port to the target. It does not require any configuration of the target or in the debugging environment and can even be used with varying target speeds. RTT can be used in parallel to a running debug session, without intrusion, as well as without any IDE or debugger at all.","title":"1.1. How RTT Works"},{"location":"blog/stm32/j-link-rtt/#12-rtt-performance","text":"The performance of SEGGER RTT is significantly higher than any other technology used to output data to a host PC. An average line of text can be output in one microsecond or less. Basically only the time to do a single memcopy() . RTT Performance in comparison with SemiHosting and SWO The maximum speed at which output data can be sent to the host depends on the target buffer size and target interface speed. Even with a small target buffer of 512 Bytes an RTT speed of up to 1 MiB/s is possible with a high interface speed and 0.5 MiB/s are possible with a regular J-Link model.","title":"1.2. RTT Performance"},{"location":"blog/stm32/j-link-rtt/#13-rtt-apis","text":"The SEGGER RTT implementation is written in ANSI C and can be integrated into any embedded application. RTT can be used via a simple and easy to use API. It is even possible to override the standard printf() functions to use RTT. Using RTT reduces the time taken for printf() to a minimum and allows printing debug information to the host PC, while the application is performing time critical, real time tasks. The SEGGER RTT implementation includes a simple implementation of printf() which can be used to write a formatted string via RTT. SEGGER_RTT_Printf() is smaller than most standard library printf implementations and does not require heap and only a configurable amount of stack. However, it does not support printing double or float numbers. Function Name Description SEGGER_RTT_Read() Read data from an input buffer. SEGGER_RTT_Write() Write data to an output buffer. SEGGER_RTT_WriteString() Write a zero-terminated string to an output buffer. SEGGER_RTT_printf() Write a formatted string to an output buffer. SEGGER_RTT_GetKey() Get one character from input buffer 0. SEGGER_RTT_HasKey() Check if a character is available in input buffer 0. SEGGER_RTT_WaitKey() Wait for a character to be available in input buffer 0 and get it. SEGGER_RTT_ConfigUpBuffer() Configure an up (output) buffer. SEGGER_RTT_ConfigDownBuffer() Configure a down (input) buffer. SEGGER_RTT_Init() Initialize RTT Control Block structure when using RAM only targets. SEGGER_RTT_SetTerminal() Set the \u201cvirtual\u201d Terminal to use for output on channel 0 via Write and WriteString . SEGGER_RTT_TerminalOut() Send a zero-terminated string via a \u201cvirtual\u201d terminal.","title":"1.3. RTT APIs"},{"location":"blog/stm32/j-link-rtt/#14-rtt-viewer","text":"J-Link RTT Viewer is the main Windows GUI application to use all features of RTT on the debugging host. RTT Viewer can be used stand-alone, opening an own connection to J-Link and target or in parallel to a running debug session, attaching to it and using this existing J-Link connection. RTT Viewer supports all major features of RTT: Terminal output on Channel 0 Sending text input to Channel 0 Up to 16 virtual Terminals with only one target channel Controlling text output: Colored text, erasing the console Logging data on Channel 1","title":"1.4. RTT Viewer"},{"location":"blog/stm32/j-link-rtt/#2-rtt-integration","text":"RTT in the target MCU is provided freely. Firstly, download the J-Link software and install it. Under the installation folder, the source code of RTT on MCU is found in Samples\\\\RTT . At the time of writing this guide, the version of J-Link is 7.20, therefore, user can find the SEGGER_RTT_V720a.zip file there. \u2502 License.txt \u2502 README.txt \u2502 \u251c\u2500RTT \u2502 SEGGER_RTT_Conf.h # Configuration \u2502 SEGGER_RTT.h # Main header \u2502 SEGGER_RTT.c # Main implementation \u2502 SEGGER_RTT_printf.c # Print functions \u2502 SEGGER_RTT_ASM_ARMv7M.S # for Cortex-M3/M4 \u2502 \u251c\u2500Syscalls \u2502 SEGGER_RTT_Syscalls_GCC.c # redirection for GCC and newlib \u2502 SEGGER_RTT_Syscalls_IAR.c # redirection for IAR \u2502 SEGGER_RTT_Syscalls_KEIL.c # redirection for KEIL ARM \u2502 SEGGER_RTT_Syscalls_SES.c # redirection for Segger Embedded System \u2502 \u2514\u2500Examples Main_RTT_InputEchoApp.c # echo characters Main_RTT_MenuApp.c # use character to select an option Main_RTT_PrintfTest.c # print log with format Main_RTT_SpeedTestApp.c # measure execution time To integrate RTT into a project, copy the folder RTT from the SEGGER_RTT_V720a.zip to the project folder. It\u2019s recommend to put header files into Inc folder, and all source file into Src folder, as they will need to add into Build\u2019s Path and Symbols.","title":"2. RTT Integration"},{"location":"blog/stm32/j-link-rtt/#3-lab-print-out-with-rtt","text":"This lab will guide on how to add RTT into the Build\u2019s Path and Symbols of the project and print log on the Terminal channel 0.","title":"3. Lab: Print out with RTT"},{"location":"blog/stm32/j-link-rtt/#31-start-a-new-project","text":"RTT supports all Cortex-M MCUs, in this lab, an F411CE MCU will be used. To use RTT, just need to enable the SWD interface on pin PA13 (SWDIO) and pin PA14 (SWCLK).","title":"3.1. Start a new project"},{"location":"blog/stm32/j-link-rtt/#32-import-rtt-files","text":"As mentioned above, the RTT source folder can be added into project like below: \u251c\u2500Core \u251c\u2500Drivers \u251c\u2500Segger | \u251c\u2500Inc \u2502 | SEGGER_RTT_Conf.h # Configuration \u2502 | SEGGER_RTT.h # Header \u2502 \u2514\u2500Src \u2502 SEGGER_RTT.c # Implementation \u2502 SEGGER_RTT_printf.c # Print functions \u2502 SEGGER_RTT_ASM_ARMv7M.S # for Cortex-M3/M4 Add RTT files Add Include Paths Open the Project Properties and select C/C++ Build \u00bb Settings . Then add ../Segger/Inc into to include paths of both GCC Assembler and GCC Compiler Add source files To make RTT source files get compiled, add the folder /Segger into the Source Location list in the Paths and Symbols setting under the C/C++ General property. Add Include path Add source files","title":"3.2. Import RTT files"},{"location":"blog/stm32/j-link-rtt/#33-add-rtt-print","text":"In the main.c file, include the SEGGER_RTT.h firstly to import RTT APIs. Inside the int main () function, call to SEGGER_RTT_Init() to initialize the SEGGER RTT Control Block and the Channel 0. Then, it is ok to start using print API, such SEGGER_RTT_printf() to write strings. main.c #include <stdio.h> #ifdef CONFIG_USE_RTT #include \"SEGGER_RTT.h\" #endif unsigned char counter = 0 ; int main ( void ) { #ifdef CONFIG_USE_RTT SEGGER_RTT_Init (); #endif while ( 1 ) { counter ++ ; #ifdef REDIRECT_TO_RTT SEGGER_RTT_printf ( 0 , \"S: counter = %d \\r\\n \" , counter ); #endif HAL_Delay ( 500 ); } } That\u2019s it. It is very simple to use RTT APIs. Compile and flash the firmware into the target MCU and power it up.","title":"3.3. Add RTT print"},{"location":"blog/stm32/j-link-rtt/#4-start-rtt-viewer","text":"Connect any J-Link probe into the SWD interface of the target MCU. Then start the J-Link RTT Viewer in the J-Link software package. J-Link Pro Cloned J-Link OB J-Link JTAG connection J-Link SWD connection Convert ST-LINK to J-LINK SEGGER offers a firmware upgrading the ST-LINK on-board on the Nucleo and Discovery Boards to a J-LINK On-Board debugger. The configuration dialog will show up, select USB mode, and select the Target device from the list of supported devices. RTT Viewer Configs Then the viewer will open the Default Channel 0 to display RTT strings. RTT Viewer","title":"4. Start RTT Viewer"},{"location":"blog/stm32/j-link-rtt/#5-redirect-standard-io-to-rtt","text":"With the same method to redirect standard IO to UART or VCOM , two low-level function _write() and _read() should be overridden to redirect to RTT. #ifdef REDIRECT_TO_RTT int _read ( int file , char * ptr , int len ) { * ptr = SEGGER_RTT_WaitKey (); return 1 ; } int _write ( int file , char * ptr , int len ) { SEGGER_RTT_Write ( 0 , ptr , len ); return len ; } #endif Blocking input The function SEGGER_RTT_WaitKey() intensionally block the application to read a character. Once a character is available, it is read and this function returns. Here is an example of reading a number using RTT redirection: Use RTT redirection for scanf","title":"5. Redirect Standard IO to RTT"},{"location":"blog/stm32/j-link-sysview/","text":"SEGGER_SysView_V330.zip F051R8 J-Link SysView NoOS F411CE J-Link SysView NoOS F411CE_RTOS_Simple_Tasks_SysView.zip 1. System View \u2693\ufe0e Visit the Official J-Link System View page on SEGGER website for more information. J-Link System View \u2014 Manual SEGGER\u2019s J-Link System View is written on top of the excellent J-Link Real-Time Transfer to record many types of events in real-time in an embedded system. Those events can be interrupts, timers, task switches and scheduling with an RTOS, API function calls and returns, or user events and messages. The events are retrieved from the target, analyzed and visualized in the System View Application , while the target keeps running. 1.1. How System View Works \u2693\ufe0e To keep the communication overhead on the target system low, it only needs to record basic information, such as \u201cFunction with ID X has been called with parameter values y and z at the n ticks after the last event\u201d. System View analyzes all information from the events and shows: The recording time or system time when the call happened The task/context in which the call happened The interrupt name, timer ID, and marker name The API function name and its parameters and values The duration of the any pair of start-stop, enter-exit events The timestamps for events can be as accurate as 1 CPU cycle. A regular event is just 4 to 8 bytes long. 1.2. Figure out Potential problems \u2693\ufe0e Issues and inefficiencies in the system can be identified below ways: Incorrect task priorities or priority inversion leading to starvation Incorrect inter-task communication Inefficient delays and timeouts Spurious or unnecessary interrupts Unexpected log run-time of a short task High CPU Load can lead to: Bottlenecks which may lead to delayed execution of important tasks Dropped data or overflow of incoming buffer 1.3. System View License \u2693\ufe0e System View may be used with a non-commercial license for evaluation, educational and hobbyist purposes. When using System View under the non-commercial license, no activation is required. On start of the System View Application, a popup is presented, the click Continue to accept the license terms. No Commercial-Use License 1.4. System View APIs \u2693\ufe0e The SEGGER System View implementation is written in ANSI C on the top of RTT, therefore, it can be easily integrated into any embedded application. The System View needs to be initialized before it can be used. However, it does not automatically run to reduce CPU Load and power usage. System View only runs when it gets request from Host\u2019s System View Application. Control functions Function Description SEGGER_SYSVIEW_Init() Initializes the SYSVIEW module SEGGER_SYSVIEW_Start() Start recording System View events. This function is triggered by the System View Application on connect. SEGGER_SYSVIEW_Stop() Stop recording System View events. This function is triggered by the System View Application on disconnect. Configuration functions Function Description SEGGER_SYSVIEW_Conf() Initialize and configures System View SEGGER_SYSVIEW_SetRAMBase() Sets the RAM base address SEGGER_SYSVIEW_SendSysDesc() Send the system description string to the host SEGGER_SYSVIEW_SendTaskList() Send all tasks descriptors to the host SEGGER_SYSVIEW_SendTaskInfo() Send a Task Info Packet, containing TaskId for identification, task priority and task name SEGGER_SYSVIEW_X_GetTimestamp() Callback called by System View to get the timestamp in cycles Event recording functions Function Description SEGGER_SYSVIEW_RecordEnterISR() Format and send an ISR entry event SEGGER_SYSVIEW_RecordExitISR() Format and send an ISR exit event SEGGER_SYSVIEW_RecordEnterTimer() Format and send a Timer entry event SEGGER_SYSVIEW_RecordExitTimer() Format and send a Timer exit event SEGGER_SYSVIEW_OnIdle() Record an Idle event SEGGER_SYSVIEW_OnTaskCreate() Record a Task Create event SEGGER_SYSVIEW_OnTaskStartExec() Record a Task Start Execution event SEGGER_SYSVIEW_OnTaskStartReady() Record a Task Start Ready event SEGGER_SYSVIEW_OnTaskStopExec() Record a Task Stop Execution event SEGGER_SYSVIEW_OnTaskStopReady() Record a Task Stop Ready event SEGGER_SYSVIEW_OnTaskTerminate() Record a Task termination event SEGGER_SYSVIEW_MarkStart() Record a Performance Marker Start event to start measuring runtime SEGGER_SYSVIEW_Mark() Record a Performance Marker intermediate event SEGGER_SYSVIEW_MarkStop() Record a Performance Marker Stop event to stop measuring runtime User API recording functions Function Description SEGGER_SYSVIEW_RecordVoid() Formats and sends a System View packet with an empty payload SEGGER_SYSVIEW_RecordU32() Formats and sends a System View packet containing a single U32 parameter payload SEGGER_SYSVIEW_RecordU32x[2:10]() Formats and sends a System View packet containing [2:10] U32 parameter payload SEGGER_SYSVIEW_RecordString() Formats and sends a System View packet containing a string SEGGER_SYSVIEW_RecordEndCall() Format and send an End API Call event without return value. SEGGER_SYSVIEW_RecordEndCallU32() Format and send an End API Call event with a return value Message recording functions Function Description SEGGER_SYSVIEW_Print() Print a string to the host SEGGER_SYSVIEW_Warn() Print a warning string to the host SEGGER_SYSVIEW_Error() Print an error string to the host SEGGER_SYSVIEW_PrintfHost() Print a string which is formatted on the host by the System View Application SEGGER_SYSVIEW_WarnfHost() Print a string which is formatted on the host by the System View Application SEGGER_SYSVIEW_ErrorfHost() Print an error string which is formatted on the host by the System View Application To reduce CPU cycles used by System View to format strings, System View function *fHost() just sends a raw string and its params to the host! 2. System View Integration \u2693\ufe0e Install the System View Application firstly at System View download page . After installation, go the application folder to get the latest source code of System View target integration, for example C:\\Program Files\\SEGGER\\System View\\Src . Here is SEGGER_SysView_V330.zip . \u251c\u2500Config \u2502 Global.h # Typedef for data types \u2502 SEGGER_RTT_Conf.h # Default RTT configs \u2502 SEGGER_SYSVIEW_Conf.h # User SysView Configs | \u251c\u2500\u2500SEGGER \u2502 \u2502 SEGGER.h # Segger common defines \u2502 \u2502 SEGGER_RTT.h # RTT Header \u2502 \u2502 SEGGER_RTT.c # RTT implementation \u2502 \u2502 SEGGER_RTT_ASM_ARMv7M.S # for Cortex-M3/M4 \u2502 \u2502 SEGGER_RTT_printf.c # Print functions \u2502 \u2502 SEGGER_SYSVIEW_ConfDefaults.h # SysView Default Configs \u2502 \u2502 SEGGER_SYSVIEW_Int.h # SysView Internal defines \u2502 \u2502 SEGGER_SYSVIEW.h # SysView header \u2502 \u2502 SEGGER_SYSVIEW.c # SysView implementation \u2502 \u2502 \u2502 \u2514\u2500\u2500\u2500Syscalls # Standard IO redirection \u2502 \u2514\u2500Sample # Sample configs for diff. targets \u251c\u2500\u2500\u2500COMM # Example to record on UART \u251c\u2500\u2500\u2500embOS # Example configs \u251c\u2500\u2500\u2500FreeRTOSV10 # Example configs \u251c\u2500\u2500\u2500FreeRTOSV8 # Example configs \u251c\u2500\u2500\u2500FreeRTOSV9 # Example configs \u251c\u2500\u2500\u2500MicriumOSKernel # Example configs \u251c\u2500\u2500\u2500uCOS-II # Example configs \u251c\u2500\u2500\u2500uCOS-III # Example configs \u2514\u2500\u2500\u2500NoOS # Example configs \u2514\u2500\u2500\u2500Config \u251c\u2500\u2500\u2500RX \u251c\u2500\u2500\u2500Cortex-M \u2502 SEGGER_SYSVIEW_Config_NoOS.c \u2514\u2500\u2500\u2500Cortex-M0 SEGGER_SYSVIEW_Config_NoOS_CM0.c To integrate System View into a project,it\u2019s recommend to put header files into Inc folder, and all source file into Src folder, as they will need to add into Build\u2019s Path and Symbols. 3. Lab 1: Analyze a Non-OS firmware \u2693\ufe0e This lab will guide on how to add System View into an application and record its activity to analyze them. As System View is based on RTT which runs through SWD interface, the guide to integrate on Cortex-M MCUs is the same in general. There are some steps needed for specific CPU lines, as can be seen in the Sample files of SEGGER. Target application Blink an LED at 100 Hz using a general Timer Increase a counter value by one when press on a Button using External Interrupt Send the above counter value on an UART port every 100 ms in the main loop 3.1. Start a new project \u2693\ufe0e This guide is written based on projects with STM32F051R8 (Cortex-M0) as it needs more configs than other Cortex-M MCUs. Here are settings applied to a new project before starting to add System View: Check if you need to enable HSE or LSE when using external crystals Setup debug mode for using SWD on PA13 (SWDIO) and PA14 (SWCLK) Setup Clock path, PLL, and the system frequency Enable UART1 , set baud rate at 115200 bps, mode 8-N-1, and enable its interrupt Enable the general purpose timer, e.g. TIM3 , and set to use internal system clock, interrupt at 100 Hz Config a button input of PA0 with External Interrupt mode Config a LED output on any available GPIO pin, e.g. PC8 or PC13 Here is the base code of the in the main.c file for this application\u2019s requirement: main.c #include <stdio.h> #include <string.h> TIM_HandleTypeDef htim3 ; UART_HandleTypeDef huart1 ; unsigned char counter = 0 ; char buffer [ 16 ] = { 0 }; // counter=xxx\\r\\n void SystemClock_Config ( void ){...} static void MX_GPIO_Init ( void ){...} static void MX_USART1_UART_Init ( void ){...} static void MX_TIM3_Init ( void ){...} void HAL_TIM_PeriodElapsedCallback ( TIM_HandleTypeDef * htim ) { if ( htim == & htim3 ) { HAL_GPIO_TogglePin ( LED_GPIO_Port , LED_Pin ); } } void HAL_GPIO_EXTI_Callback ( uint16_t GPIO_Pin ) { if ( GPIO_Pin == GPIO_PIN_0 ) { counter ++ ; } } void HAL_UART_TxCpltCallback ( UART_HandleTypeDef * huart ) { if ( huart == & huart1 ) { } } int main ( void ) { HAL_Init (); SystemClock_Config (); MX_GPIO_Init (); MX_USART1_UART_Init (); MX_TIM3_Init (); HAL_TIM_Base_Start_IT ( & htim3 ); while ( 1 ) { sprintf ( buffer , \"counter = %03d \\r\\n \" , counter ); HAL_UART_Transmit ( & huart1 , ( uint8_t * ) buffer , strlen ( buffer ), HAL_MAX_DELAY ); HAL_Delay ( 100 ); } } When start up, this application prints out counter = 000 every 100 ms. If press on the Button, the counter value is increased, not always by 1, but sometimes by 3, 4, or more, due to un-debounced input. 3.2. Import System View files \u2693\ufe0e The base files of SEGGER System View can be added in a separated folder Segger , and custom config files can can be added into the project main folder. See the below folder structure: Sample files SEGGER provides Sample files for different types of OS and CPU. Make sure to include correct header and source files for the target project. Read the System View Manual for more details of each type of OS and CPU support. This project is for STM32F051R8 MCU which is based on Cortex-M0 CPU, therefore, the file SEGGER_SYSVIEW_Config_NoOS_CM0.c will be included. Add Include Paths Open the Project Properties and select C/C++ Build \u00bb Settings . Then add ../Segger/Inc into to include paths of both GCC Assembler and GCC Compiler Add Include path Add source files To make System View source files get compiled, add the folder /Segger into the Source Location list in the Paths and Symbols setting under the C/C++ General property. Add source files 3.3. Configure System View \u2693\ufe0e Before System View can be used, it needs to be initialized, including: Setup RTT base Set RAM Base address Send Device Information Send Interrupts description Set Timestamp source In the main.c , include the SEGGER System View header files, then in the main() function, call to SEGGER_SYSVIEW_Conf() function to initialize the System View stuff: main.c #include \"SEGGER_SYSVIEW_Conf.h\" #include \"SEGGER_SYSVIEW.h\" int main () { SEGGER_SYSVIEW_Conf (); // initialize System View while ( 1 ) {...} } Normally, SEGGER_SYSVIEW_Conf() will initialize the System View with System Clock Frequency (saved in SystemCoreClock variable) for timestamp resolution, and provide a _cbSendSystemDesc() callback function which will be executed when the host application requests to start monitoring. The device information have to be sent to host application, with custom data, therefore it is implemented in the SEGGER_SYSVIEW_Config_NoOS_CM0.c . The next step is to set the RAM Base address. Every variable\u2019s address will be subtracted to this base address to get an offset value which is later encoded in only 1 or 2 bytes. The RAM Base address for ARM all Cortex-M MCUs is 0x20000000 : SEGGER_SYSVIEW_Config_NoOS_CM0.c #define SYSVIEW_RAM_BASE (0x20000000) Here is the SEGGER_SYSVIEW_Conf() function: void SEGGER_SYSVIEW_Conf ( void ) { SEGGER_SYSVIEW_Init ( SYSVIEW_TIMESTAMP_FREQ , SYSVIEW_CPU_FREQ , 0 , _cbSendSystemDesc ); SEGGER_SYSVIEW_SetRAMBase ( SYSVIEW_RAM_BASE ); } Next step is to implement the callback function _cbSendSystemDesc() which sends the Device information, including the App Name, the Device Name, the Core Name, the OS Name, and the interrupts used in the application: SEGGER_SYSVIEW_Config_NoOS_CM0.c #define SYSVIEW_APP_NAME \"System View Demo\" #define SYSVIEW_DEVICE_NAME \"STM32F051R8\" #define SYSVIEW_CORE_NAME \"Cortex-M0\" #define SYSVIEW_OS_NAME \"Non-OS_Cortex-M0\" static void _cbSendSystemDesc ( void ) { SEGGER_SYSVIEW_SendSysDesc ( \"N=\" SYSVIEW_APP_NAME \",\" \"D=\" SYSVIEW_DEVICE_NAME \",\" \"C=\" SYSVIEW_CORE_NAME \",\" \"O=\" SYSVIEW_OS_NAME ); SEGGER_SYSVIEW_SendSysDesc ( \"I#15=SysTick\" ); SEGGER_SYSVIEW_SendSysDesc ( \"I#21=EXTI0_1_IRQHandler\" ); SEGGER_SYSVIEW_SendSysDesc ( \"I#32=TIM3_IRQHandler\" ); SEGGER_SYSVIEW_SendSysDesc ( \"I#43=USART1_IRQHandler\" ); } The OS Name also is used by System View Application to load useful descriptions for displaying analysed data. Read more in APIs Descriptions . The Interrupt number can be found in the g_pfnVectors table in the startup_stm32f051r8tx.s . Different cores have different interrupt mapping, even some interrupts remain the same number, e.g. the interrupt SysTick_Handler always is mapped to the number #15. Application should only send in-use interrupts to the host. The main loop, and each interrupt is considered as a different context. g_pfnVectors : . word _estack . word Reset_Handler /* 1 */ . word NMI_Handler /* 2 */ . word HardFault_Handler /* 3 */ . word 0 /* 4 */ . word 0 /* 5 */ . word 0 /* 6 */ . word 0 /* 7 */ . word 0 /* 8 */ . word 0 /* 9 */ . word 0 /* 10 */ . word SVC_Handler /* 11 */ . word 0 /* 12 */ . word 0 /* 13 */ . word PendSV_Handler /* 14 */ . word SysTick_Handler /* 15 */ . word WWDG_IRQHandler /* 16 */ . word PVD_IRQHandler /* 17 */ . word RTC_IRQHandler /* 18 */ . word FLASH_IRQHandler /* 19 */ . word RCC_CRS_IRQHandler /* 20 */ . word EXTI0_1_IRQHandler /* 21 */ . word EXTI2_3_IRQHandler /* 22 */ . word EXTI4_15_IRQHandler /* 23 */ . word TSC_IRQHandler /* 24 */ . word DMA1_Channel1_IRQHandler /* 25 */ . word DMA1_Channel2_3_IRQHandler /* 26 */ . word DMA1_Channel4_5_IRQHandler /* 27 */ . word ADC1_COMP_IRQHandler /* 28 */ . word TIM1_BRK_UP_TRG_COM_IRQHandler /* 29 */ . word TIM1_CC_IRQHandler /* 30 */ . word TIM2_IRQHandler /* 31 */ . word TIM3_IRQHandler /* 32 */ . word TIM6_DAC_IRQHandler /* 33 */ . word 0 /* 34 */ . word TIM14_IRQHandler /* 35 */ . word TIM15_IRQHandler /* 36 */ . word TIM16_IRQHandler /* 37 */ . word TIM17_IRQHandler /* 38 */ . word I2C1_IRQHandler /* 39 */ . word I2C2_IRQHandler /* 40 */ . word SPI1_IRQHandler /* 41 */ . word SPI2_IRQHandler /* 42 */ . word USART1_IRQHandler /* 43 */ . word USART2_IRQHandler /* 44 */ . word 0 /* 45 */ . word CEC_CAN_IRQHandler /* 46 */ . word 0 /* 47 */ The final step is to help System View find the system timestamp which is used in all events for processing the timeline of recorded events. For Cortex-M0, it is needed to increase the variable SEGGER_SYSVIEW_TickCnt in the SysTick interrupt, as soon as that handler is executed. This variable is used in the function SEGGER_SYSVIEW_X_GetTimestamp() to correctly calculate the clock cycles. stm32f0xx_it #include \"SEGGER_SYSVIEW.h\" void SysTick_Handler ( void ) { SEGGER_SYSVIEW_TickCnt ++ ; HAL_IncTick (); } Cycle counter Except on Cortex-M0 MCUs do not have Cycle Counter, therefore, it needs to be calculated manually based on the SysTick interrupt and the SysTick reload register. Other Cortex-M CPU has CPU Cycle Counter register to be used as system timestamp. Both of two methods provide 1-cycle resolution. 3.4. Print messages to host \u2693\ufe0e To log the counter value to both the UART1 interface and the System View application, add the function all SEGGER_SYSVIEW_Print() which sends a string to the host: main.c while ( 1 ) { sprintf ( buffer , \"counter = %03d \\r\\n \" , counter ); HAL_UART_Transmit ( & huart1 , ( uint8_t * ) buffer , strlen ( buffer ), HAL_MAX_DELAY ); SEGGER_SYSVIEW_Print ( buffer ); HAL_Delay ( 100 ); } 3.5. Run the System View \u2693\ufe0e Connect any J-Link probe into the SWD interface of the target MCU. Then start the System View application on the host PC. J-Link Pro Cloned J-Link OB J-Link JTAG connection J-Link SWD connection Convert ST-LINK to J-LINK SEGGER offers a firmware upgrading the ST-LINK on-board on the Nucleo and Discovery Boards to a J-LINK On-Board debugger. Start the System View for the first time, it will show a recorded example. Go to Tools \u00bb Preferences and uncheck the checkbox Load last data on start . When starting to record a new session, it is recommended to check and set the target device. Press Alt + Return to show the device selection: Device selection Press F5 or click on the start button to start recording. At the beginning step in this lab, the System View will display: Device information which are set above The message of counter value every 100 ms System View with device info and some messages 3.6. Record interrupts \u2693\ufe0e In the file stm32f0xx_it.c , in each concerning interrupt handler, add a pair of ISR recording function SEGGER_SYSVIEW_RecordEnterISR() and SEGGER_SYSVIEW_RecordExitISR() to track the interrupts. It automatically retrieves the interrupt ID via a special register implemented in the SEGGER_SYSVIEW_GET_INTERRUPT_ID() function macro: main.c void SysTick_Handler ( void ) { SEGGER_SYSVIEW_TickCnt ++ ; // must be at the beginning SEGGER_SYSVIEW_RecordEnterISR (); HAL_IncTick (); SEGGER_SYSVIEW_RecordExitISR (); } void EXTI0_1_IRQHandler ( void ) { SEGGER_SYSVIEW_RecordEnterISR (); HAL_GPIO_EXTI_IRQHandler ( GPIO_PIN_0 ); SEGGER_SYSVIEW_RecordExitISR (); } void TIM3_IRQHandler ( void ) { SEGGER_SYSVIEW_RecordEnterISR (); HAL_TIM_IRQHandler ( & htim3 ); SEGGER_SYSVIEW_RecordExitISR (); } void USART1_IRQHandler ( void ) { SEGGER_SYSVIEW_RecordEnterISR (); HAL_UART_IRQHandler ( & huart1 ); SEGGER_SYSVIEW_RecordExitISR (); } This time, when recording with System View, there are many events captured. Below is a screenshot of the moment I pressed on the BUTTON once, which does not have a debouncing filter, there were a lot of ISRs triggered. That explains why the counter variable were increased multiple times. System View with Interrupt context 3.7. Record a function \u2693\ufe0e It\u2019s known that the HAL IRQs take care a lot of user cases, which indeed causes wasting time, before it calls to a user\u2019s callback function. The System View records to enter and the exit event of an interrupt, but it does not automatically record a user function. To do that, application must manually set the starting point of the function\u2019s entry with one of: SEGGER_SYSVIEW_RecordVoid() , or SEGGER_SYSVIEW_RecordU32() , or SEGGER_SYSVIEW_RecordString() and the ending point of that function with one of: SEGGER_SYSVIEW_RecordEndCall() , or SEGGER_SYSVIEW_RecordEndCallU32() function. These functions need an ID to distinguish the different APIs. ID is 2 bytes, comparing to an API function name which usually is much more than 2 bytes, it is very short to save sending bandwidth. For example, to measure the main loop, and user callback functions, define some IDs starting from 32 as below: SEGGER_SYSVIEW_Conf.h #define APP_EVTID_MAIN_LOOP 32 #define APP_EVTID_HAL_TIM_PeriodElapsedCallback 33 #define APP_EVTID_HAL_GPIO_EXTI_Callback 34 #define APP_EVTID_HAL_UART_TxCpltCallback 35 main.c void HAL_TIM_PeriodElapsedCallback ( TIM_HandleTypeDef * htim ) { SEGGER_SYSVIEW_RecordVoid ( APP_EVTID_HAL_TIM_PeriodElapsedCallback ); if ( htim == & htim3 ) { HAL_GPIO_TogglePin ( LED_GPIO_Port , LED_Pin ); } SEGGER_SYSVIEW_RecordEndCall ( APP_EVTID_HAL_TIM_PeriodElapsedCallback ); } void HAL_GPIO_EXTI_Callback ( uint16_t GPIO_Pin ) { SEGGER_SYSVIEW_RecordVoid ( APP_EVTID_HAL_GPIO_EXTI_Callback ); if ( GPIO_Pin == GPIO_PIN_0 ) { counter ++ ; } SEGGER_SYSVIEW_RecordEndCall ( APP_EVTID_HAL_GPIO_EXTI_Callback ); } void HAL_UART_TxCpltCallback ( UART_HandleTypeDef * huart ) { SEGGER_SYSVIEW_RecordVoid ( APP_EVTID_HAL_UART_TxCpltCallback ); if ( huart == & huart1 ) { } SEGGER_SYSVIEW_RecordEndCall ( APP_EVTID_HAL_UART_TxCpltCallback ); } int main ( void ) { while ( 1 ) { SEGGER_SYSVIEW_RecordVoid ( APP_EVTID_MAIN_LOOP ); sprintf ( buffer , \"counter = %03d \\r\\n \" , counter ); HAL_UART_Transmit ( & huart1 , ( uint8_t * ) buffer , strlen ( buffer ), HAL_MAX_DELAY ); SEGGER_SYSVIEW_Print ( buffer ); HAL_Delay ( 100 ); SEGGER_SYSVIEW_RecordEndCall ( APP_EVTID_MAIN_LOOP ); } } System View reserved IDs The first 32 IDs from 0 to 31 are reserved by System View for its defined events: SEGGER_SYSVIEW.h #define SYSVIEW_EVTID_NOP 0 // Dummy packet. #define SYSVIEW_EVTID_OVERFLOW 1 #define SYSVIEW_EVTID_ISR_ENTER 2 #define SYSVIEW_EVTID_ISR_EXIT 3 #define SYSVIEW_EVTID_TASK_START_EXEC 4 #define SYSVIEW_EVTID_TASK_STOP_EXEC 5 #define SYSVIEW_EVTID_TASK_START_READY 6 #define SYSVIEW_EVTID_TASK_STOP_READY 7 #define SYSVIEW_EVTID_TASK_CREATE 8 #define SYSVIEW_EVTID_TASK_INFO 9 #define SYSVIEW_EVTID_TRACE_START 10 #define SYSVIEW_EVTID_TRACE_STOP 11 #define SYSVIEW_EVTID_SYSTIME_CYCLES 12 #define SYSVIEW_EVTID_SYSTIME_US 13 #define SYSVIEW_EVTID_SYSDESC 14 #define SYSVIEW_EVTID_MARK_START 15 #define SYSVIEW_EVTID_MARK_STOP 16 #define SYSVIEW_EVTID_IDLE 17 #define SYSVIEW_EVTID_ISR_TO_SCHEDULER 18 #define SYSVIEW_EVTID_TIMER_ENTER 19 #define SYSVIEW_EVTID_TIMER_EXIT 20 #define SYSVIEW_EVTID_STACK_INFO 21 #define SYSVIEW_EVTID_MODULEDESC 22 #define SYSVIEW_EVTID_INIT 24 #define SYSVIEW_EVTID_NAME_RESOURCE 25 #define SYSVIEW_EVTID_PRINT_FORMATTED 26 #define SYSVIEW_EVTID_NUMMODULES 27 #define SYSVIEW_EVTID_END_CALL 28 #define SYSVIEW_EVTID_TASK_TERMINATE 29 #define SYSVIEW_EVTID_EX 31 User can define custom IDs starting from 32 in the SEGGER_SYSVIEW_Conf.h header. Lets what appear on the System View events: There are recorded events for starting and ending of an API. However, there is just event ID, not a human-friendly readable API name. In the below image, the TIM3 IRQ handler took 43 us to run, in which the user callback function took 14 us. System View with custom API event ID 3.8. OS Description file \u2693\ufe0e In order for System View to properly decode API calls it requires a description file to be present in the /description/ directory of System View. The name of the file has to be SYSVIEW_<OSName>.txt where <OSName> is the name as sent in the system description. This lab use Non-OS_Cortex-M0 as the OS Name, therefore, it should be a SYSVIEW_Non-OS_Cortex-M0.txt file in the description folder of System View. Warning of the OS description file A description file includes all API functions which can be recorded by the OS. Each line in the file is one function in the following format: <ID> <Name> <Parameters> | <ReturnValue> <Id> is the Id which is recorded for the API function. It can be in the range of 32 to 511. <Name> is the name of the API function, displayed in the Event column of System View. It may not contain spaces. <Parameters> and <ReturnValue> are the description string of the parameters which are recorded with the API functions. The ReturnValueDescription is optional. The parameter display can be configured by a set of modifiers: %b - Display parameter as binary. %B - Display parameter as hexadecimal string (e.g. 00 AA FF \u2026). %d - Display parameter as signed decimal integer. %D - Display parameter as time value. %I - Display parameter as a resource name if the resource id is known to System View. %p - Display parameter as 4 byte hexadecimal integer (e.g. 0xAABBCCDD). %s - Display parameter as string. %t - Display parameter as a task name if the task id is known to System View. %u - Display parameter as unsigned decimal integer. %x - Display parameter as hexadecimal integer. The following example shows a part of SYSVIEW_embOS.txt : 46 OS_CreateTask Task=%t Pri=%u Stack=%p Size=%u In addition to the default modifiers the description file can define NamedTypes to map numerical values to strings, which can for example be useful to display the textual value of enums or error codes. The special character * represents for all remaining unmapped values. NamedTypes have following format: NamedType <TypeName> <Key>=<Value> [<Key1>=<Value1> ...] NamedTypes can be used in the <Parameters> and the <ReturnValue> : # Types for parameter formatters NamedType OSErr 0=OS_ERR_NONE 10000=OS_ERR_A # API Functions 34 OSFunc Param=%OSFlag | Returns %OSErr When a task pauses execution its state is recorded in the System View event. This task state can be converted to a textual representation in System View with the TaskState description. TaskState has following format: TaskState <Mask> <Key>=<Value>, [<Key1>=<Value1>, ...] # Task States TaskState 0xFF 0=Ready, 1=Delayed or Timeout Always have an empty line in the OS description file to make the last line is parsed properly Here is an example of OS Description file used in this lab. There are 2 NamedType defined there, %UARTx and %TIMx which take the mapping address of a peripheral to look up its name using the Data-sheet document. SYSVIEW_Non-OS_Cortex-M0.txt # Types NamedType UARTx * = %p 0x40013800 = UART1 0x40004400 = UART2 NamedType TIMx * = %p 0x40012C00 = TIM1 0x40000400 = TIM3 NamedType PINx * = %u 0x0 = None 0x1 = PIN0 0x2 = PIN1 # API IDs 32 Main_Loop 33 HAL_TIM_PeriodElapsedCallback Instance = %TIMx 34 GPIO_EXTI_Callback GPIO_Pin = %Pinx 35 HAL_UART_TxCpltCallback Instance = %UARTx Then, the recording function should be changed to transfer API parameters: void HAL_TIM_PeriodElapsedCallback ( TIM_HandleTypeDef * htim ) { SEGGER_SYSVIEW_RecordU32 ( APP_EVTID_HAL_TIM_PeriodElapsedCallback , ( U32 ) htim -> Instance ); if ( htim == & htim3 ) { HAL_GPIO_TogglePin ( LED_GPIO_Port , LED_Pin ); } SEGGER_SYSVIEW_RecordEndCall ( APP_EVTID_HAL_TIM_PeriodElapsedCallback ); } The result is much better, with API name and some extra information: System View with API name and its extra info Then, use the API description file with string formatter in more complex example: void HAL_GPIO_EXTI_Callback ( uint16_t GPIO_Pin ) { SEGGER_SYSVIEW_RecordU32 ( APP_EVTID_HAL_GPIO_EXTI_Callback , GPIO_Pin ); if ( GPIO_Pin == GPIO_PIN_0 ) { counter ++ ; SEGGER_SYSVIEW_WarnfHost ( \"counter set to %d\" , counter ); } SEGGER_SYSVIEW_RecordEndCall ( APP_EVTID_HAL_GPIO_EXTI_Callback ); } System View with warning message 3.9. Measure performance \u2693\ufe0e To measure performance, System View uses Markers to calculate the execution time between a starting point and a corresponding ending point. This lab will send the counter value in two method: blocking, and interrupt. The functions to measure performance is SEGGER_SYSVIEW_MarkStart() and SEGGER_SYSVIEW_MarkStop() , which need IDs to create pairs. Let\u2019s start with defining two marker IDs: SEGGER_SYSVIEW_Conf.h #define APP_MARKER_UART_TX_BLOCKING 0 #define APP_MARKER_UART_TX_INTERRUPT 1 Then send the marker names in the Device Information callback function: static void _cbSendSystemDesc ( void ) { SEGGER_SYSVIEW_SendSysDesc (...); SEGGER_SYSVIEW_NameMarker ( APP_MARKER_UART_TX_BLOCKING , \"UART_TX_Blocking\" ); SEGGER_SYSVIEW_NameMarker ( APP_MARKER_UART_TX_INTERRUPT , \"UART_TX_Interrupt\" ); } In the main while loop, firstly, send the counter value using the block method. Wrap the blocking method with a pair of markers. After the blocking method finish, start the Interrupt method. Note that, in main loop, only mark the starting time. An interrupt will be called when all bytes are transmitted in the HAL_UART_TxCpltCallback() function, therefore, add the ending marker there to calculate the second case. void HAL_UART_TxCpltCallback ( UART_HandleTypeDef * huart ) { SEGGER_SYSVIEW_RecordU32 ( APP_EVTID_HAL_UART_TxCpltCallback , ( U32 ) huart -> Instance ); if ( huart == & huart1 ) { SEGGER_SYSVIEW_MarkStop ( APP_MARKER_UART_TX_INTERRUPT ); } SEGGER_SYSVIEW_RecordEndCall ( APP_EVTID_HAL_UART_TxCpltCallback ); } int main () { ... while ( 1 ) { SEGGER_SYSVIEW_RecordVoid ( APP_EVTID_MAIN_LOOP ); sprintf ( buffer , \"counter = %03d \\r\\n \" , counter ); // measure UART TX blocking mode SEGGER_SYSVIEW_MarkStart ( APP_MARKER_UART_TX_BLOCKING ); HAL_UART_Transmit ( & huart1 , ( uint8_t * ) buffer , strlen ( buffer ), HAL_MAX_DELAY ); SEGGER_SYSVIEW_MarkStop ( APP_MARKER_UART_TX_BLOCKING ); // measure UART TX interrupt mode SEGGER_SYSVIEW_MarkStart ( APP_MARKER_UART_TX_INTERRUPT ); HAL_UART_Transmit_IT ( & huart1 , ( uint8_t * ) buffer , strlen ( buffer )); // print SEGGER_SYSVIEW_Print ( buffer ); // delay HAL_Delay ( 100 ); SEGGER_SYSVIEW_RecordEndCall ( APP_EVTID_MAIN_LOOP ); } } The result of measuring two performance points is as below: The performance makers show the execution time Look at the above image, firstly, it tells that both 2 methods need the same time to complete transmitting the same message. However, note that, in the Blocking mode, CPU is busy of wasting, while in the Interrupt mode, CPU can do something else when there is no interrupt. The total execution time of all interrupts is about \u2153 of the time needed by the blocking mode. 4. Lab 2: Analyze FreeRTOS \u2693\ufe0e Using an RTOS makes system analysis more complicated. However, System View is designed to work with RTOS after some simple steps. 4.1. Start a new project \u2693\ufe0e Let\u2019s create a new project using FreeRTOS V10 and CMSIS V2. Here in this lab, a Black Pill board with STM32 F411 . Enable RTOS RTOS should use SysTick for its own OS delay function, while HAL function also needs a time-base to operate its own polling delay method. Read more in RTOS SysTick . Set Time-base for HAL function 4.2. Import System View files \u2693\ufe0e The core files of Segger System View is the same as they are used in the Non-OS firmware. The difference is the config files for RTOS, which are found in the target FreeRTOS version or any other RTOS such as embOS. FreeRTOSV10 \u2502 \u2502 SEGGER_SYSVIEW_FreeRTOS.c \u2502 SEGGER_SYSVIEW_FreeRTOS.h \u2502 \u251c\u2500\u2500\u2500Config \u2502 \u2514\u2500\u2500\u2500Cortex-M \u2502 SEGGER_SYSVIEW_Config_FreeRTOS.c \u2502 \u2514\u2500\u2500\u2500Patch FreeRTOSV10_Amazon_Core.patch FreeRTOSV10_Core.patch Here are the steps: Copy all of those files to the project. Apply patch to the FreeRTOS source. The patch file may not be applied for newer FreeRTOS version, such as V10.3+. It easy to modify the patch to apply into a newer version. Or download a working patch for V10.3.1 here . Include SEGGER_SYSVIEW_FreeRTOS.h at the end of the file FreeRTOSConfig.h to override some RTOS definitions of tracing functions. Finally, configure System View in the file SEGGER_SYSVIEW_Config_FreeRTOS.c which sends System Information, Interrupt ID & Name, Timers and Markers. 5. Appendix \u2693\ufe0e How to get Interrupt ID? /********************************************************************* * * Define: SEGGER_SYSVIEW_GET_INTERRUPT_ID() * * Description * Function macro to retrieve the Id of the currently active * interrupt. * Default * Call user-supplied function SEGGER_SYSVIEW_X_GetInterruptId(). * Notes * For some known compilers and cores, a ready-to-use, core-specific * default is set. * ARMv7M: Read ICSR[8:0] (active vector) * ARMv6M: Read ICSR[5:0] (active vector) */ #ifndef SEGGER_SYSVIEW_GET_INTERRUPT_ID #if SEGGER_SYSVIEW_CORE == SEGGER_SYSVIEW_CORE_CM3 // Get the currently active interrupt Id. // (i.e. read Cortex-M ICSR[8:0] = active vector) #define SEGGER_SYSVIEW_GET_INTERRUPT_ID() ((*(U32*)(0xE000ED04)) & 0x1FF) #elif SEGGER_SYSVIEW_CORE == SEGGER_SYSVIEW_CORE_CM0 #if defined(__ICCARM__) #if (__VER__ > 6010000) // Workaround for IAR, which might do a byte-access to 0xE000ED04. // Read IPSR instead. #define SEGGER_SYSVIEW_GET_INTERRUPT_ID() (__get_IPSR()) #else // Older versions of IAR do not include __get_IPSR, // but might also not optimize to byte-access. #define SEGGER_SYSVIEW_GET_INTERRUPT_ID() ((*(U32*)(0xE000ED04)) & 0x3F) #endif #else // Get the currently active interrupt Id. // (i.e. read Cortex-M ICSR[5:0] = active vector) #define SEGGER_SYSVIEW_GET_INTERRUPT_ID() ((*(U32*)(0xE000ED04)) & 0x3F) #endif #else // Get the currently active interrupt Id from the user-provided function. #define SEGGER_SYSVIEW_GET_INTERRUPT_ID() SEGGER_SYSVIEW_X_GetInterruptId() #endif #endif /********************************************************************* * * SEGGER_SYSVIEW_X_GetInterruptId() * * Function description * Return the currently active interrupt Id, * which ist the active vector taken from IPSR[5:0]. * * Return value * The current currently active interrupt Id. * * Additional information * This function is not used by default, as the active vector can be * read from ICSR instead on Cortex-M0. * For Cortex-M0+ devices, change SEGGER_SYSVIEW_GET_INTERRUPT_ID * in SEGGER_SYSVIEW_Conf.h to call this function instead. */ U32 SEGGER_SYSVIEW_X_GetInterruptId ( void ) { U32 Id ; __asm volatile ( \"mrs %0, ipsr\" : \"=r\" ( Id ) ); Id &= 0x3F ; return Id ; } How to get Timestamp? /********************************************************************* * * Define: SEGGER_SYSVIEW_GET_TIMESTAMP() * * Description * Function macro to retrieve a system timestamp for SYSVIEW events. * Default * Call user-supplied function SEGGER_SYSVIEW_X_GetTimestamp(). * Notes * For some known compilers and cores, a ready-to-use, core-specific * default is set. * ARMv7M: Read Cortex-M Cycle Count register. * * The system timestamp clock frequency has to be passed in * SEGGER_SYSVIEW_Init(). */ #ifndef SEGGER_SYSVIEW_GET_TIMESTAMP #if defined (SEGGER_SYSVIEW_CORE) && (SEGGER_SYSVIEW_CORE == SEGGER_SYSVIEW_CORE_CM3) // Retrieve a system timestamp. Cortex-M cycle counter. #define SEGGER_SYSVIEW_GET_TIMESTAMP() (*(U32 *)(0xE0001004)) #else // Retrieve a system timestamp via user-defined function #define SEGGER_SYSVIEW_GET_TIMESTAMP() SEGGER_SYSVIEW_X_GetTimestamp() #endif #endif /********************************************************************* * * SEGGER_SYSVIEW_X_GetTimestamp() * * Function description * Returns the current timestamp in ticks using the system tick * count and the SysTick counter. * All parameters of the SysTick have to be known and are set via * configuration defines on top of the file. * * Return value * The current timestamp. * * Additional information * SEGGER_SYSVIEW_X_GetTimestamp is always called when interrupts are * disabled. Therefore locking here is not required. */ U32 SEGGER_SYSVIEW_X_GetTimestamp ( void ) { #if USE_CYCCNT_TIMESTAMP U32 TickCount ; U32 Cycles ; U32 CyclesPerTick ; // // Get the cycles of the current system tick. // SysTick is down-counting, subtract the current value // from the number of cycles per tick. // CyclesPerTick = SYST_RVR + 1 ; Cycles = ( CyclesPerTick - SYST_CVR ); // // Get the system tick count. // TickCount = SEGGER_SYSVIEW_TickCnt ; // // If a SysTick interrupt is pending, re-read timer and adjust result // if (( SCB_ICSR & SCB_ICSR_PENDSTSET_MASK ) != 0 ) { Cycles = ( CyclesPerTick - SYST_CVR ); TickCount ++ ; } Cycles += TickCount * CyclesPerTick ; return Cycles ; #endif } Do you see how cycles is calculated? Cycles += TickCount * CyclesPerTick ; Have you thought it is not optimized? Use breakpoints before and after that line, and compare the value of the SysTick Current Value Register to see how many cycles are used. #define SYST_CVR (*(volatile U32*) (0xE000E018uL)) It\u2019s just about 12 cycles. If you want to save 12 cycles in slow MCUs, here is an optimized version: U32 CyclesPerTick = 0 ; U32 TotalCycles = 0 void SEGGER_SYSVIEW_Conf ( void ) { ... CyclesPerTick = SYST_RVR + 1 ; } U32 SEGGER_SYSVIEW_X_GetTimestamp ( void ) { #if USE_CYCCNT_TIMESTAMP U32 Cycles ; // // Get the cycles of the current system tick. // SysTick is down-counting, subtract the current value from the number of cycles per tick. // Cycles = ( CyclesPerTick - SYST_CVR ); // // If a SysTick interrupt is pending, re-read timer and adjust result // if (( SCB_ICSR & SCB_ICSR_PENDSTSET_MASK ) != 0 ) { Cycles = ( CyclesPerTick - SYST_CVR ); // calculate the total cycles in advance, // but the actual total cycles will be updated when SysTick is handled return TotalCycles + CyclesPerTick + Cycles ; } return TotalCycles + Cycles ; #endif } void SysTick_Handler ( void ) { TotalCycles += CyclesPerTick ; HAL_IncTick (); }","title":"J-Link SysView"},{"location":"blog/stm32/j-link-sysview/#1-system-view","text":"Visit the Official J-Link System View page on SEGGER website for more information. J-Link System View \u2014 Manual SEGGER\u2019s J-Link System View is written on top of the excellent J-Link Real-Time Transfer to record many types of events in real-time in an embedded system. Those events can be interrupts, timers, task switches and scheduling with an RTOS, API function calls and returns, or user events and messages. The events are retrieved from the target, analyzed and visualized in the System View Application , while the target keeps running.","title":"1. System View"},{"location":"blog/stm32/j-link-sysview/#11-how-system-view-works","text":"To keep the communication overhead on the target system low, it only needs to record basic information, such as \u201cFunction with ID X has been called with parameter values y and z at the n ticks after the last event\u201d. System View analyzes all information from the events and shows: The recording time or system time when the call happened The task/context in which the call happened The interrupt name, timer ID, and marker name The API function name and its parameters and values The duration of the any pair of start-stop, enter-exit events The timestamps for events can be as accurate as 1 CPU cycle. A regular event is just 4 to 8 bytes long.","title":"1.1. How System View Works"},{"location":"blog/stm32/j-link-sysview/#12-figure-out-potential-problems","text":"Issues and inefficiencies in the system can be identified below ways: Incorrect task priorities or priority inversion leading to starvation Incorrect inter-task communication Inefficient delays and timeouts Spurious or unnecessary interrupts Unexpected log run-time of a short task High CPU Load can lead to: Bottlenecks which may lead to delayed execution of important tasks Dropped data or overflow of incoming buffer","title":"1.2. Figure out Potential problems"},{"location":"blog/stm32/j-link-sysview/#13-system-view-license","text":"System View may be used with a non-commercial license for evaluation, educational and hobbyist purposes. When using System View under the non-commercial license, no activation is required. On start of the System View Application, a popup is presented, the click Continue to accept the license terms. No Commercial-Use License","title":"1.3. System View License"},{"location":"blog/stm32/j-link-sysview/#14-system-view-apis","text":"The SEGGER System View implementation is written in ANSI C on the top of RTT, therefore, it can be easily integrated into any embedded application. The System View needs to be initialized before it can be used. However, it does not automatically run to reduce CPU Load and power usage. System View only runs when it gets request from Host\u2019s System View Application. Control functions Function Description SEGGER_SYSVIEW_Init() Initializes the SYSVIEW module SEGGER_SYSVIEW_Start() Start recording System View events. This function is triggered by the System View Application on connect. SEGGER_SYSVIEW_Stop() Stop recording System View events. This function is triggered by the System View Application on disconnect. Configuration functions Function Description SEGGER_SYSVIEW_Conf() Initialize and configures System View SEGGER_SYSVIEW_SetRAMBase() Sets the RAM base address SEGGER_SYSVIEW_SendSysDesc() Send the system description string to the host SEGGER_SYSVIEW_SendTaskList() Send all tasks descriptors to the host SEGGER_SYSVIEW_SendTaskInfo() Send a Task Info Packet, containing TaskId for identification, task priority and task name SEGGER_SYSVIEW_X_GetTimestamp() Callback called by System View to get the timestamp in cycles Event recording functions Function Description SEGGER_SYSVIEW_RecordEnterISR() Format and send an ISR entry event SEGGER_SYSVIEW_RecordExitISR() Format and send an ISR exit event SEGGER_SYSVIEW_RecordEnterTimer() Format and send a Timer entry event SEGGER_SYSVIEW_RecordExitTimer() Format and send a Timer exit event SEGGER_SYSVIEW_OnIdle() Record an Idle event SEGGER_SYSVIEW_OnTaskCreate() Record a Task Create event SEGGER_SYSVIEW_OnTaskStartExec() Record a Task Start Execution event SEGGER_SYSVIEW_OnTaskStartReady() Record a Task Start Ready event SEGGER_SYSVIEW_OnTaskStopExec() Record a Task Stop Execution event SEGGER_SYSVIEW_OnTaskStopReady() Record a Task Stop Ready event SEGGER_SYSVIEW_OnTaskTerminate() Record a Task termination event SEGGER_SYSVIEW_MarkStart() Record a Performance Marker Start event to start measuring runtime SEGGER_SYSVIEW_Mark() Record a Performance Marker intermediate event SEGGER_SYSVIEW_MarkStop() Record a Performance Marker Stop event to stop measuring runtime User API recording functions Function Description SEGGER_SYSVIEW_RecordVoid() Formats and sends a System View packet with an empty payload SEGGER_SYSVIEW_RecordU32() Formats and sends a System View packet containing a single U32 parameter payload SEGGER_SYSVIEW_RecordU32x[2:10]() Formats and sends a System View packet containing [2:10] U32 parameter payload SEGGER_SYSVIEW_RecordString() Formats and sends a System View packet containing a string SEGGER_SYSVIEW_RecordEndCall() Format and send an End API Call event without return value. SEGGER_SYSVIEW_RecordEndCallU32() Format and send an End API Call event with a return value Message recording functions Function Description SEGGER_SYSVIEW_Print() Print a string to the host SEGGER_SYSVIEW_Warn() Print a warning string to the host SEGGER_SYSVIEW_Error() Print an error string to the host SEGGER_SYSVIEW_PrintfHost() Print a string which is formatted on the host by the System View Application SEGGER_SYSVIEW_WarnfHost() Print a string which is formatted on the host by the System View Application SEGGER_SYSVIEW_ErrorfHost() Print an error string which is formatted on the host by the System View Application To reduce CPU cycles used by System View to format strings, System View function *fHost() just sends a raw string and its params to the host!","title":"1.4. System View APIs"},{"location":"blog/stm32/j-link-sysview/#2-system-view-integration","text":"Install the System View Application firstly at System View download page . After installation, go the application folder to get the latest source code of System View target integration, for example C:\\Program Files\\SEGGER\\System View\\Src . Here is SEGGER_SysView_V330.zip . \u251c\u2500Config \u2502 Global.h # Typedef for data types \u2502 SEGGER_RTT_Conf.h # Default RTT configs \u2502 SEGGER_SYSVIEW_Conf.h # User SysView Configs | \u251c\u2500\u2500SEGGER \u2502 \u2502 SEGGER.h # Segger common defines \u2502 \u2502 SEGGER_RTT.h # RTT Header \u2502 \u2502 SEGGER_RTT.c # RTT implementation \u2502 \u2502 SEGGER_RTT_ASM_ARMv7M.S # for Cortex-M3/M4 \u2502 \u2502 SEGGER_RTT_printf.c # Print functions \u2502 \u2502 SEGGER_SYSVIEW_ConfDefaults.h # SysView Default Configs \u2502 \u2502 SEGGER_SYSVIEW_Int.h # SysView Internal defines \u2502 \u2502 SEGGER_SYSVIEW.h # SysView header \u2502 \u2502 SEGGER_SYSVIEW.c # SysView implementation \u2502 \u2502 \u2502 \u2514\u2500\u2500\u2500Syscalls # Standard IO redirection \u2502 \u2514\u2500Sample # Sample configs for diff. targets \u251c\u2500\u2500\u2500COMM # Example to record on UART \u251c\u2500\u2500\u2500embOS # Example configs \u251c\u2500\u2500\u2500FreeRTOSV10 # Example configs \u251c\u2500\u2500\u2500FreeRTOSV8 # Example configs \u251c\u2500\u2500\u2500FreeRTOSV9 # Example configs \u251c\u2500\u2500\u2500MicriumOSKernel # Example configs \u251c\u2500\u2500\u2500uCOS-II # Example configs \u251c\u2500\u2500\u2500uCOS-III # Example configs \u2514\u2500\u2500\u2500NoOS # Example configs \u2514\u2500\u2500\u2500Config \u251c\u2500\u2500\u2500RX \u251c\u2500\u2500\u2500Cortex-M \u2502 SEGGER_SYSVIEW_Config_NoOS.c \u2514\u2500\u2500\u2500Cortex-M0 SEGGER_SYSVIEW_Config_NoOS_CM0.c To integrate System View into a project,it\u2019s recommend to put header files into Inc folder, and all source file into Src folder, as they will need to add into Build\u2019s Path and Symbols.","title":"2. System View Integration"},{"location":"blog/stm32/j-link-sysview/#3-lab-1-analyze-a-non-os-firmware","text":"This lab will guide on how to add System View into an application and record its activity to analyze them. As System View is based on RTT which runs through SWD interface, the guide to integrate on Cortex-M MCUs is the same in general. There are some steps needed for specific CPU lines, as can be seen in the Sample files of SEGGER. Target application Blink an LED at 100 Hz using a general Timer Increase a counter value by one when press on a Button using External Interrupt Send the above counter value on an UART port every 100 ms in the main loop","title":"3. Lab 1: Analyze a Non-OS firmware"},{"location":"blog/stm32/j-link-sysview/#31-start-a-new-project","text":"This guide is written based on projects with STM32F051R8 (Cortex-M0) as it needs more configs than other Cortex-M MCUs. Here are settings applied to a new project before starting to add System View: Check if you need to enable HSE or LSE when using external crystals Setup debug mode for using SWD on PA13 (SWDIO) and PA14 (SWCLK) Setup Clock path, PLL, and the system frequency Enable UART1 , set baud rate at 115200 bps, mode 8-N-1, and enable its interrupt Enable the general purpose timer, e.g. TIM3 , and set to use internal system clock, interrupt at 100 Hz Config a button input of PA0 with External Interrupt mode Config a LED output on any available GPIO pin, e.g. PC8 or PC13 Here is the base code of the in the main.c file for this application\u2019s requirement: main.c #include <stdio.h> #include <string.h> TIM_HandleTypeDef htim3 ; UART_HandleTypeDef huart1 ; unsigned char counter = 0 ; char buffer [ 16 ] = { 0 }; // counter=xxx\\r\\n void SystemClock_Config ( void ){...} static void MX_GPIO_Init ( void ){...} static void MX_USART1_UART_Init ( void ){...} static void MX_TIM3_Init ( void ){...} void HAL_TIM_PeriodElapsedCallback ( TIM_HandleTypeDef * htim ) { if ( htim == & htim3 ) { HAL_GPIO_TogglePin ( LED_GPIO_Port , LED_Pin ); } } void HAL_GPIO_EXTI_Callback ( uint16_t GPIO_Pin ) { if ( GPIO_Pin == GPIO_PIN_0 ) { counter ++ ; } } void HAL_UART_TxCpltCallback ( UART_HandleTypeDef * huart ) { if ( huart == & huart1 ) { } } int main ( void ) { HAL_Init (); SystemClock_Config (); MX_GPIO_Init (); MX_USART1_UART_Init (); MX_TIM3_Init (); HAL_TIM_Base_Start_IT ( & htim3 ); while ( 1 ) { sprintf ( buffer , \"counter = %03d \\r\\n \" , counter ); HAL_UART_Transmit ( & huart1 , ( uint8_t * ) buffer , strlen ( buffer ), HAL_MAX_DELAY ); HAL_Delay ( 100 ); } } When start up, this application prints out counter = 000 every 100 ms. If press on the Button, the counter value is increased, not always by 1, but sometimes by 3, 4, or more, due to un-debounced input.","title":"3.1. Start a new project"},{"location":"blog/stm32/j-link-sysview/#32-import-system-view-files","text":"The base files of SEGGER System View can be added in a separated folder Segger , and custom config files can can be added into the project main folder. See the below folder structure: Sample files SEGGER provides Sample files for different types of OS and CPU. Make sure to include correct header and source files for the target project. Read the System View Manual for more details of each type of OS and CPU support. This project is for STM32F051R8 MCU which is based on Cortex-M0 CPU, therefore, the file SEGGER_SYSVIEW_Config_NoOS_CM0.c will be included. Add Include Paths Open the Project Properties and select C/C++ Build \u00bb Settings . Then add ../Segger/Inc into to include paths of both GCC Assembler and GCC Compiler Add Include path Add source files To make System View source files get compiled, add the folder /Segger into the Source Location list in the Paths and Symbols setting under the C/C++ General property. Add source files","title":"3.2. Import System View files"},{"location":"blog/stm32/j-link-sysview/#33-configure-system-view","text":"Before System View can be used, it needs to be initialized, including: Setup RTT base Set RAM Base address Send Device Information Send Interrupts description Set Timestamp source In the main.c , include the SEGGER System View header files, then in the main() function, call to SEGGER_SYSVIEW_Conf() function to initialize the System View stuff: main.c #include \"SEGGER_SYSVIEW_Conf.h\" #include \"SEGGER_SYSVIEW.h\" int main () { SEGGER_SYSVIEW_Conf (); // initialize System View while ( 1 ) {...} } Normally, SEGGER_SYSVIEW_Conf() will initialize the System View with System Clock Frequency (saved in SystemCoreClock variable) for timestamp resolution, and provide a _cbSendSystemDesc() callback function which will be executed when the host application requests to start monitoring. The device information have to be sent to host application, with custom data, therefore it is implemented in the SEGGER_SYSVIEW_Config_NoOS_CM0.c . The next step is to set the RAM Base address. Every variable\u2019s address will be subtracted to this base address to get an offset value which is later encoded in only 1 or 2 bytes. The RAM Base address for ARM all Cortex-M MCUs is 0x20000000 : SEGGER_SYSVIEW_Config_NoOS_CM0.c #define SYSVIEW_RAM_BASE (0x20000000) Here is the SEGGER_SYSVIEW_Conf() function: void SEGGER_SYSVIEW_Conf ( void ) { SEGGER_SYSVIEW_Init ( SYSVIEW_TIMESTAMP_FREQ , SYSVIEW_CPU_FREQ , 0 , _cbSendSystemDesc ); SEGGER_SYSVIEW_SetRAMBase ( SYSVIEW_RAM_BASE ); } Next step is to implement the callback function _cbSendSystemDesc() which sends the Device information, including the App Name, the Device Name, the Core Name, the OS Name, and the interrupts used in the application: SEGGER_SYSVIEW_Config_NoOS_CM0.c #define SYSVIEW_APP_NAME \"System View Demo\" #define SYSVIEW_DEVICE_NAME \"STM32F051R8\" #define SYSVIEW_CORE_NAME \"Cortex-M0\" #define SYSVIEW_OS_NAME \"Non-OS_Cortex-M0\" static void _cbSendSystemDesc ( void ) { SEGGER_SYSVIEW_SendSysDesc ( \"N=\" SYSVIEW_APP_NAME \",\" \"D=\" SYSVIEW_DEVICE_NAME \",\" \"C=\" SYSVIEW_CORE_NAME \",\" \"O=\" SYSVIEW_OS_NAME ); SEGGER_SYSVIEW_SendSysDesc ( \"I#15=SysTick\" ); SEGGER_SYSVIEW_SendSysDesc ( \"I#21=EXTI0_1_IRQHandler\" ); SEGGER_SYSVIEW_SendSysDesc ( \"I#32=TIM3_IRQHandler\" ); SEGGER_SYSVIEW_SendSysDesc ( \"I#43=USART1_IRQHandler\" ); } The OS Name also is used by System View Application to load useful descriptions for displaying analysed data. Read more in APIs Descriptions . The Interrupt number can be found in the g_pfnVectors table in the startup_stm32f051r8tx.s . Different cores have different interrupt mapping, even some interrupts remain the same number, e.g. the interrupt SysTick_Handler always is mapped to the number #15. Application should only send in-use interrupts to the host. The main loop, and each interrupt is considered as a different context. g_pfnVectors : . word _estack . word Reset_Handler /* 1 */ . word NMI_Handler /* 2 */ . word HardFault_Handler /* 3 */ . word 0 /* 4 */ . word 0 /* 5 */ . word 0 /* 6 */ . word 0 /* 7 */ . word 0 /* 8 */ . word 0 /* 9 */ . word 0 /* 10 */ . word SVC_Handler /* 11 */ . word 0 /* 12 */ . word 0 /* 13 */ . word PendSV_Handler /* 14 */ . word SysTick_Handler /* 15 */ . word WWDG_IRQHandler /* 16 */ . word PVD_IRQHandler /* 17 */ . word RTC_IRQHandler /* 18 */ . word FLASH_IRQHandler /* 19 */ . word RCC_CRS_IRQHandler /* 20 */ . word EXTI0_1_IRQHandler /* 21 */ . word EXTI2_3_IRQHandler /* 22 */ . word EXTI4_15_IRQHandler /* 23 */ . word TSC_IRQHandler /* 24 */ . word DMA1_Channel1_IRQHandler /* 25 */ . word DMA1_Channel2_3_IRQHandler /* 26 */ . word DMA1_Channel4_5_IRQHandler /* 27 */ . word ADC1_COMP_IRQHandler /* 28 */ . word TIM1_BRK_UP_TRG_COM_IRQHandler /* 29 */ . word TIM1_CC_IRQHandler /* 30 */ . word TIM2_IRQHandler /* 31 */ . word TIM3_IRQHandler /* 32 */ . word TIM6_DAC_IRQHandler /* 33 */ . word 0 /* 34 */ . word TIM14_IRQHandler /* 35 */ . word TIM15_IRQHandler /* 36 */ . word TIM16_IRQHandler /* 37 */ . word TIM17_IRQHandler /* 38 */ . word I2C1_IRQHandler /* 39 */ . word I2C2_IRQHandler /* 40 */ . word SPI1_IRQHandler /* 41 */ . word SPI2_IRQHandler /* 42 */ . word USART1_IRQHandler /* 43 */ . word USART2_IRQHandler /* 44 */ . word 0 /* 45 */ . word CEC_CAN_IRQHandler /* 46 */ . word 0 /* 47 */ The final step is to help System View find the system timestamp which is used in all events for processing the timeline of recorded events. For Cortex-M0, it is needed to increase the variable SEGGER_SYSVIEW_TickCnt in the SysTick interrupt, as soon as that handler is executed. This variable is used in the function SEGGER_SYSVIEW_X_GetTimestamp() to correctly calculate the clock cycles. stm32f0xx_it #include \"SEGGER_SYSVIEW.h\" void SysTick_Handler ( void ) { SEGGER_SYSVIEW_TickCnt ++ ; HAL_IncTick (); } Cycle counter Except on Cortex-M0 MCUs do not have Cycle Counter, therefore, it needs to be calculated manually based on the SysTick interrupt and the SysTick reload register. Other Cortex-M CPU has CPU Cycle Counter register to be used as system timestamp. Both of two methods provide 1-cycle resolution.","title":"3.3. Configure System View"},{"location":"blog/stm32/j-link-sysview/#34-print-messages-to-host","text":"To log the counter value to both the UART1 interface and the System View application, add the function all SEGGER_SYSVIEW_Print() which sends a string to the host: main.c while ( 1 ) { sprintf ( buffer , \"counter = %03d \\r\\n \" , counter ); HAL_UART_Transmit ( & huart1 , ( uint8_t * ) buffer , strlen ( buffer ), HAL_MAX_DELAY ); SEGGER_SYSVIEW_Print ( buffer ); HAL_Delay ( 100 ); }","title":"3.4. Print messages to host"},{"location":"blog/stm32/j-link-sysview/#35-run-the-system-view","text":"Connect any J-Link probe into the SWD interface of the target MCU. Then start the System View application on the host PC. J-Link Pro Cloned J-Link OB J-Link JTAG connection J-Link SWD connection Convert ST-LINK to J-LINK SEGGER offers a firmware upgrading the ST-LINK on-board on the Nucleo and Discovery Boards to a J-LINK On-Board debugger. Start the System View for the first time, it will show a recorded example. Go to Tools \u00bb Preferences and uncheck the checkbox Load last data on start . When starting to record a new session, it is recommended to check and set the target device. Press Alt + Return to show the device selection: Device selection Press F5 or click on the start button to start recording. At the beginning step in this lab, the System View will display: Device information which are set above The message of counter value every 100 ms System View with device info and some messages","title":"3.5. Run the System View"},{"location":"blog/stm32/j-link-sysview/#36-record-interrupts","text":"In the file stm32f0xx_it.c , in each concerning interrupt handler, add a pair of ISR recording function SEGGER_SYSVIEW_RecordEnterISR() and SEGGER_SYSVIEW_RecordExitISR() to track the interrupts. It automatically retrieves the interrupt ID via a special register implemented in the SEGGER_SYSVIEW_GET_INTERRUPT_ID() function macro: main.c void SysTick_Handler ( void ) { SEGGER_SYSVIEW_TickCnt ++ ; // must be at the beginning SEGGER_SYSVIEW_RecordEnterISR (); HAL_IncTick (); SEGGER_SYSVIEW_RecordExitISR (); } void EXTI0_1_IRQHandler ( void ) { SEGGER_SYSVIEW_RecordEnterISR (); HAL_GPIO_EXTI_IRQHandler ( GPIO_PIN_0 ); SEGGER_SYSVIEW_RecordExitISR (); } void TIM3_IRQHandler ( void ) { SEGGER_SYSVIEW_RecordEnterISR (); HAL_TIM_IRQHandler ( & htim3 ); SEGGER_SYSVIEW_RecordExitISR (); } void USART1_IRQHandler ( void ) { SEGGER_SYSVIEW_RecordEnterISR (); HAL_UART_IRQHandler ( & huart1 ); SEGGER_SYSVIEW_RecordExitISR (); } This time, when recording with System View, there are many events captured. Below is a screenshot of the moment I pressed on the BUTTON once, which does not have a debouncing filter, there were a lot of ISRs triggered. That explains why the counter variable were increased multiple times. System View with Interrupt context","title":"3.6. Record interrupts"},{"location":"blog/stm32/j-link-sysview/#37-record-a-function","text":"It\u2019s known that the HAL IRQs take care a lot of user cases, which indeed causes wasting time, before it calls to a user\u2019s callback function. The System View records to enter and the exit event of an interrupt, but it does not automatically record a user function. To do that, application must manually set the starting point of the function\u2019s entry with one of: SEGGER_SYSVIEW_RecordVoid() , or SEGGER_SYSVIEW_RecordU32() , or SEGGER_SYSVIEW_RecordString() and the ending point of that function with one of: SEGGER_SYSVIEW_RecordEndCall() , or SEGGER_SYSVIEW_RecordEndCallU32() function. These functions need an ID to distinguish the different APIs. ID is 2 bytes, comparing to an API function name which usually is much more than 2 bytes, it is very short to save sending bandwidth. For example, to measure the main loop, and user callback functions, define some IDs starting from 32 as below: SEGGER_SYSVIEW_Conf.h #define APP_EVTID_MAIN_LOOP 32 #define APP_EVTID_HAL_TIM_PeriodElapsedCallback 33 #define APP_EVTID_HAL_GPIO_EXTI_Callback 34 #define APP_EVTID_HAL_UART_TxCpltCallback 35 main.c void HAL_TIM_PeriodElapsedCallback ( TIM_HandleTypeDef * htim ) { SEGGER_SYSVIEW_RecordVoid ( APP_EVTID_HAL_TIM_PeriodElapsedCallback ); if ( htim == & htim3 ) { HAL_GPIO_TogglePin ( LED_GPIO_Port , LED_Pin ); } SEGGER_SYSVIEW_RecordEndCall ( APP_EVTID_HAL_TIM_PeriodElapsedCallback ); } void HAL_GPIO_EXTI_Callback ( uint16_t GPIO_Pin ) { SEGGER_SYSVIEW_RecordVoid ( APP_EVTID_HAL_GPIO_EXTI_Callback ); if ( GPIO_Pin == GPIO_PIN_0 ) { counter ++ ; } SEGGER_SYSVIEW_RecordEndCall ( APP_EVTID_HAL_GPIO_EXTI_Callback ); } void HAL_UART_TxCpltCallback ( UART_HandleTypeDef * huart ) { SEGGER_SYSVIEW_RecordVoid ( APP_EVTID_HAL_UART_TxCpltCallback ); if ( huart == & huart1 ) { } SEGGER_SYSVIEW_RecordEndCall ( APP_EVTID_HAL_UART_TxCpltCallback ); } int main ( void ) { while ( 1 ) { SEGGER_SYSVIEW_RecordVoid ( APP_EVTID_MAIN_LOOP ); sprintf ( buffer , \"counter = %03d \\r\\n \" , counter ); HAL_UART_Transmit ( & huart1 , ( uint8_t * ) buffer , strlen ( buffer ), HAL_MAX_DELAY ); SEGGER_SYSVIEW_Print ( buffer ); HAL_Delay ( 100 ); SEGGER_SYSVIEW_RecordEndCall ( APP_EVTID_MAIN_LOOP ); } } System View reserved IDs The first 32 IDs from 0 to 31 are reserved by System View for its defined events: SEGGER_SYSVIEW.h #define SYSVIEW_EVTID_NOP 0 // Dummy packet. #define SYSVIEW_EVTID_OVERFLOW 1 #define SYSVIEW_EVTID_ISR_ENTER 2 #define SYSVIEW_EVTID_ISR_EXIT 3 #define SYSVIEW_EVTID_TASK_START_EXEC 4 #define SYSVIEW_EVTID_TASK_STOP_EXEC 5 #define SYSVIEW_EVTID_TASK_START_READY 6 #define SYSVIEW_EVTID_TASK_STOP_READY 7 #define SYSVIEW_EVTID_TASK_CREATE 8 #define SYSVIEW_EVTID_TASK_INFO 9 #define SYSVIEW_EVTID_TRACE_START 10 #define SYSVIEW_EVTID_TRACE_STOP 11 #define SYSVIEW_EVTID_SYSTIME_CYCLES 12 #define SYSVIEW_EVTID_SYSTIME_US 13 #define SYSVIEW_EVTID_SYSDESC 14 #define SYSVIEW_EVTID_MARK_START 15 #define SYSVIEW_EVTID_MARK_STOP 16 #define SYSVIEW_EVTID_IDLE 17 #define SYSVIEW_EVTID_ISR_TO_SCHEDULER 18 #define SYSVIEW_EVTID_TIMER_ENTER 19 #define SYSVIEW_EVTID_TIMER_EXIT 20 #define SYSVIEW_EVTID_STACK_INFO 21 #define SYSVIEW_EVTID_MODULEDESC 22 #define SYSVIEW_EVTID_INIT 24 #define SYSVIEW_EVTID_NAME_RESOURCE 25 #define SYSVIEW_EVTID_PRINT_FORMATTED 26 #define SYSVIEW_EVTID_NUMMODULES 27 #define SYSVIEW_EVTID_END_CALL 28 #define SYSVIEW_EVTID_TASK_TERMINATE 29 #define SYSVIEW_EVTID_EX 31 User can define custom IDs starting from 32 in the SEGGER_SYSVIEW_Conf.h header. Lets what appear on the System View events: There are recorded events for starting and ending of an API. However, there is just event ID, not a human-friendly readable API name. In the below image, the TIM3 IRQ handler took 43 us to run, in which the user callback function took 14 us. System View with custom API event ID","title":"3.7. Record a function"},{"location":"blog/stm32/j-link-sysview/#38-os-description-file","text":"In order for System View to properly decode API calls it requires a description file to be present in the /description/ directory of System View. The name of the file has to be SYSVIEW_<OSName>.txt where <OSName> is the name as sent in the system description. This lab use Non-OS_Cortex-M0 as the OS Name, therefore, it should be a SYSVIEW_Non-OS_Cortex-M0.txt file in the description folder of System View. Warning of the OS description file A description file includes all API functions which can be recorded by the OS. Each line in the file is one function in the following format: <ID> <Name> <Parameters> | <ReturnValue> <Id> is the Id which is recorded for the API function. It can be in the range of 32 to 511. <Name> is the name of the API function, displayed in the Event column of System View. It may not contain spaces. <Parameters> and <ReturnValue> are the description string of the parameters which are recorded with the API functions. The ReturnValueDescription is optional. The parameter display can be configured by a set of modifiers: %b - Display parameter as binary. %B - Display parameter as hexadecimal string (e.g. 00 AA FF \u2026). %d - Display parameter as signed decimal integer. %D - Display parameter as time value. %I - Display parameter as a resource name if the resource id is known to System View. %p - Display parameter as 4 byte hexadecimal integer (e.g. 0xAABBCCDD). %s - Display parameter as string. %t - Display parameter as a task name if the task id is known to System View. %u - Display parameter as unsigned decimal integer. %x - Display parameter as hexadecimal integer. The following example shows a part of SYSVIEW_embOS.txt : 46 OS_CreateTask Task=%t Pri=%u Stack=%p Size=%u In addition to the default modifiers the description file can define NamedTypes to map numerical values to strings, which can for example be useful to display the textual value of enums or error codes. The special character * represents for all remaining unmapped values. NamedTypes have following format: NamedType <TypeName> <Key>=<Value> [<Key1>=<Value1> ...] NamedTypes can be used in the <Parameters> and the <ReturnValue> : # Types for parameter formatters NamedType OSErr 0=OS_ERR_NONE 10000=OS_ERR_A # API Functions 34 OSFunc Param=%OSFlag | Returns %OSErr When a task pauses execution its state is recorded in the System View event. This task state can be converted to a textual representation in System View with the TaskState description. TaskState has following format: TaskState <Mask> <Key>=<Value>, [<Key1>=<Value1>, ...] # Task States TaskState 0xFF 0=Ready, 1=Delayed or Timeout Always have an empty line in the OS description file to make the last line is parsed properly Here is an example of OS Description file used in this lab. There are 2 NamedType defined there, %UARTx and %TIMx which take the mapping address of a peripheral to look up its name using the Data-sheet document. SYSVIEW_Non-OS_Cortex-M0.txt # Types NamedType UARTx * = %p 0x40013800 = UART1 0x40004400 = UART2 NamedType TIMx * = %p 0x40012C00 = TIM1 0x40000400 = TIM3 NamedType PINx * = %u 0x0 = None 0x1 = PIN0 0x2 = PIN1 # API IDs 32 Main_Loop 33 HAL_TIM_PeriodElapsedCallback Instance = %TIMx 34 GPIO_EXTI_Callback GPIO_Pin = %Pinx 35 HAL_UART_TxCpltCallback Instance = %UARTx Then, the recording function should be changed to transfer API parameters: void HAL_TIM_PeriodElapsedCallback ( TIM_HandleTypeDef * htim ) { SEGGER_SYSVIEW_RecordU32 ( APP_EVTID_HAL_TIM_PeriodElapsedCallback , ( U32 ) htim -> Instance ); if ( htim == & htim3 ) { HAL_GPIO_TogglePin ( LED_GPIO_Port , LED_Pin ); } SEGGER_SYSVIEW_RecordEndCall ( APP_EVTID_HAL_TIM_PeriodElapsedCallback ); } The result is much better, with API name and some extra information: System View with API name and its extra info Then, use the API description file with string formatter in more complex example: void HAL_GPIO_EXTI_Callback ( uint16_t GPIO_Pin ) { SEGGER_SYSVIEW_RecordU32 ( APP_EVTID_HAL_GPIO_EXTI_Callback , GPIO_Pin ); if ( GPIO_Pin == GPIO_PIN_0 ) { counter ++ ; SEGGER_SYSVIEW_WarnfHost ( \"counter set to %d\" , counter ); } SEGGER_SYSVIEW_RecordEndCall ( APP_EVTID_HAL_GPIO_EXTI_Callback ); } System View with warning message","title":"3.8. OS Description file"},{"location":"blog/stm32/j-link-sysview/#39-measure-performance","text":"To measure performance, System View uses Markers to calculate the execution time between a starting point and a corresponding ending point. This lab will send the counter value in two method: blocking, and interrupt. The functions to measure performance is SEGGER_SYSVIEW_MarkStart() and SEGGER_SYSVIEW_MarkStop() , which need IDs to create pairs. Let\u2019s start with defining two marker IDs: SEGGER_SYSVIEW_Conf.h #define APP_MARKER_UART_TX_BLOCKING 0 #define APP_MARKER_UART_TX_INTERRUPT 1 Then send the marker names in the Device Information callback function: static void _cbSendSystemDesc ( void ) { SEGGER_SYSVIEW_SendSysDesc (...); SEGGER_SYSVIEW_NameMarker ( APP_MARKER_UART_TX_BLOCKING , \"UART_TX_Blocking\" ); SEGGER_SYSVIEW_NameMarker ( APP_MARKER_UART_TX_INTERRUPT , \"UART_TX_Interrupt\" ); } In the main while loop, firstly, send the counter value using the block method. Wrap the blocking method with a pair of markers. After the blocking method finish, start the Interrupt method. Note that, in main loop, only mark the starting time. An interrupt will be called when all bytes are transmitted in the HAL_UART_TxCpltCallback() function, therefore, add the ending marker there to calculate the second case. void HAL_UART_TxCpltCallback ( UART_HandleTypeDef * huart ) { SEGGER_SYSVIEW_RecordU32 ( APP_EVTID_HAL_UART_TxCpltCallback , ( U32 ) huart -> Instance ); if ( huart == & huart1 ) { SEGGER_SYSVIEW_MarkStop ( APP_MARKER_UART_TX_INTERRUPT ); } SEGGER_SYSVIEW_RecordEndCall ( APP_EVTID_HAL_UART_TxCpltCallback ); } int main () { ... while ( 1 ) { SEGGER_SYSVIEW_RecordVoid ( APP_EVTID_MAIN_LOOP ); sprintf ( buffer , \"counter = %03d \\r\\n \" , counter ); // measure UART TX blocking mode SEGGER_SYSVIEW_MarkStart ( APP_MARKER_UART_TX_BLOCKING ); HAL_UART_Transmit ( & huart1 , ( uint8_t * ) buffer , strlen ( buffer ), HAL_MAX_DELAY ); SEGGER_SYSVIEW_MarkStop ( APP_MARKER_UART_TX_BLOCKING ); // measure UART TX interrupt mode SEGGER_SYSVIEW_MarkStart ( APP_MARKER_UART_TX_INTERRUPT ); HAL_UART_Transmit_IT ( & huart1 , ( uint8_t * ) buffer , strlen ( buffer )); // print SEGGER_SYSVIEW_Print ( buffer ); // delay HAL_Delay ( 100 ); SEGGER_SYSVIEW_RecordEndCall ( APP_EVTID_MAIN_LOOP ); } } The result of measuring two performance points is as below: The performance makers show the execution time Look at the above image, firstly, it tells that both 2 methods need the same time to complete transmitting the same message. However, note that, in the Blocking mode, CPU is busy of wasting, while in the Interrupt mode, CPU can do something else when there is no interrupt. The total execution time of all interrupts is about \u2153 of the time needed by the blocking mode.","title":"3.9. Measure performance"},{"location":"blog/stm32/j-link-sysview/#4-lab-2-analyze-freertos","text":"Using an RTOS makes system analysis more complicated. However, System View is designed to work with RTOS after some simple steps.","title":"4. Lab 2: Analyze FreeRTOS"},{"location":"blog/stm32/j-link-sysview/#41-start-a-new-project","text":"Let\u2019s create a new project using FreeRTOS V10 and CMSIS V2. Here in this lab, a Black Pill board with STM32 F411 . Enable RTOS RTOS should use SysTick for its own OS delay function, while HAL function also needs a time-base to operate its own polling delay method. Read more in RTOS SysTick . Set Time-base for HAL function","title":"4.1. Start a new project"},{"location":"blog/stm32/j-link-sysview/#42-import-system-view-files","text":"The core files of Segger System View is the same as they are used in the Non-OS firmware. The difference is the config files for RTOS, which are found in the target FreeRTOS version or any other RTOS such as embOS. FreeRTOSV10 \u2502 \u2502 SEGGER_SYSVIEW_FreeRTOS.c \u2502 SEGGER_SYSVIEW_FreeRTOS.h \u2502 \u251c\u2500\u2500\u2500Config \u2502 \u2514\u2500\u2500\u2500Cortex-M \u2502 SEGGER_SYSVIEW_Config_FreeRTOS.c \u2502 \u2514\u2500\u2500\u2500Patch FreeRTOSV10_Amazon_Core.patch FreeRTOSV10_Core.patch Here are the steps: Copy all of those files to the project. Apply patch to the FreeRTOS source. The patch file may not be applied for newer FreeRTOS version, such as V10.3+. It easy to modify the patch to apply into a newer version. Or download a working patch for V10.3.1 here . Include SEGGER_SYSVIEW_FreeRTOS.h at the end of the file FreeRTOSConfig.h to override some RTOS definitions of tracing functions. Finally, configure System View in the file SEGGER_SYSVIEW_Config_FreeRTOS.c which sends System Information, Interrupt ID & Name, Timers and Markers.","title":"4.2. Import System View files"},{"location":"blog/stm32/j-link-sysview/#5-appendix","text":"How to get Interrupt ID? /********************************************************************* * * Define: SEGGER_SYSVIEW_GET_INTERRUPT_ID() * * Description * Function macro to retrieve the Id of the currently active * interrupt. * Default * Call user-supplied function SEGGER_SYSVIEW_X_GetInterruptId(). * Notes * For some known compilers and cores, a ready-to-use, core-specific * default is set. * ARMv7M: Read ICSR[8:0] (active vector) * ARMv6M: Read ICSR[5:0] (active vector) */ #ifndef SEGGER_SYSVIEW_GET_INTERRUPT_ID #if SEGGER_SYSVIEW_CORE == SEGGER_SYSVIEW_CORE_CM3 // Get the currently active interrupt Id. // (i.e. read Cortex-M ICSR[8:0] = active vector) #define SEGGER_SYSVIEW_GET_INTERRUPT_ID() ((*(U32*)(0xE000ED04)) & 0x1FF) #elif SEGGER_SYSVIEW_CORE == SEGGER_SYSVIEW_CORE_CM0 #if defined(__ICCARM__) #if (__VER__ > 6010000) // Workaround for IAR, which might do a byte-access to 0xE000ED04. // Read IPSR instead. #define SEGGER_SYSVIEW_GET_INTERRUPT_ID() (__get_IPSR()) #else // Older versions of IAR do not include __get_IPSR, // but might also not optimize to byte-access. #define SEGGER_SYSVIEW_GET_INTERRUPT_ID() ((*(U32*)(0xE000ED04)) & 0x3F) #endif #else // Get the currently active interrupt Id. // (i.e. read Cortex-M ICSR[5:0] = active vector) #define SEGGER_SYSVIEW_GET_INTERRUPT_ID() ((*(U32*)(0xE000ED04)) & 0x3F) #endif #else // Get the currently active interrupt Id from the user-provided function. #define SEGGER_SYSVIEW_GET_INTERRUPT_ID() SEGGER_SYSVIEW_X_GetInterruptId() #endif #endif /********************************************************************* * * SEGGER_SYSVIEW_X_GetInterruptId() * * Function description * Return the currently active interrupt Id, * which ist the active vector taken from IPSR[5:0]. * * Return value * The current currently active interrupt Id. * * Additional information * This function is not used by default, as the active vector can be * read from ICSR instead on Cortex-M0. * For Cortex-M0+ devices, change SEGGER_SYSVIEW_GET_INTERRUPT_ID * in SEGGER_SYSVIEW_Conf.h to call this function instead. */ U32 SEGGER_SYSVIEW_X_GetInterruptId ( void ) { U32 Id ; __asm volatile ( \"mrs %0, ipsr\" : \"=r\" ( Id ) ); Id &= 0x3F ; return Id ; } How to get Timestamp? /********************************************************************* * * Define: SEGGER_SYSVIEW_GET_TIMESTAMP() * * Description * Function macro to retrieve a system timestamp for SYSVIEW events. * Default * Call user-supplied function SEGGER_SYSVIEW_X_GetTimestamp(). * Notes * For some known compilers and cores, a ready-to-use, core-specific * default is set. * ARMv7M: Read Cortex-M Cycle Count register. * * The system timestamp clock frequency has to be passed in * SEGGER_SYSVIEW_Init(). */ #ifndef SEGGER_SYSVIEW_GET_TIMESTAMP #if defined (SEGGER_SYSVIEW_CORE) && (SEGGER_SYSVIEW_CORE == SEGGER_SYSVIEW_CORE_CM3) // Retrieve a system timestamp. Cortex-M cycle counter. #define SEGGER_SYSVIEW_GET_TIMESTAMP() (*(U32 *)(0xE0001004)) #else // Retrieve a system timestamp via user-defined function #define SEGGER_SYSVIEW_GET_TIMESTAMP() SEGGER_SYSVIEW_X_GetTimestamp() #endif #endif /********************************************************************* * * SEGGER_SYSVIEW_X_GetTimestamp() * * Function description * Returns the current timestamp in ticks using the system tick * count and the SysTick counter. * All parameters of the SysTick have to be known and are set via * configuration defines on top of the file. * * Return value * The current timestamp. * * Additional information * SEGGER_SYSVIEW_X_GetTimestamp is always called when interrupts are * disabled. Therefore locking here is not required. */ U32 SEGGER_SYSVIEW_X_GetTimestamp ( void ) { #if USE_CYCCNT_TIMESTAMP U32 TickCount ; U32 Cycles ; U32 CyclesPerTick ; // // Get the cycles of the current system tick. // SysTick is down-counting, subtract the current value // from the number of cycles per tick. // CyclesPerTick = SYST_RVR + 1 ; Cycles = ( CyclesPerTick - SYST_CVR ); // // Get the system tick count. // TickCount = SEGGER_SYSVIEW_TickCnt ; // // If a SysTick interrupt is pending, re-read timer and adjust result // if (( SCB_ICSR & SCB_ICSR_PENDSTSET_MASK ) != 0 ) { Cycles = ( CyclesPerTick - SYST_CVR ); TickCount ++ ; } Cycles += TickCount * CyclesPerTick ; return Cycles ; #endif } Do you see how cycles is calculated? Cycles += TickCount * CyclesPerTick ; Have you thought it is not optimized? Use breakpoints before and after that line, and compare the value of the SysTick Current Value Register to see how many cycles are used. #define SYST_CVR (*(volatile U32*) (0xE000E018uL)) It\u2019s just about 12 cycles. If you want to save 12 cycles in slow MCUs, here is an optimized version: U32 CyclesPerTick = 0 ; U32 TotalCycles = 0 void SEGGER_SYSVIEW_Conf ( void ) { ... CyclesPerTick = SYST_RVR + 1 ; } U32 SEGGER_SYSVIEW_X_GetTimestamp ( void ) { #if USE_CYCCNT_TIMESTAMP U32 Cycles ; // // Get the cycles of the current system tick. // SysTick is down-counting, subtract the current value from the number of cycles per tick. // Cycles = ( CyclesPerTick - SYST_CVR ); // // If a SysTick interrupt is pending, re-read timer and adjust result // if (( SCB_ICSR & SCB_ICSR_PENDSTSET_MASK ) != 0 ) { Cycles = ( CyclesPerTick - SYST_CVR ); // calculate the total cycles in advance, // but the actual total cycles will be updated when SysTick is handled return TotalCycles + CyclesPerTick + Cycles ; } return TotalCycles + Cycles ; #endif } void SysTick_Handler ( void ) { TotalCycles += CyclesPerTick ; HAL_IncTick (); }","title":"5. Appendix"},{"location":"blog/stm32/notes/","text":".md-typeset h2, .md-typeset h3 { font-size: 0; /* hide header but still scroll to its anchor */ } .md-typeset .content { margin-left: 3em; } Terminal application \u2693\ufe0e Terminal application Links have review about terminal applications: https://oliverbetz.de/pages/PIM/TerminalPrograms https://learn.sparkfun.com/tutorials/terminal-basics/all The good ones are: CoolTerm YAT MobaXterm Use float with printf and scanf \u2693\ufe0e Use float with printf and scanf The newlib-nano library does not enable float support by default. When float is used in printf() , scanf() or in sprintf() , it must be explicitly enabled in linker. To enable, go to Project \u00bb Properties menu, then go to C/C++ Build \u00bb Settings \u00bb Cross ARM C++ Linker \u00bb Miscellaneous and check Use float with nano printf/scanf . DMA Polling in an infinite loop \u2693\ufe0e DMA Polling in an infinite loop The function HAL_DMA_PollForTransfer() works properly only when the DMA interrupts are disabled. It needs to turn off the option Force DMA Channels Interrupts to be able to disable DMA interrupts. Force turning off DMA interrupt If DMA interrupts are enabled, the interrupt handler HAL_DMA_IRQHandler() may clear the interrupt flag and set DMA State to HAL_DMA_STATE_READY , which causes the function HAL_DMA_PollForTransfer() runs in a infinite loop if it is called with Timeout = HAL_MAX_DELAY : HAL_StatusTypeDef HAL_DMA_PollForTransfer ( DMA_HandleTypeDef * hdma , uint32_t CompleteLevel , uint32_t Timeout ) { ... /* Get tick */ tickstart = HAL_GetTick (); // hdma->DmaBaseAddress->ISR = 0 due to modified hdma->DmaBaseAddress->IFCR while ( RESET == ( hdma -> DmaBaseAddress -> ISR & temp )) { // always enter here if ( RESET != ( hdma -> DmaBaseAddress -> ISR & ( DMA_FLAG_TE1 << hdma -> ChannelIndex ))) { // never enter here } if ( Timeout != HAL_MAX_DELAY ) { // never enter here } } } To fix this, just need to check the DMA state inside the while loop. If the state is already HAL_DMA_STATE_READY , exit the loop and return HAL_OK . Pulling-up or Pulling-down an input \u2693\ufe0e Pulling-up or Pulling-down an input When a logic analyser cannot catch the level of an input pin, it\u2019s mostly because of no pull-up or pull-down is applied for that pin. At the time I wanted to see input bouncing on the push button soldered on my STM32F0 Discovery board, I plugged my Logic Analyzer to the pin PA0 . The weird thing was that the logic level of PA0 is always High, even when I pressed on the button. Without logic analyser plugged in, the button works well. A button using pull-down resistor It turns out that the pin PA0 did not have pull-up or pull-down setting in MCU side, while the logic analyser sets its input probe pin with pull-up resistor. Therefore, when probe pin is connected, the logic level is always HIGH. Setting pull-down resistor in in MCU side will solve this problem. A floating input button One other case is working with the USER button on Black Pill F411 or Blue Pill F103 boards. The User Key is left floating without any resistor. If in MCU side, no pull-up or pull-down is set, the input is always floating. If I connect a probe pin from logic analyser, the button will work normally. Setting pull-up resistor in in MCU side will solve this problem. SEGGER SysView causes Hard Faults/Resets \u2693\ufe0e SEGGER SysView causes Hard Faults/Resets There is a problem that when the system is running normally, if start Segger SysView to record event, system will hang up . Debugger shows that there is a HardFault exception. On the Segger Forum , there are some questions related to this issue, such as here or here . The answer from a Segger\u2019s developer is: HardFaults/Resets are most commonly caused by stack overflows. SystemView may need ~200 Bytes on the stack. Make sure enough stack is available in every context (Task, Interrupt, Scheduler) which can create SystemView events. For further exception debugging, refer to this Segger Note AN00016 on this article . Check the pin function on development kits \u2693\ufe0e Check the pin function on development kits When using a development kit or any board, always check the pin function and PCB to know what is connected to that pin. For example, here is a problem that many people have: pin PA9 and PA10 of the USART 1 do not work property, the data on is corrupted on the pin output when captured in a logic analyser. Why? On some boards, such as STM32F411E DISCO, pin PA9 is connected to V BUS of the USB OTG port, and pin PA10 is connected to USB_ID pin. Therefore, USART1 is not available on these pins anymore. USB OTG Pins The solution is to choose alternative pins which are also mapped to USART1, such as PB7 and PA15 . Refer to the datasheet of the MCU to know all alternative functions. Computer architecture \u2693\ufe0e Computer architecture The most of STM32 MCUs share the same computer architecture except for STM32F0 and STM32L0 that are based on the Cortex-M0/0+ cores. They, in fact, are the only Cortex-M cores based on the von Neumann architecture , compared to the other Cortex-M cores that are based on the (modified) Harvard architecture 1 . The fundamental distinction between the two architectures is that: Cortex-M0/0+ cores access to Flash, SRAM and peripherals using one common bus The other Cortex-M cores have: two separated bus lines for the access to the flash (one for the fetch of instructions called instruction bus, or simply I-Bus or even I-Code, and one for the access to const data called data bus, or simply D-Bus or even D-Code) one dedicated line for the access to SRAM and peripherals (also called system bus, or simply S-Bus). Windows 10 USB to Serial driver \u2693\ufe0e Windows 10 USB to Serial driver Windows 10 does not support PL2303 USB to Serial, but here is the fix for this problem: https://github.com/johnstevenson/pl2303-win10 . This will install an old but compatible driver for EOL PL2303 chips. https://en.wikipedia.org/wiki/Modified_Harvard_architecture \u21a9","title":"Notes"},{"location":"blog/stm32/notes/#terminal-application","text":"Terminal application Links have review about terminal applications: https://oliverbetz.de/pages/PIM/TerminalPrograms https://learn.sparkfun.com/tutorials/terminal-basics/all The good ones are: CoolTerm YAT MobaXterm","title":"Terminal application"},{"location":"blog/stm32/notes/#use-float-with-printf-and-scanf","text":"Use float with printf and scanf The newlib-nano library does not enable float support by default. When float is used in printf() , scanf() or in sprintf() , it must be explicitly enabled in linker. To enable, go to Project \u00bb Properties menu, then go to C/C++ Build \u00bb Settings \u00bb Cross ARM C++ Linker \u00bb Miscellaneous and check Use float with nano printf/scanf .","title":"Use float with printf and scanf"},{"location":"blog/stm32/notes/#dma-polling-in-an-infinite-loop","text":"DMA Polling in an infinite loop The function HAL_DMA_PollForTransfer() works properly only when the DMA interrupts are disabled. It needs to turn off the option Force DMA Channels Interrupts to be able to disable DMA interrupts. Force turning off DMA interrupt If DMA interrupts are enabled, the interrupt handler HAL_DMA_IRQHandler() may clear the interrupt flag and set DMA State to HAL_DMA_STATE_READY , which causes the function HAL_DMA_PollForTransfer() runs in a infinite loop if it is called with Timeout = HAL_MAX_DELAY : HAL_StatusTypeDef HAL_DMA_PollForTransfer ( DMA_HandleTypeDef * hdma , uint32_t CompleteLevel , uint32_t Timeout ) { ... /* Get tick */ tickstart = HAL_GetTick (); // hdma->DmaBaseAddress->ISR = 0 due to modified hdma->DmaBaseAddress->IFCR while ( RESET == ( hdma -> DmaBaseAddress -> ISR & temp )) { // always enter here if ( RESET != ( hdma -> DmaBaseAddress -> ISR & ( DMA_FLAG_TE1 << hdma -> ChannelIndex ))) { // never enter here } if ( Timeout != HAL_MAX_DELAY ) { // never enter here } } } To fix this, just need to check the DMA state inside the while loop. If the state is already HAL_DMA_STATE_READY , exit the loop and return HAL_OK .","title":"DMA Polling in an infinite loop"},{"location":"blog/stm32/notes/#pulling-up-or-pulling-down-an-input","text":"Pulling-up or Pulling-down an input When a logic analyser cannot catch the level of an input pin, it\u2019s mostly because of no pull-up or pull-down is applied for that pin. At the time I wanted to see input bouncing on the push button soldered on my STM32F0 Discovery board, I plugged my Logic Analyzer to the pin PA0 . The weird thing was that the logic level of PA0 is always High, even when I pressed on the button. Without logic analyser plugged in, the button works well. A button using pull-down resistor It turns out that the pin PA0 did not have pull-up or pull-down setting in MCU side, while the logic analyser sets its input probe pin with pull-up resistor. Therefore, when probe pin is connected, the logic level is always HIGH. Setting pull-down resistor in in MCU side will solve this problem. A floating input button One other case is working with the USER button on Black Pill F411 or Blue Pill F103 boards. The User Key is left floating without any resistor. If in MCU side, no pull-up or pull-down is set, the input is always floating. If I connect a probe pin from logic analyser, the button will work normally. Setting pull-up resistor in in MCU side will solve this problem.","title":"Pulling-up or Pulling-down an input"},{"location":"blog/stm32/notes/#segger-sysview-causes-hard-faultsresets","text":"SEGGER SysView causes Hard Faults/Resets There is a problem that when the system is running normally, if start Segger SysView to record event, system will hang up . Debugger shows that there is a HardFault exception. On the Segger Forum , there are some questions related to this issue, such as here or here . The answer from a Segger\u2019s developer is: HardFaults/Resets are most commonly caused by stack overflows. SystemView may need ~200 Bytes on the stack. Make sure enough stack is available in every context (Task, Interrupt, Scheduler) which can create SystemView events. For further exception debugging, refer to this Segger Note AN00016 on this article .","title":"SEGGER SysView causes Hard Faults/Resets"},{"location":"blog/stm32/notes/#check-the-pin-function-on-development-kits","text":"Check the pin function on development kits When using a development kit or any board, always check the pin function and PCB to know what is connected to that pin. For example, here is a problem that many people have: pin PA9 and PA10 of the USART 1 do not work property, the data on is corrupted on the pin output when captured in a logic analyser. Why? On some boards, such as STM32F411E DISCO, pin PA9 is connected to V BUS of the USB OTG port, and pin PA10 is connected to USB_ID pin. Therefore, USART1 is not available on these pins anymore. USB OTG Pins The solution is to choose alternative pins which are also mapped to USART1, such as PB7 and PA15 . Refer to the datasheet of the MCU to know all alternative functions.","title":"Check the pin function on development kits"},{"location":"blog/stm32/notes/#computer-architecture","text":"Computer architecture The most of STM32 MCUs share the same computer architecture except for STM32F0 and STM32L0 that are based on the Cortex-M0/0+ cores. They, in fact, are the only Cortex-M cores based on the von Neumann architecture , compared to the other Cortex-M cores that are based on the (modified) Harvard architecture 1 . The fundamental distinction between the two architectures is that: Cortex-M0/0+ cores access to Flash, SRAM and peripherals using one common bus The other Cortex-M cores have: two separated bus lines for the access to the flash (one for the fetch of instructions called instruction bus, or simply I-Bus or even I-Code, and one for the access to const data called data bus, or simply D-Bus or even D-Code) one dedicated line for the access to SRAM and peripherals (also called system bus, or simply S-Bus).","title":"Computer architecture"},{"location":"blog/stm32/notes/#windows-10-usb-to-serial-driver","text":"Windows 10 USB to Serial driver Windows 10 does not support PL2303 USB to Serial, but here is the fix for this problem: https://github.com/johnstevenson/pl2303-win10 . This will install an old but compatible driver for EOL PL2303 chips. https://en.wikipedia.org/wiki/Modified_Harvard_architecture \u21a9","title":"Windows 10 USB to Serial driver"},{"location":"blog/stm32/oled-ssd1306/","text":"F051R8_I2C_OLED_SSD1306.zip 128x32 using I2C at 400 Kbps OLED 128x64 using SPI at 750 Kbps 1. SSD1306 Controller \u2693\ufe0e SSD1306 is a single-chip CMOS OLED/PLED driver to control display with 128 segments and 64 commons. This IC is designed for Common Cathode type OLED panel. The SSD1306 embeds with contrast control, display RAM and oscillator, which reduces the number of external components and power consumption. It has 256-step brightness control. Data/Commands are sent from general MCU through the hardware selectable 6800/8000 series compatible Parallel Interface, I2C interface or Serial Peripheral Interface. It is suitable for many compact portable applications, such as mobile phone sub-display, MP3 player and calculator, etc. 1.1. Features \u2693\ufe0e Resolution: 128 x 64 dots VDD = 1.65V to 3.3V for IC logic On-Chip Oscillator 256-step contrast brightness Embedded 128 x 64 bit SRAM display buffer Programmable Frame Rate and Multiplexing Ratio Row Re-mapping and Column Re-mapping to rotate the screen Scrolling function in both horizontal and vertical direction Pin selectable MCU Interfaces: 8-bit 6800/8080-series parallel interface 3 /4 wire Serial Peripheral Interface I2C Interface SSD1306 128x64 OLED SSD1306 128x32 OLED 1.2. I2C Interface \u2693\ufe0e SSD1306 has to recognize the slave address before transmitting or receiving any information by the I2C-bus. The device will respond to the slave address following by the slave address bit ( SA0 bit) and the read/write select bit ( R/W# bit) with the following byte format: b7 b6 b5 b4 b3 b2 b1 b0 0 1 1 1 1 0 SA0 R/W# It means the address of OLED is either 0x3C or 0x3D in 7-bit address mode, or 0x78 and 0x7A in 8-bit address mode. Use I2C Scanner to see the address of connected devices on I2C bus. 1.2.1. I2C Message \u2693\ufe0e In the Write Mode , the Master device has to transfer a control byte following by one or more data bytes in a transfer (between the start and the stop bit). SSD1306 I2C Message Control Byte : Have the Co# bit, the D/C# bit, and six 0 bits: Bit Co# set to 0 means the next stream bytes. Bit Co# set to 1 means the next byte is a single byte Bit D/C# set to 0 means the next bytes is a Command and Command parameters. Bit D/C# set to 1 means the next bytes is Data which will be stored in the Embedded GDDRAM. Therefore, the Control Byte can be: Single Command mode: 0x80 Stream Command mode: 0x00 Single Data mode: 0xC0 Stream Data mode: 0x40 1.3. Display clock \u2693\ufe0e The Display Clock for the Display Timing Generator is derived from the operation CLK (either the internal RC Oscillator or an external Clock). The command 0xD5 and its one byte parameter A are used to select the internal RC frequency F osc via A[7:4] , and the clock divide ratio D via A[3:0] . 1.4. Graphic Display Data RAM \u2693\ufe0e Dimension Segments mean Columns , define the Width . Commons mean Rows , define the Height . The width of the screen is the number of activated Segments. There are 128 segments, from SEG0 to SEG127 . The height of the screen is the number of activate Commons. There are 64 commons, from COM0 to COM63 . The GDDRAM is a bit mapped static RAM holding the bit pattern to be displayed. The size of the RAM is 128 x 64 bits. The Commons are grouped in to 8 pages, from PAGE0 to PAGE7 . Each segment in a page is one BYTE which actually drives 8 commons. Data bit D0 is written into the top row, while data bit D7 is written into bottom row. Pages with its Commons Segments in a Page and the corresponding bit of a pixel The command 0xA8 and its one byte parameter A are used to set the number of activated rows (in 0-index) which is usually the height of the desired screen\u2019s resolution. The command 0xDA and its one byte parameter A are used to set the Memory Scan Mode of the commons (rows) from the memory to the display. If A=0x02 , each half of memory will be pushed on a half of screen. If A=0x12 , rows are interleaved. Memory scan mode 128 x 32 Double Buffer SSD1306 Controller divides the GDDRAM 128x64 into 2 halves with different scan modes. Therefore, if using only half resolution at 128x32, 2 halves of memory can be used as a double buffer to reduce the flicker or to show different images without redrawing. Read more in this project. Mirroring The command 0xA0 and 0xA1 are used to remap the segments (columns). This causes the screen is vertically flipped. The command 0xC0 and 0xC8 are used to remap the commons (rows). This causes the screen is horizontally flipped. Flip behavior Horizontal Flip affects only activated commons (rows). Please note the case that the activated rows is less then the screen height. Flip behavior in different activating rows 1.5. Memory Addressing Mode \u2693\ufe0e When ever a data is written into GDDRAM, the current memory point is increased by one to point to the next bytes of rows in the next segment. There are 3 different memory addressing modes in SSD1306: page addressing mode, horizontal addressing mode and vertical addressing mode. The command 0x20 and its one byte parameter A are used to set the Memory Addressing Mode . If A=0 , it sets Horizontal Mode If A=1 , it sets Vertical Mode If A=2 , it sets Page Mode Horizontal Mode In horizontal addressing mode, after the display RAM is read/written, the column address pointer is increased automatically by 1. If the column address pointer reaches column end address, the column address pointer is reset to column start address and page address pointer is increased by 1. When both column and page address pointers reach the end address, the pointers are reset to column start address and page start address The command 0x21 and its two bytes parameter A and B are used to set the start and the end segment (column). This also set the address pointer to the start segment. The command 0x22 and its two bytes parameter A and B to set the start and the end page (rows). This also set the address pointer to the start page. Memory Horizontal Addressing mode Vertical Mode In vertical addressing mode, after the display RAM is read/written, the page address pointer is increased automatically by 1. If the page address pointer reaches the page end address, the page address pointer is reset to page start address and column address pointer is increased by 1. When both column and page address pointers reach the end address, the pointers are reset to column start address and page start address The command 0x21 and its two bytes parameter A and B are used to set the start and the end segment (column). This also set the address pointer to the start segment. The command 0x22 and its two bytes parameter A and B to set the start and the end page (rows). This also set the address pointer to the start page. Memory Vertical Addressing mode Page Mode In page addressing mode, after the display RAM is read/written, the column address pointer is increased automatically by 1. If the column address pointer reaches column end address, the column address pointer is reset to column start address and page address pointer is not changed. Users have to set the new page and column addresses in order to access the next page RAM content The command from 0x00 ~ 0x0F are used to set the lower nibble of the start segment (column). The command from 0x10 ~ 0x1F are used to set the higher nibble of the start segment (column). The command from 0xB0 ~ 0xB7 are used to set the active page. 1.6. Brightness \u2693\ufe0e The command 0x81 and its one byte parameter A are used to set the brightness value which is in range [0:255] . 1.7. Display Start Line \u2693\ufe0e The command from 0x40 ~ 0x7F are used to set the starting address of display RAM. With value equal to 0, RAM row 0 is mapped to COM0. With value equal to 1, RAM row 1 is mapped to COM0 and so on. Then command 0xD3 and its one byte parameter is to specify the mapping of the display start line to one of COM0 to COM63 (assuming that COM0 is the display start line then the display start line register is equal to 0). For example, to move the COM16 towards the COM0 direction by 16 lines the 6-bit data in the second byte should be given as 010000b . To move in the opposite direction by 16 lines the 6-bit data should be given by 64 \u2013 16, so the second byte would be 100000b . 1.8. Display content \u2693\ufe0e There are two modes of display ON can be selected. The command 0xA4 will set screen to display from RAM; The command 0xA5 will force screen to display all pixels ON regardless of the contents of the display data RAM. 1.9. Display Inverse \u2693\ufe0e The command 0xA6 will set screen to display in normal mode. In normal display a RAM data of 1 indicates an \u201cON\u201d pixel while in inverse display a RAM data of 0 indicates an \u201cON\u201d pixel. The command 0xA7 will force screen to inverse the display. 1.10. Display On/Off \u2693\ufe0e The command 0xAE will set screen to off; the segment and common output are in VSS state and high impedance state, respectively The command 0xAF will turn on the screen. 1.11. Charge Pump (DC-DC) \u2693\ufe0e The internal regulator circuit in SSD1306 accompanying only 2 external capacitors can generate a 7.5V voltage supply, V CC , from a low voltage supply input, V BAT . The V CC is the voltage supply to the OLED driver block. This is a switching capacitor regulator circuit, designed for handheld applications. This regulator can be turned on/off by software command setting. The command 0x8D and its one byte parameter is used to turn On or Off the OLED driver block. If the parameter is 0x14 , it enables the charge pump. If the parameter is 0x10 , it disables the charge pump. Note that the command to turn on OLED 0xAF should be sent after enabling the charge pump. 2. Implementation \u2693\ufe0e Below implementation should not depend on any specific protocol. It can work without knowing the protocol, except 4 functions: SSD1306_Init() , SSD1306_CMD_Send() , SSD1306_DATA_Send() and SSD1306_Screen_Update() ; 2.1. Protocol Settings \u2693\ufe0e SSD1306 can accept I2C speed at Standard Mode (100 Kbps), Fast Mode (400 Kbps), and Fast Plus Mode (1 Mbps). Note to set Pull-up resistors on the SCL and SDA pins when there is no external pull-up resistors. SPI interface Using SPI will achieve higher speed upto 15 Mbps. Refer to this F051R8_SPI_OLED_SH1106 . 2.2. Start-up commands \u2693\ufe0e It\u2019s highly recommended sending a full set of commands to set up OLED when startup or reboot. This help to get right configs. This is a minimal setup for setting up OLED with resolution being 128x32, Horizontal Memory Addressing Mode, no flipping. A buffer with the first byte being the CONTROL COMMAND byte is used to store a list of commands: uint8_t ssd1306_cmd_buffer [ SSD1306_BUFFER_CMD_MAX + 1 ] = { 0x00 , 0 }; Then add the commands and their parameters, as below: void SSD1306_Init ( I2C_HandleTypeDef * hi2c ) { // startup sequence SSD1306_CMD_Int (); // Display off SSD1306_CMD_Add0 ( 0xAE ); // OSC default=0x81 SSD1306_CMD_Add1 ( 0xD5 , 0x81 ); // Brightness in range 0~255, default=0x7F SSD1306_CMD_Add1 ( 0x81 , 0x7F ); // Memory Address Mode: Horizontal=0, Vertical=1, Page=default=2 SSD1306_CMD_Add1 ( 0x20 , 0 ); // Set Display Offset in range 0~63 SSD1306_CMD_Add1 ( 0xD3 , 0 ); // Set Display start line in range 0x40~0x7F SSD1306_CMD_Add0 ( 0x40 ); // Set multiplex number (activated rows): rows=height-1, default=63 SSD1306_CMD_Add1 ( 0xA8 , SSD1306_HEIGHT -1 ); // Reduce a half of height SSD1306_CMD_Add1 ( 0xDA , 0x02 ); // Segment (Column) normal mode, Inverse=0xA1 SSD1306_CMD_Add0 ( 0xA0 ); // Common (Row) normal mode, inverse=0xC8 SSD1306_CMD_Add0 ( 0xC0 ); // Display normal mode, inverse=0xA7 SSD1306_CMD_Add0 ( 0xA6 ); // Disable Scroll SSD1306_CMD_Add0 ( 0x2E ); // Pre-charge period, default=2 SSD1306_CMD_Add1 ( 0xD9 , 2 ); // Charge Pump: On=0x14, Off=0x10 SSD1306_CMD_Add1 ( 0x8D , 0x14 ); // Display on SSD1306_CMD_Add0 ( 0xAF ); SSD1306_CMD_Send ( hi2c ); 2.3. Screen Buffer \u2693\ufe0e The GDDRAM is accessible at byte level only, therefore, to manipulate bits, it\u2019s better to use an external memory which have the same size of the GDDRAM and then draw on that buffer. When screen needs to be updated, that buffer will be sent to GDDRAM. Memory Mapping A memory buffer is used to hold the screen buffer with the first byte is the DATA CONTROL byte: uint8_t ssd1306_data_buffer [ SSD1306_BUFFER_DATA_MAX + 1 ] = { 0x40 , 0 }; The whole buffer is sent to SSD1306 after setting the address point to first byte (Segment = 0, Page = 0): Separate Command and Data stream When an I2C transfer is started, the first byte is used to set the type of whole transfer. From the second byte, they are considered as the data bytes of the command. It could not be mixed between a command stream and a data stream. void SSD1306_Screen_Update ( I2C_HandleTypeDef * hi2c ) { SSD1306_CMD_Int (); // point to the starting byte of screen SSD1306_CMD_Add2 ( 0x21 , 0 , SSD1306_WIDTH -1 ); // Segment (column) SSD1306_CMD_Add2 ( 0x22 , 0 , ( SSD1306_HEIGHT / 8 ) -1 ); // Page (row) SSD1306_CMD_Send ( hi2c ); SSD1306_DATA_Send ( hi2c ); // Send screen buffer } 2.4. Draw a pixel \u2693\ufe0e As seen in the above picture of memory mapping, any pixel at location (x, y) can be set or unset with below method: Byte location: ssd1306_data_buffer [ 1 + x + ( y >> 3 ) * SSD1306_WIDTH ] Bit location: ( 1 << ( y % 8 )) Therefore, to set a pixel: ssd1306_data_buffer [ 1 + x + ( y >> 3 ) * SSD1306_WIDTH ] |= ( 1 << ( y % 8 )); and to clear a pixel: ssd1306_data_buffer [ 1 + x + ( y >> 3 ) * SSD1306_WIDTH ] &= ~ ( 1 << ( y % 8 )); The SSD1306_DrawPixel also takes a color parameter to present a set/cleared pixel: White = set, Black = clear. void SSD1306_DrawPixel ( int16_t x , int16_t y , SSD1306_COLOR_t color ) { if ( x < 0 || x >= SSD1306_WIDTH || y < 0 || y >= SSD1306_HEIGHT ) { return ; } if ( color == SSD1306_WHITE ) { ssd1306_data_buffer [ 1 + x + ( y >> 3 ) * SSD1306_WIDTH ] |= ( 1 << ( y % 8 )); } else { ssd1306_data_buffer [ 1 + x + ( y >> 3 ) * SSD1306_WIDTH ] &= ~ ( 1 << ( y % 8 )); } } Based on the function SSD1306_DrawPixel() , other shapes can be drawn too. Here are some functions to draw primitive shapes: void SSD1306_DrawLine ( int16_t x0 , int16_t y0 , int16_t x1 , int16_t y1 , SSD1306_COLOR_t color ); void SSD1306_DrawRectangle ( int16_t x , int16_t y , int16_t w , int16_t h , SSD1306_COLOR_t color ); void SSD1306_DrawFilledRectangle ( int16_t x , int16_t y , int16_t w , int16_t h , SSD1306_COLOR_t color ); void SSD1306_DrawTriangle ( int16_t x1 , int16_t y1 , int16_t x2 , int16_t y2 , int16_t x3 , int16_t y3 , SSD1306_COLOR_t color ); void SSD1306_DrawFilledTriangle ( int16_t x1 , int16_t y1 , int16_t x2 , int16_t y2 , int16_t x3 , int16_t y3 , SSD1306_COLOR_t color ); void SSD1306_DrawCircle ( int16_t x0 , int16_t y0 , int16_t r , SSD1306_COLOR_t color ); void SSD1306_DrawFilledCircle ( int16_t x0 , int16_t y0 , int16_t r , SSD1306_COLOR_t color ); 2.5. Bitmap & Font & String \u2693\ufe0e Bitmap file can be easily read out, as it is sliced into bytes. For example, a character 0 below are encoded into 10 bytes which will be mapped to 7px width by 10px height character. It also can be a 8px width by 10px height bitmap. Bitmap Mapping void SSD1306_DrawBitmap ( int16_t x , int16_t y , const uint8_t * bitmap , int16_t w , int16_t h ) { int16_t byteWidth = ( w + 7 ) / 8 ; // Bitmap scan line pad = whole byte uint8_t byte = 0 ; for ( int16_t j = 0 ; j < h ; j ++ , y ++ ) { for ( int16_t i = 0 ; i < w ; i ++ ) { if ( i & 7 ) { byte <<= 1 ; // shift to get a bit } else { // read one byte when i=0 byte = bitmap [ j * byteWidth + i / 8 ]; } // bit is 1 if ( byte & 0x80 ) { SSD1306_DrawPixel ( x + i , y , SSD1306_WHITE ); } } } } Here is an example of a 7x10 font is saved, each 10 bytes represent a character, and the first character is space causing a lookup offset of 32 when retrieving bitmap for a character. If the width of a character is bigger than 8, the array will have uint16_t type to hold at max 16 bits. static const int8_t Font7x10 [] = { 0x00 , 0x00 , 0x00 , 0x00 , 0x00 , 0x00 , 0x00 , 0x00 , 0x00 , 0x00 , // sp (32) ... 0x38 , 0x44 , 0x44 , 0x54 , 0x54 , 0x44 , 0x44 , 0x38 , 0x00 , 0x00 , // 0 0x10 , 0x30 , 0x50 , 0x10 , 0x10 , 0x10 , 0x10 , 0x10 , 0x00 , 0x00 , // 1 0x38 , 0x44 , 0x44 , 0x04 , 0x08 , 0x10 , 0x20 , 0x7C , 0x00 , 0x00 , // 2 ... To write a character: void SSD1306_WriteChar ( int16_t x , int16_t y , char ch , FontDef_t * Font ) { int16_t x0 , y0 , b ; // Translate font to screen buffer for ( y0 = 0 ; y0 < Font -> height ; y0 ++ ) { b = Font -> data [( ch - 32 ) * Font -> height + y0 ]; for ( x0 = 0 ; x0 < Font -> width ; x0 ++ ) { if (( b << x0 ) & 0x8000 ) { SSD1306_DrawPixel ( x + x0 , y + y0 , SSD1306_WHITE ); } } } } To write a string: void SSD1306_WriteString ( int16_t x , int16_t y , char * str , FontDef_t * Font ) { int16_t n = 0 ; // Write until null-byte or the first cutoff char while ( * str ) { SSD1306_WriteChar ( x + n * Font -> width , y , * str , Font ); n ++ ; str ++ ; } } Transferring modes The communication with screen can be done in either Polling, Interrupt or DMA mode. In DMA mode, the interrupt of I2C port must be enabled as it is in the Interrupt mode. A callback HAL_I2C_MasterTxCpltCallback() is called when a transfer is done. It should check whenever the screen buffer is dirty to update on display to avoid overhead of data communication. I2C is dropped when using Interrupt at Ultra fast mode Take an example of I2C Ultra Fast mode at 5 Mbps, which will generate 625000 interrupts per second (!) in case of 8-bit transfer. An STM32F0xx running at 48 MHz will have a room of only 77 cycles to process an Interrupt. However, calling an interrupt takes 12 cycle, exiting an interrupt costs 10 cycles (ideal state without waiting). Therefore, an interrupt code must be served in only 55 cycles ! Should use DMA when the bit rate is high, because DMA only causes 2 interrupts: \u201cHalf-transfer\u201d and \u201cTransfer-Complete\u201d in a routine of transfer a large data buffer.","title":"SSD1306 OLED"},{"location":"blog/stm32/oled-ssd1306/#1-ssd1306-controller","text":"SSD1306 is a single-chip CMOS OLED/PLED driver to control display with 128 segments and 64 commons. This IC is designed for Common Cathode type OLED panel. The SSD1306 embeds with contrast control, display RAM and oscillator, which reduces the number of external components and power consumption. It has 256-step brightness control. Data/Commands are sent from general MCU through the hardware selectable 6800/8000 series compatible Parallel Interface, I2C interface or Serial Peripheral Interface. It is suitable for many compact portable applications, such as mobile phone sub-display, MP3 player and calculator, etc.","title":"1. SSD1306 Controller"},{"location":"blog/stm32/oled-ssd1306/#11-features","text":"Resolution: 128 x 64 dots VDD = 1.65V to 3.3V for IC logic On-Chip Oscillator 256-step contrast brightness Embedded 128 x 64 bit SRAM display buffer Programmable Frame Rate and Multiplexing Ratio Row Re-mapping and Column Re-mapping to rotate the screen Scrolling function in both horizontal and vertical direction Pin selectable MCU Interfaces: 8-bit 6800/8080-series parallel interface 3 /4 wire Serial Peripheral Interface I2C Interface SSD1306 128x64 OLED SSD1306 128x32 OLED","title":"1.1. Features"},{"location":"blog/stm32/oled-ssd1306/#12-i2c-interface","text":"SSD1306 has to recognize the slave address before transmitting or receiving any information by the I2C-bus. The device will respond to the slave address following by the slave address bit ( SA0 bit) and the read/write select bit ( R/W# bit) with the following byte format: b7 b6 b5 b4 b3 b2 b1 b0 0 1 1 1 1 0 SA0 R/W# It means the address of OLED is either 0x3C or 0x3D in 7-bit address mode, or 0x78 and 0x7A in 8-bit address mode. Use I2C Scanner to see the address of connected devices on I2C bus.","title":"1.2. I2C Interface"},{"location":"blog/stm32/oled-ssd1306/#121-i2c-message","text":"In the Write Mode , the Master device has to transfer a control byte following by one or more data bytes in a transfer (between the start and the stop bit). SSD1306 I2C Message Control Byte : Have the Co# bit, the D/C# bit, and six 0 bits: Bit Co# set to 0 means the next stream bytes. Bit Co# set to 1 means the next byte is a single byte Bit D/C# set to 0 means the next bytes is a Command and Command parameters. Bit D/C# set to 1 means the next bytes is Data which will be stored in the Embedded GDDRAM. Therefore, the Control Byte can be: Single Command mode: 0x80 Stream Command mode: 0x00 Single Data mode: 0xC0 Stream Data mode: 0x40","title":"1.2.1. I2C Message"},{"location":"blog/stm32/oled-ssd1306/#13-display-clock","text":"The Display Clock for the Display Timing Generator is derived from the operation CLK (either the internal RC Oscillator or an external Clock). The command 0xD5 and its one byte parameter A are used to select the internal RC frequency F osc via A[7:4] , and the clock divide ratio D via A[3:0] .","title":"1.3. Display clock"},{"location":"blog/stm32/oled-ssd1306/#14-graphic-display-data-ram","text":"Dimension Segments mean Columns , define the Width . Commons mean Rows , define the Height . The width of the screen is the number of activated Segments. There are 128 segments, from SEG0 to SEG127 . The height of the screen is the number of activate Commons. There are 64 commons, from COM0 to COM63 . The GDDRAM is a bit mapped static RAM holding the bit pattern to be displayed. The size of the RAM is 128 x 64 bits. The Commons are grouped in to 8 pages, from PAGE0 to PAGE7 . Each segment in a page is one BYTE which actually drives 8 commons. Data bit D0 is written into the top row, while data bit D7 is written into bottom row. Pages with its Commons Segments in a Page and the corresponding bit of a pixel The command 0xA8 and its one byte parameter A are used to set the number of activated rows (in 0-index) which is usually the height of the desired screen\u2019s resolution. The command 0xDA and its one byte parameter A are used to set the Memory Scan Mode of the commons (rows) from the memory to the display. If A=0x02 , each half of memory will be pushed on a half of screen. If A=0x12 , rows are interleaved. Memory scan mode 128 x 32 Double Buffer SSD1306 Controller divides the GDDRAM 128x64 into 2 halves with different scan modes. Therefore, if using only half resolution at 128x32, 2 halves of memory can be used as a double buffer to reduce the flicker or to show different images without redrawing. Read more in this project. Mirroring The command 0xA0 and 0xA1 are used to remap the segments (columns). This causes the screen is vertically flipped. The command 0xC0 and 0xC8 are used to remap the commons (rows). This causes the screen is horizontally flipped. Flip behavior Horizontal Flip affects only activated commons (rows). Please note the case that the activated rows is less then the screen height. Flip behavior in different activating rows","title":"1.4. Graphic Display Data RAM"},{"location":"blog/stm32/oled-ssd1306/#15-memory-addressing-mode","text":"When ever a data is written into GDDRAM, the current memory point is increased by one to point to the next bytes of rows in the next segment. There are 3 different memory addressing modes in SSD1306: page addressing mode, horizontal addressing mode and vertical addressing mode. The command 0x20 and its one byte parameter A are used to set the Memory Addressing Mode . If A=0 , it sets Horizontal Mode If A=1 , it sets Vertical Mode If A=2 , it sets Page Mode Horizontal Mode In horizontal addressing mode, after the display RAM is read/written, the column address pointer is increased automatically by 1. If the column address pointer reaches column end address, the column address pointer is reset to column start address and page address pointer is increased by 1. When both column and page address pointers reach the end address, the pointers are reset to column start address and page start address The command 0x21 and its two bytes parameter A and B are used to set the start and the end segment (column). This also set the address pointer to the start segment. The command 0x22 and its two bytes parameter A and B to set the start and the end page (rows). This also set the address pointer to the start page. Memory Horizontal Addressing mode Vertical Mode In vertical addressing mode, after the display RAM is read/written, the page address pointer is increased automatically by 1. If the page address pointer reaches the page end address, the page address pointer is reset to page start address and column address pointer is increased by 1. When both column and page address pointers reach the end address, the pointers are reset to column start address and page start address The command 0x21 and its two bytes parameter A and B are used to set the start and the end segment (column). This also set the address pointer to the start segment. The command 0x22 and its two bytes parameter A and B to set the start and the end page (rows). This also set the address pointer to the start page. Memory Vertical Addressing mode Page Mode In page addressing mode, after the display RAM is read/written, the column address pointer is increased automatically by 1. If the column address pointer reaches column end address, the column address pointer is reset to column start address and page address pointer is not changed. Users have to set the new page and column addresses in order to access the next page RAM content The command from 0x00 ~ 0x0F are used to set the lower nibble of the start segment (column). The command from 0x10 ~ 0x1F are used to set the higher nibble of the start segment (column). The command from 0xB0 ~ 0xB7 are used to set the active page.","title":"1.5. Memory Addressing Mode"},{"location":"blog/stm32/oled-ssd1306/#16-brightness","text":"The command 0x81 and its one byte parameter A are used to set the brightness value which is in range [0:255] .","title":"1.6. Brightness"},{"location":"blog/stm32/oled-ssd1306/#17-display-start-line","text":"The command from 0x40 ~ 0x7F are used to set the starting address of display RAM. With value equal to 0, RAM row 0 is mapped to COM0. With value equal to 1, RAM row 1 is mapped to COM0 and so on. Then command 0xD3 and its one byte parameter is to specify the mapping of the display start line to one of COM0 to COM63 (assuming that COM0 is the display start line then the display start line register is equal to 0). For example, to move the COM16 towards the COM0 direction by 16 lines the 6-bit data in the second byte should be given as 010000b . To move in the opposite direction by 16 lines the 6-bit data should be given by 64 \u2013 16, so the second byte would be 100000b .","title":"1.7. Display Start Line"},{"location":"blog/stm32/oled-ssd1306/#18-display-content","text":"There are two modes of display ON can be selected. The command 0xA4 will set screen to display from RAM; The command 0xA5 will force screen to display all pixels ON regardless of the contents of the display data RAM.","title":"1.8. Display content"},{"location":"blog/stm32/oled-ssd1306/#19-display-inverse","text":"The command 0xA6 will set screen to display in normal mode. In normal display a RAM data of 1 indicates an \u201cON\u201d pixel while in inverse display a RAM data of 0 indicates an \u201cON\u201d pixel. The command 0xA7 will force screen to inverse the display.","title":"1.9. Display Inverse"},{"location":"blog/stm32/oled-ssd1306/#110-display-onoff","text":"The command 0xAE will set screen to off; the segment and common output are in VSS state and high impedance state, respectively The command 0xAF will turn on the screen.","title":"1.10. Display On/Off"},{"location":"blog/stm32/oled-ssd1306/#111-charge-pump-dc-dc","text":"The internal regulator circuit in SSD1306 accompanying only 2 external capacitors can generate a 7.5V voltage supply, V CC , from a low voltage supply input, V BAT . The V CC is the voltage supply to the OLED driver block. This is a switching capacitor regulator circuit, designed for handheld applications. This regulator can be turned on/off by software command setting. The command 0x8D and its one byte parameter is used to turn On or Off the OLED driver block. If the parameter is 0x14 , it enables the charge pump. If the parameter is 0x10 , it disables the charge pump. Note that the command to turn on OLED 0xAF should be sent after enabling the charge pump.","title":"1.11. Charge Pump (DC-DC)"},{"location":"blog/stm32/oled-ssd1306/#2-implementation","text":"Below implementation should not depend on any specific protocol. It can work without knowing the protocol, except 4 functions: SSD1306_Init() , SSD1306_CMD_Send() , SSD1306_DATA_Send() and SSD1306_Screen_Update() ;","title":"2. Implementation"},{"location":"blog/stm32/oled-ssd1306/#21-protocol-settings","text":"SSD1306 can accept I2C speed at Standard Mode (100 Kbps), Fast Mode (400 Kbps), and Fast Plus Mode (1 Mbps). Note to set Pull-up resistors on the SCL and SDA pins when there is no external pull-up resistors. SPI interface Using SPI will achieve higher speed upto 15 Mbps. Refer to this F051R8_SPI_OLED_SH1106 .","title":"2.1. Protocol Settings"},{"location":"blog/stm32/oled-ssd1306/#22-start-up-commands","text":"It\u2019s highly recommended sending a full set of commands to set up OLED when startup or reboot. This help to get right configs. This is a minimal setup for setting up OLED with resolution being 128x32, Horizontal Memory Addressing Mode, no flipping. A buffer with the first byte being the CONTROL COMMAND byte is used to store a list of commands: uint8_t ssd1306_cmd_buffer [ SSD1306_BUFFER_CMD_MAX + 1 ] = { 0x00 , 0 }; Then add the commands and their parameters, as below: void SSD1306_Init ( I2C_HandleTypeDef * hi2c ) { // startup sequence SSD1306_CMD_Int (); // Display off SSD1306_CMD_Add0 ( 0xAE ); // OSC default=0x81 SSD1306_CMD_Add1 ( 0xD5 , 0x81 ); // Brightness in range 0~255, default=0x7F SSD1306_CMD_Add1 ( 0x81 , 0x7F ); // Memory Address Mode: Horizontal=0, Vertical=1, Page=default=2 SSD1306_CMD_Add1 ( 0x20 , 0 ); // Set Display Offset in range 0~63 SSD1306_CMD_Add1 ( 0xD3 , 0 ); // Set Display start line in range 0x40~0x7F SSD1306_CMD_Add0 ( 0x40 ); // Set multiplex number (activated rows): rows=height-1, default=63 SSD1306_CMD_Add1 ( 0xA8 , SSD1306_HEIGHT -1 ); // Reduce a half of height SSD1306_CMD_Add1 ( 0xDA , 0x02 ); // Segment (Column) normal mode, Inverse=0xA1 SSD1306_CMD_Add0 ( 0xA0 ); // Common (Row) normal mode, inverse=0xC8 SSD1306_CMD_Add0 ( 0xC0 ); // Display normal mode, inverse=0xA7 SSD1306_CMD_Add0 ( 0xA6 ); // Disable Scroll SSD1306_CMD_Add0 ( 0x2E ); // Pre-charge period, default=2 SSD1306_CMD_Add1 ( 0xD9 , 2 ); // Charge Pump: On=0x14, Off=0x10 SSD1306_CMD_Add1 ( 0x8D , 0x14 ); // Display on SSD1306_CMD_Add0 ( 0xAF ); SSD1306_CMD_Send ( hi2c );","title":"2.2. Start-up commands"},{"location":"blog/stm32/oled-ssd1306/#23-screen-buffer","text":"The GDDRAM is accessible at byte level only, therefore, to manipulate bits, it\u2019s better to use an external memory which have the same size of the GDDRAM and then draw on that buffer. When screen needs to be updated, that buffer will be sent to GDDRAM. Memory Mapping A memory buffer is used to hold the screen buffer with the first byte is the DATA CONTROL byte: uint8_t ssd1306_data_buffer [ SSD1306_BUFFER_DATA_MAX + 1 ] = { 0x40 , 0 }; The whole buffer is sent to SSD1306 after setting the address point to first byte (Segment = 0, Page = 0): Separate Command and Data stream When an I2C transfer is started, the first byte is used to set the type of whole transfer. From the second byte, they are considered as the data bytes of the command. It could not be mixed between a command stream and a data stream. void SSD1306_Screen_Update ( I2C_HandleTypeDef * hi2c ) { SSD1306_CMD_Int (); // point to the starting byte of screen SSD1306_CMD_Add2 ( 0x21 , 0 , SSD1306_WIDTH -1 ); // Segment (column) SSD1306_CMD_Add2 ( 0x22 , 0 , ( SSD1306_HEIGHT / 8 ) -1 ); // Page (row) SSD1306_CMD_Send ( hi2c ); SSD1306_DATA_Send ( hi2c ); // Send screen buffer }","title":"2.3. Screen Buffer"},{"location":"blog/stm32/oled-ssd1306/#24-draw-a-pixel","text":"As seen in the above picture of memory mapping, any pixel at location (x, y) can be set or unset with below method: Byte location: ssd1306_data_buffer [ 1 + x + ( y >> 3 ) * SSD1306_WIDTH ] Bit location: ( 1 << ( y % 8 )) Therefore, to set a pixel: ssd1306_data_buffer [ 1 + x + ( y >> 3 ) * SSD1306_WIDTH ] |= ( 1 << ( y % 8 )); and to clear a pixel: ssd1306_data_buffer [ 1 + x + ( y >> 3 ) * SSD1306_WIDTH ] &= ~ ( 1 << ( y % 8 )); The SSD1306_DrawPixel also takes a color parameter to present a set/cleared pixel: White = set, Black = clear. void SSD1306_DrawPixel ( int16_t x , int16_t y , SSD1306_COLOR_t color ) { if ( x < 0 || x >= SSD1306_WIDTH || y < 0 || y >= SSD1306_HEIGHT ) { return ; } if ( color == SSD1306_WHITE ) { ssd1306_data_buffer [ 1 + x + ( y >> 3 ) * SSD1306_WIDTH ] |= ( 1 << ( y % 8 )); } else { ssd1306_data_buffer [ 1 + x + ( y >> 3 ) * SSD1306_WIDTH ] &= ~ ( 1 << ( y % 8 )); } } Based on the function SSD1306_DrawPixel() , other shapes can be drawn too. Here are some functions to draw primitive shapes: void SSD1306_DrawLine ( int16_t x0 , int16_t y0 , int16_t x1 , int16_t y1 , SSD1306_COLOR_t color ); void SSD1306_DrawRectangle ( int16_t x , int16_t y , int16_t w , int16_t h , SSD1306_COLOR_t color ); void SSD1306_DrawFilledRectangle ( int16_t x , int16_t y , int16_t w , int16_t h , SSD1306_COLOR_t color ); void SSD1306_DrawTriangle ( int16_t x1 , int16_t y1 , int16_t x2 , int16_t y2 , int16_t x3 , int16_t y3 , SSD1306_COLOR_t color ); void SSD1306_DrawFilledTriangle ( int16_t x1 , int16_t y1 , int16_t x2 , int16_t y2 , int16_t x3 , int16_t y3 , SSD1306_COLOR_t color ); void SSD1306_DrawCircle ( int16_t x0 , int16_t y0 , int16_t r , SSD1306_COLOR_t color ); void SSD1306_DrawFilledCircle ( int16_t x0 , int16_t y0 , int16_t r , SSD1306_COLOR_t color );","title":"2.4. Draw a pixel"},{"location":"blog/stm32/oled-ssd1306/#25-bitmap--font--string","text":"Bitmap file can be easily read out, as it is sliced into bytes. For example, a character 0 below are encoded into 10 bytes which will be mapped to 7px width by 10px height character. It also can be a 8px width by 10px height bitmap. Bitmap Mapping void SSD1306_DrawBitmap ( int16_t x , int16_t y , const uint8_t * bitmap , int16_t w , int16_t h ) { int16_t byteWidth = ( w + 7 ) / 8 ; // Bitmap scan line pad = whole byte uint8_t byte = 0 ; for ( int16_t j = 0 ; j < h ; j ++ , y ++ ) { for ( int16_t i = 0 ; i < w ; i ++ ) { if ( i & 7 ) { byte <<= 1 ; // shift to get a bit } else { // read one byte when i=0 byte = bitmap [ j * byteWidth + i / 8 ]; } // bit is 1 if ( byte & 0x80 ) { SSD1306_DrawPixel ( x + i , y , SSD1306_WHITE ); } } } } Here is an example of a 7x10 font is saved, each 10 bytes represent a character, and the first character is space causing a lookup offset of 32 when retrieving bitmap for a character. If the width of a character is bigger than 8, the array will have uint16_t type to hold at max 16 bits. static const int8_t Font7x10 [] = { 0x00 , 0x00 , 0x00 , 0x00 , 0x00 , 0x00 , 0x00 , 0x00 , 0x00 , 0x00 , // sp (32) ... 0x38 , 0x44 , 0x44 , 0x54 , 0x54 , 0x44 , 0x44 , 0x38 , 0x00 , 0x00 , // 0 0x10 , 0x30 , 0x50 , 0x10 , 0x10 , 0x10 , 0x10 , 0x10 , 0x00 , 0x00 , // 1 0x38 , 0x44 , 0x44 , 0x04 , 0x08 , 0x10 , 0x20 , 0x7C , 0x00 , 0x00 , // 2 ... To write a character: void SSD1306_WriteChar ( int16_t x , int16_t y , char ch , FontDef_t * Font ) { int16_t x0 , y0 , b ; // Translate font to screen buffer for ( y0 = 0 ; y0 < Font -> height ; y0 ++ ) { b = Font -> data [( ch - 32 ) * Font -> height + y0 ]; for ( x0 = 0 ; x0 < Font -> width ; x0 ++ ) { if (( b << x0 ) & 0x8000 ) { SSD1306_DrawPixel ( x + x0 , y + y0 , SSD1306_WHITE ); } } } } To write a string: void SSD1306_WriteString ( int16_t x , int16_t y , char * str , FontDef_t * Font ) { int16_t n = 0 ; // Write until null-byte or the first cutoff char while ( * str ) { SSD1306_WriteChar ( x + n * Font -> width , y , * str , Font ); n ++ ; str ++ ; } } Transferring modes The communication with screen can be done in either Polling, Interrupt or DMA mode. In DMA mode, the interrupt of I2C port must be enabled as it is in the Interrupt mode. A callback HAL_I2C_MasterTxCpltCallback() is called when a transfer is done. It should check whenever the screen buffer is dirty to update on display to avoid overhead of data communication. I2C is dropped when using Interrupt at Ultra fast mode Take an example of I2C Ultra Fast mode at 5 Mbps, which will generate 625000 interrupts per second (!) in case of 8-bit transfer. An STM32F0xx running at 48 MHz will have a room of only 77 cycles to process an Interrupt. However, calling an interrupt takes 12 cycle, exiting an interrupt costs 10 cycles (ideal state without waiting). Therefore, an interrupt code must be served in only 55 cycles ! Should use DMA when the bit rate is high, because DMA only causes 2 interrupts: \u201cHalf-transfer\u201d and \u201cTransfer-Complete\u201d in a routine of transfer a large data buffer.","title":"2.5. Bitmap &amp; Font &amp; String"},{"location":"blog/stm32/prepare/","text":"Always use original products when you can afford to buy! 1. Development boards \u2693\ufe0e There are many boards available in the market, which are from the ST, or from a 3 rd party company, or just from a seller. Here are the list of some popular boards for beginners, as they are cheap and easy to buy from a retailer. 1.1. STM32 Nucleo boards \u2693\ufe0e These boards come with a cheap price and an integrated ST-LINK debugger. The advantages of this Nucleo board line is to have access directly to all GPIOs, and to have compliant Arduino connector. Many users who are familiar with Arduino like to use Nucleo boards, because they can keep using these STM32 boards as an Arduino. Starter boards can be: Nucleo-F103RB Nucleo-F401RE/F411RE Nucleo-F103RB Nucleo-H743 1.2. STM32 Discovery kits \u2693\ufe0e This line of board allows either for beginner or for experienced users to get started on new projects. These boards are cheap, and have complete solutions for demonstrating the capabilities of the devices. Some boards come with many peripherals such as LCD, MEM sensors, touchpad. They also have integrated ST-LINK debugger/ programmer. Starter boards can be: STM32F072-Discovery STM32F429-Discovery STM32F072-Discovery STM32F429-Discovery 1.3. Evaluation board \u2693\ufe0e The STM32 Evaluation boards have been designed as a complete demonstration and development platform for the STM32 MCUs and MPUs. They are meant to be used to execute a comprehensive evaluation of ST Microelectronics solutions. These boards have integrated ST-LINK debugger/ programmer. They carry external circuitry, such as transceivers, sensors, memory interfaces, displays and many more. The evaluation boards can be considered as a reference design for application development. Starter boards can be: STM32L476-EVAL STM32F407-EVAL STM32L476-EVAL STM32F407-EVAL 1.4. Custom board \u2693\ufe0e Many users still find that the price of original boards is still high. There are many clones which use either authorized MCUs or even fake ones, with reduced peripherals. They are usually customized to different starter boards in small size and just USB and debugging pins. The popular custom boards are \u201cBlue Pills\u201d STM32F103, and \u201cBlack Pills\u201d STM32F4x1. They are cheap and have many exposed pins. There is no debugger or programmer in these custom boards. Users have to use an external one, such as ST-LINK or J-LINK. A blue pill STM32F103 A black pill STM32Fx1 Power conflict On a custom board, there may be no power protection circuit added, therefore, do not connect 3.3V power pin of the debugger if the USB port is plugged because the USB port already powers the board with 5V. Counterfeit chip There are counterfeit chips on the market that are blocked to work with ST-Link/ J-Link to flash and debug. Please make sure to not buy them, even there is a method to workaround with OpenOCD. 2. Programmer & Debugger \u2693\ufe0e Programmer is used to write application code into MCU. It can read the application and make a copy of the firmware. Debugger is used to read CPU registers, memory, and logging data to help developers see how application runs. It can halt the CPU too. In monitoring mode, it lets CPU run and read memory in background through some special channels to gather information of application and system in real-time. 2.1. ST-LINK \u2693\ufe0e All official boards from ST have integrated ST-Link debugger / programmer in version 2 or 3. They work on a Serial Wire Debug (SWD) interface. ST-Link comes with good performance and some extra feature such as Serial Wire Output (SWO), Virtual COM port, Mass-storage for drag-and-drop programming. On custom boards, there is no on-board debugger, so that an external debugger is needed. There are both original and clone version in the market. Original ST-LINK/V2 A clone of ST-LINK/V2 Missing SWO pin on ST-LINK clones Many ST-LINK clones only expose SWD interface (SWCLK and SWDIO). The pin for SWO is not exposed. There is a quick fix for this problem: wire the PA10 of the on-board STM32 chip to a pin on the header. Read more in Add SWO pin . 2.2. J-LINK \u2693\ufe0e One of a popular debugger manufacturer is SEGGER . They provide many tools for embedded systems. Their J-Link is quite expensive but comes with a lot of high performance features beside standard ones in ST-LINK, such as Real-time logging, system view, profiling. There are also cloned J-Link devices which are actually an STM32F0 MCU running a SEGGER firmware but have limitation in features due to missing hardware component and license. One interesting thing is SEGGER provides a tool to convert ST-LINK/V2 to a J-LINK OB model with some small limitations. J-Link Pro Cloned J-Link OB 3. Power Supplier \u2693\ufe0e There are many ways to power the board. Always check the Voltage and the Maximum Current of the power source. During the development, the board should be powered through the debugger which connects to PC via a USB port. If there is another on-board USB port connecting to PC, do not use power pin on the debugger. In the final production, the board will run without a debugger connected to a host PC, the power can be connected to the USB port or the power pins directly. A portable power source can be a Power bank, or a Li-Po battery. Also keep in mind that if the board would occasionally go to sleep state and the consumption current drops below 50 \u2013 70 mA, many power banks would drop the supply, so the system will shut down catastrophically. 4. Logic Analyzer (optional) \u2693\ufe0e A Logic Analyzer can capture (and display) multiple signals on a system. The output can be visualized in timing diagrams, and then analyzed or decoded to get detailed information about the signal or the protocol and data. There are small portable Logic Analyzers which just do capturing data, and then the captured data is transferred to a host PC via USB. Finally, the data is visualized by an application. Saleae Logic Cloned Logic","title":"Preparation"},{"location":"blog/stm32/prepare/#1-development-boards","text":"There are many boards available in the market, which are from the ST, or from a 3 rd party company, or just from a seller. Here are the list of some popular boards for beginners, as they are cheap and easy to buy from a retailer.","title":"1. Development boards"},{"location":"blog/stm32/prepare/#11-stm32-nucleo-boards","text":"These boards come with a cheap price and an integrated ST-LINK debugger. The advantages of this Nucleo board line is to have access directly to all GPIOs, and to have compliant Arduino connector. Many users who are familiar with Arduino like to use Nucleo boards, because they can keep using these STM32 boards as an Arduino. Starter boards can be: Nucleo-F103RB Nucleo-F401RE/F411RE Nucleo-F103RB Nucleo-H743","title":"1.1. STM32 Nucleo boards"},{"location":"blog/stm32/prepare/#12-stm32-discovery-kits","text":"This line of board allows either for beginner or for experienced users to get started on new projects. These boards are cheap, and have complete solutions for demonstrating the capabilities of the devices. Some boards come with many peripherals such as LCD, MEM sensors, touchpad. They also have integrated ST-LINK debugger/ programmer. Starter boards can be: STM32F072-Discovery STM32F429-Discovery STM32F072-Discovery STM32F429-Discovery","title":"1.2. STM32 Discovery kits"},{"location":"blog/stm32/prepare/#13-evaluation-board","text":"The STM32 Evaluation boards have been designed as a complete demonstration and development platform for the STM32 MCUs and MPUs. They are meant to be used to execute a comprehensive evaluation of ST Microelectronics solutions. These boards have integrated ST-LINK debugger/ programmer. They carry external circuitry, such as transceivers, sensors, memory interfaces, displays and many more. The evaluation boards can be considered as a reference design for application development. Starter boards can be: STM32L476-EVAL STM32F407-EVAL STM32L476-EVAL STM32F407-EVAL","title":"1.3. Evaluation board"},{"location":"blog/stm32/prepare/#14-custom-board","text":"Many users still find that the price of original boards is still high. There are many clones which use either authorized MCUs or even fake ones, with reduced peripherals. They are usually customized to different starter boards in small size and just USB and debugging pins. The popular custom boards are \u201cBlue Pills\u201d STM32F103, and \u201cBlack Pills\u201d STM32F4x1. They are cheap and have many exposed pins. There is no debugger or programmer in these custom boards. Users have to use an external one, such as ST-LINK or J-LINK. A blue pill STM32F103 A black pill STM32Fx1 Power conflict On a custom board, there may be no power protection circuit added, therefore, do not connect 3.3V power pin of the debugger if the USB port is plugged because the USB port already powers the board with 5V. Counterfeit chip There are counterfeit chips on the market that are blocked to work with ST-Link/ J-Link to flash and debug. Please make sure to not buy them, even there is a method to workaround with OpenOCD.","title":"1.4. Custom board"},{"location":"blog/stm32/prepare/#2-programmer--debugger","text":"Programmer is used to write application code into MCU. It can read the application and make a copy of the firmware. Debugger is used to read CPU registers, memory, and logging data to help developers see how application runs. It can halt the CPU too. In monitoring mode, it lets CPU run and read memory in background through some special channels to gather information of application and system in real-time.","title":"2. Programmer &amp; Debugger"},{"location":"blog/stm32/prepare/#21-st-link","text":"All official boards from ST have integrated ST-Link debugger / programmer in version 2 or 3. They work on a Serial Wire Debug (SWD) interface. ST-Link comes with good performance and some extra feature such as Serial Wire Output (SWO), Virtual COM port, Mass-storage for drag-and-drop programming. On custom boards, there is no on-board debugger, so that an external debugger is needed. There are both original and clone version in the market. Original ST-LINK/V2 A clone of ST-LINK/V2 Missing SWO pin on ST-LINK clones Many ST-LINK clones only expose SWD interface (SWCLK and SWDIO). The pin for SWO is not exposed. There is a quick fix for this problem: wire the PA10 of the on-board STM32 chip to a pin on the header. Read more in Add SWO pin .","title":"2.1. ST-LINK"},{"location":"blog/stm32/prepare/#22-j-link","text":"One of a popular debugger manufacturer is SEGGER . They provide many tools for embedded systems. Their J-Link is quite expensive but comes with a lot of high performance features beside standard ones in ST-LINK, such as Real-time logging, system view, profiling. There are also cloned J-Link devices which are actually an STM32F0 MCU running a SEGGER firmware but have limitation in features due to missing hardware component and license. One interesting thing is SEGGER provides a tool to convert ST-LINK/V2 to a J-LINK OB model with some small limitations. J-Link Pro Cloned J-Link OB","title":"2.2. J-LINK"},{"location":"blog/stm32/prepare/#3-power-supplier","text":"There are many ways to power the board. Always check the Voltage and the Maximum Current of the power source. During the development, the board should be powered through the debugger which connects to PC via a USB port. If there is another on-board USB port connecting to PC, do not use power pin on the debugger. In the final production, the board will run without a debugger connected to a host PC, the power can be connected to the USB port or the power pins directly. A portable power source can be a Power bank, or a Li-Po battery. Also keep in mind that if the board would occasionally go to sleep state and the consumption current drops below 50 \u2013 70 mA, many power banks would drop the supply, so the system will shut down catastrophically.","title":"3. Power Supplier"},{"location":"blog/stm32/prepare/#4-logic-analyzer-optional","text":"A Logic Analyzer can capture (and display) multiple signals on a system. The output can be visualized in timing diagrams, and then analyzed or decoded to get detailed information about the signal or the protocol and data. There are small portable Logic Analyzers which just do capturing data, and then the captured data is transferred to a host PC via USB. Finally, the data is visualized by an application. Saleae Logic Cloned Logic","title":"4. Logic Analyzer (optional)"},{"location":"blog/stm32/semihosting/","text":"SemiHosting SemiHosting setup Connect a debugger via SWD interface Include SemiHosting lib in GCC linker -l rdimon --specs=rdimon.specs Exclude the default syscall.c implementation Initialize in the startup of the application with initialise_monitor_handles(); Run OpenOCD with command monitor arm SemiHosting enable SemiHosting notes SemiHosting implementation in OpenOCD is designed so that every string must be terminated with the newline character \\n before the string appears on the OpenOCD console. SemiHosting only works during a debug session, and it\u2019s slow and affects the system performance. CPU is halt when SemiHosting is executing in host machine, therefore SemiHosting is not suitable for realtime application. 1. Debugging \u2693\ufe0e There are some debug techniques used to inspect the firmware running on ARM-based MCUs: SemiHosting : built-in to every ARM chips, need adding additional library and running in debug mode Redirection : forward to a UART port but need using GPIO and extra hardware (USB to Serial converter), or forward to a Virtual COM port but need a USB peripheral Serial Wire View (SWV) : fast output over dedicated Single Wire Output (SWO) pin, but it\u2019s only available on Cortex-M3+, and this is uni-direction communication. Real Time Transfer (RTT) : extremely fast but only work with SEGGER Debugger, can have a real-time bi-direction communication. Ways to print debug 2. SemiHosting \u2693\ufe0e ARM SemiHosting is a distinctive feature of the ARM platform, that allows to use input and output functions on a host computer that get forwarded to the microcontrollers over a hardware debugger, such as printf() and scanf() , or even fopen() . SemiHosting is implemented by a set of defined software instructions, for example, SVC , that generate exceptions from program control. The application invokes the appropriate SemiHosting call and the debugger then handles the exception by communicating with the debugging application on the host computer. ARM processors prior to ARMv7 use the SVC instructions, formerly known as SWI instructions, to make SemiHosting calls. However, for an ARMv6-M or ARMv7-M, in a Cortex-M1 or Cortex-M3 processor, SemiHosting is implemented using the BKPT instruction. SemiHosting overview 2.1. Hardware setup \u2693\ufe0e SemiHosting need to be run under a debug session to communicate with SemiHosting-enabled debugger. In STM32, debugging channel maybe ST-LINK debugger (onboard, or external) which connects to the MCU via SWCLK and SWDIO in the SWD interface. In the STM32CubeMX, under the Pinout and Configuration tab, select the SYS module and check on the Debug Serial Wire option to assign the Debug function on pins PA14 and PA13 . Enable Serial Wire Debug pins 2.2. Software setup \u2693\ufe0e To use SemiHosting, it has to be set in linker options, and initialized in the main program. 2.2.1. Linker options \u2693\ufe0e GNU ARM libraries use newlib to provide standard implementation of C libraries. However, to reduce the code size and make it independent to hardware, there is a lightweight version newlib-nano used in MCUs. However, newlib-nano does not provide an implementation of low-level system calls which are used by C standard libraries, such as print() or scan() . To make the application compilable, a new library named nosys should be added. This library just provide a simple implementation of low-level system calls which mostly return a by-pass value. The lib newlib-nano is enabled via linker options --specs=nano.specs , and nosys is enabled via linker option --specs=nosys.specs . These two libs are included by default in GCC linker options in generated project. There is a rdimon library that implements interrupt for some special system calls, which pauses the processor and interact with debugger host to exchange data, such as SYS_WRITE (0x05) or SYS_READ (0x06) . This library provides low-level system calls to handling the newlib-nano specs. The lib rdimon is enabled via linker option --specs=rdimon.specs -l rdimon Example of using GUI config: Open Project Properties \u00bb C/C++ Build \u00bb Settings \u00bb Tool Settings tab \u00bb MCU GCC Linker : Libraries: add rdimon Miscellaneous flags: add --specs=rdimon.specs 2.2.2. Exclude user system calls \u2693\ufe0e In addition, STM32CubeIDE automatically generates syscalls.c with a simple implementation for nosys.specs . Must exclude syscalls.c from build to avoid compilation error of multiple definitions . Add SemiHosting in GCC Linker Exclude syscalls.c 2.2.3. Initialize SemiHosting \u2693\ufe0e The rdimon library has to be initialized before it can run properly. It exposes a function to do that, then use it: extern void initialise_monitor_handles ( void ); in the main() function: int main ( void ) { initialise_monitor_handles (); } After that, the application can use printf() , scanf() , or gets() . 2.3. Debugger option \u2693\ufe0e The final thing is to enable SemiHosting on debugger that will handle the interruption fired from MCUs. Debugger has to communicate with MCUs and the host computer. In some cases, it has to use Software Reset method to help debugger reset the target MCU. Use ST-LINK over OpenOCD with the start-up command: monitor arm SemiHosting enable Enable SemiHosting in debugger 3. Debug with SemiHosting \u2693\ufe0e Run the project in debug mode and then interact with MCUs. Here are some lines of code to print a message, get a string, and write to a file on the host machine: main.c #include \"main.h\" #include <stdio.h> #include <string.h> uint8_t counter = 0 ; char buffer [ 255 ]; extern void initialise_monitor_handles ( void ); int main ( void ) { initialise_monitor_handles (); printf ( \"Please enter your name: \\n \" ); gets ( buffer ); printf ( \" \\n Ah, I know you, %s! \\n \" , buffer ); // test.out will be created in the host machine FILE * fd = fopen ( \"D: \\\\ test.out\" , \"w+\" ); if ( fd ) { fwrite ( buffer , sizeof ( char ), strlen ( buffer ), fd ); fclose ( fd ); } while ( 1 ) { printf ( \"counter = %d \\n \" , counter ++ ); HAL_Delay ( 1000 ); } } When using fopen() , should specify the location, such as ~/test.out on Linux or D:\\\\test.out on Windows , if not, the target file will be created in the folder containing the openocd.exe program. Interact with SemiHosting","title":"SemiHosting"},{"location":"blog/stm32/semihosting/#1-debugging","text":"There are some debug techniques used to inspect the firmware running on ARM-based MCUs: SemiHosting : built-in to every ARM chips, need adding additional library and running in debug mode Redirection : forward to a UART port but need using GPIO and extra hardware (USB to Serial converter), or forward to a Virtual COM port but need a USB peripheral Serial Wire View (SWV) : fast output over dedicated Single Wire Output (SWO) pin, but it\u2019s only available on Cortex-M3+, and this is uni-direction communication. Real Time Transfer (RTT) : extremely fast but only work with SEGGER Debugger, can have a real-time bi-direction communication. Ways to print debug","title":"1. Debugging"},{"location":"blog/stm32/semihosting/#2-semihosting","text":"ARM SemiHosting is a distinctive feature of the ARM platform, that allows to use input and output functions on a host computer that get forwarded to the microcontrollers over a hardware debugger, such as printf() and scanf() , or even fopen() . SemiHosting is implemented by a set of defined software instructions, for example, SVC , that generate exceptions from program control. The application invokes the appropriate SemiHosting call and the debugger then handles the exception by communicating with the debugging application on the host computer. ARM processors prior to ARMv7 use the SVC instructions, formerly known as SWI instructions, to make SemiHosting calls. However, for an ARMv6-M or ARMv7-M, in a Cortex-M1 or Cortex-M3 processor, SemiHosting is implemented using the BKPT instruction. SemiHosting overview","title":"2. SemiHosting"},{"location":"blog/stm32/semihosting/#21-hardware-setup","text":"SemiHosting need to be run under a debug session to communicate with SemiHosting-enabled debugger. In STM32, debugging channel maybe ST-LINK debugger (onboard, or external) which connects to the MCU via SWCLK and SWDIO in the SWD interface. In the STM32CubeMX, under the Pinout and Configuration tab, select the SYS module and check on the Debug Serial Wire option to assign the Debug function on pins PA14 and PA13 . Enable Serial Wire Debug pins","title":"2.1. Hardware setup"},{"location":"blog/stm32/semihosting/#22-software-setup","text":"To use SemiHosting, it has to be set in linker options, and initialized in the main program.","title":"2.2. Software setup"},{"location":"blog/stm32/semihosting/#221-linker-options","text":"GNU ARM libraries use newlib to provide standard implementation of C libraries. However, to reduce the code size and make it independent to hardware, there is a lightweight version newlib-nano used in MCUs. However, newlib-nano does not provide an implementation of low-level system calls which are used by C standard libraries, such as print() or scan() . To make the application compilable, a new library named nosys should be added. This library just provide a simple implementation of low-level system calls which mostly return a by-pass value. The lib newlib-nano is enabled via linker options --specs=nano.specs , and nosys is enabled via linker option --specs=nosys.specs . These two libs are included by default in GCC linker options in generated project. There is a rdimon library that implements interrupt for some special system calls, which pauses the processor and interact with debugger host to exchange data, such as SYS_WRITE (0x05) or SYS_READ (0x06) . This library provides low-level system calls to handling the newlib-nano specs. The lib rdimon is enabled via linker option --specs=rdimon.specs -l rdimon Example of using GUI config: Open Project Properties \u00bb C/C++ Build \u00bb Settings \u00bb Tool Settings tab \u00bb MCU GCC Linker : Libraries: add rdimon Miscellaneous flags: add --specs=rdimon.specs","title":"2.2.1. Linker options"},{"location":"blog/stm32/semihosting/#222-exclude-user-system-calls","text":"In addition, STM32CubeIDE automatically generates syscalls.c with a simple implementation for nosys.specs . Must exclude syscalls.c from build to avoid compilation error of multiple definitions . Add SemiHosting in GCC Linker Exclude syscalls.c","title":"2.2.2. Exclude user system calls"},{"location":"blog/stm32/semihosting/#223-initialize-semihosting","text":"The rdimon library has to be initialized before it can run properly. It exposes a function to do that, then use it: extern void initialise_monitor_handles ( void ); in the main() function: int main ( void ) { initialise_monitor_handles (); } After that, the application can use printf() , scanf() , or gets() .","title":"2.2.3. Initialize SemiHosting"},{"location":"blog/stm32/semihosting/#23-debugger-option","text":"The final thing is to enable SemiHosting on debugger that will handle the interruption fired from MCUs. Debugger has to communicate with MCUs and the host computer. In some cases, it has to use Software Reset method to help debugger reset the target MCU. Use ST-LINK over OpenOCD with the start-up command: monitor arm SemiHosting enable Enable SemiHosting in debugger","title":"2.3. Debugger option"},{"location":"blog/stm32/semihosting/#3-debug-with-semihosting","text":"Run the project in debug mode and then interact with MCUs. Here are some lines of code to print a message, get a string, and write to a file on the host machine: main.c #include \"main.h\" #include <stdio.h> #include <string.h> uint8_t counter = 0 ; char buffer [ 255 ]; extern void initialise_monitor_handles ( void ); int main ( void ) { initialise_monitor_handles (); printf ( \"Please enter your name: \\n \" ); gets ( buffer ); printf ( \" \\n Ah, I know you, %s! \\n \" , buffer ); // test.out will be created in the host machine FILE * fd = fopen ( \"D: \\\\ test.out\" , \"w+\" ); if ( fd ) { fwrite ( buffer , sizeof ( char ), strlen ( buffer ), fd ); fclose ( fd ); } while ( 1 ) { printf ( \"counter = %d \\n \" , counter ++ ); HAL_Delay ( 1000 ); } } When using fopen() , should specify the location, such as ~/test.out on Linux or D:\\\\test.out on Windows , if not, the target file will be created in the folder containing the openocd.exe program. Interact with SemiHosting","title":"3. Debug with SemiHosting"},{"location":"blog/stm32/sensor-us-100/","text":"US-100 UART mode Us-100 Pulse width mode using Timer Input Capture 1. US-100 Ultrasonic sensor \u2693\ufe0e The US-100 Ultrasonic sensor is very similar to the popular HC-SR04, and even looks the same, but has a few extra tricks: Can run from 3V to 5V, so don\u2019t need any logic level shifters or dividers. Can use in \u201cPulse\u201d mode (like on HC-SR04) or in \u201cSerial UART\u201d mode. Range is about 2 cm to 450 cm away, but 10 cm to 250 cm will get the best results Ultrasonic sensor US-100 When the jumper is in place, use a 9600-baud UART to communicate with the sensor: Send 0x55 and read back two bytes (16 bit value) that is mm distance Send 0x50 to read the temperature in degrees C, with an offset of -45 degrees This mode works directly with a PC USB to Serial adapter. When the jumper on the back is removed, it acts like an HC-SR04 with a trigger and echo pin: The width of echo pulse is the time it takes for the ultrasonic sound to travel from the sensor to the object and back. No temperature data is read out using the Pulse mode Debug on UART1 using Redirection For more convenient, below labs use UART Redirection technique to use the UART1 as the debug terminal, and use standard printf() function to output messages. 2. Lab 1: UART mode \u2693\ufe0e The UART2 interface is used to communicate with US-100. As mentioned in the US-100 specification, the UART should be at 9600 baud-rate, 8 bit, N o parity, and 1 bit stop. Note to use the interrupt mode to receive data . MCU Pin US-100 Pin PA2 (UART2TX) Trigger/TX PA3 (UART2RX) Echo/RX Create variable to hold the states, trial counter, commands, and returned value: enum { IDLE , WAIT_DIST , CALC_DIST , WAIT_TEMP , CALC_TEMP }; char state = IDLE ; char try = 0 ; uint16_t value = 0 ; uint8_t cmd_dist [] = { 0x55 }; uint8_t cmd_temp [] = { 0x50 }; uint8_t buffer [ 2 ] = { 0 }; Then, in the main loop, process each state, note to use interrupt mode to receive data: int main ( void ) { while ( 1 ) { if ( state == IDLE ) { // send request to measure distance printf ( \"D? \\n\\r \" ); HAL_UART_Transmit ( US_100 , cmd_dist , 1 , HAL_MAX_DELAY ); HAL_UART_Receive_IT ( US_100 , buffer , 2 ); // change state state = WAIT_DIST ; try = 0 ; } else if ( state == CALC_DIST ) { // calculate distance value = ( buffer [ 0 ] << 8 ) + buffer [ 1 ]; printf ( \"D = %d mm \\n\\r \" , value ); // send request to get temperature printf ( \"T? \\n\\r \" ); HAL_UART_Transmit ( US_100 , cmd_temp , 1 , HAL_MAX_DELAY ); HAL_UART_Receive_IT ( US_100 , buffer , 1 ); // change state state = WAIT_TEMP ; try = 0 ; } else if ( state == CALC_TEMP ){ // calculate temperature value = buffer [ 0 ] - 45 ; printf ( \"T = %d \\n\\r \" , value ); // change state state = IDLE ; try = 0 ; } HAL_Delay ( 100 ); // retry after 5 seconds if ( ++ try >= 50 ) { printf ( \"Re-try \\n\\r \" ); state = IDLE ; } } } Finally, handle the interrupt callback by checking the state and set new state for the main loop: void HAL_UART_RxCpltCallback ( UART_HandleTypeDef * huart ) { if ( huart == US_100 ) { if ( state == WAIT_DIST ) { state = CALC_DIST ; } else if ( state == WAIT_TEMP ) { state = CALC_TEMP ; } } } Compile and run on the board, use a logic analyzer to check how fast the US-100 can response for each command, and here is the result: Distance response time: < 10 ms Temperature response time: < 5 ms Output of US-100 And on the debug terminal, the distance and temperature are printed in decimal value: Print output on terminal 3. Lab 2: Pulse mode \u2693\ufe0e Triggering the sensor to start operation is done by sending a short pulse to the TRIGGER pin, and it should be anything wider than 5uS. It can be even a few milliseconds. The module sends an ultrasonic signal, eight pulses of 40kHz square wave from the transmitter; the echo is then picked up by the receiver and outputs a waveform with a time period proportional to the distance. The echo response pulse corresponds to the time it takes for the ultrasonic sound to travel from the sensor to the object and back. Hence, the distance is computed as: Distance = Pulse Width * Speed of Sound / 2 (m) The actual speed of sound depends on the several environment factors, with temperature having most pronounced effect: Speed of Sound = 331.4 + 0.6T (m/s) US-100 has built-in temperature compensation, so the distance formula is reduced to: Distance = Pulse width * 165.7 (m) The pulse with is calculated by the timer counter divided by the counting frequency: Pulse width = Timer counter / Frequency Therefore, the final equation is: Distance = Timer counter / Frequency * 165.7 (m) = Timer counter * 165700 / Frequency (mm) 3.1. Methods to read a pulse width. \u2693\ufe0e GPIO Polling + Timer A very basic technique is to keep polling a GPIO input pin. The MCU will keep waiting until this pin goes HIGH, then it turns ON a timer module to start counting. And keep polling the input pin until it goes LOW, then the timer is turned OFF. The timer counter value will tell the echo pulse width. Polling the GPIO input pin is a time-wasting procedure that has a potential risk of freezing the entire system in case of sensor failure or whatever. Ext Interrupt + Timer An EXTI pin will be set to wait for a raising edge to start an internal timer. After the edge is captured, that will be set to wait for falling edge, while timer is counting. The 2 nd interrupt will stop the timer, and the timer counter value will tell the echo pulse width. Timer Input Capture Use a Timer with Input Capture mode to capture the timer value at the rising edge of the input pin, then capture the timer value at the falling edge. The different value will tell the echo pulse width. Differential Double Input Capture When measuring extremely short pulses, differential double IC provides accuracy and precision. Use 2 ICU channels: one triggers on the rising edge and the other triggers on the falling edge. The different value will tell the echo pulse width. Timer Gate-Controlled One technique that also works really well in extremely short pulse measurements is timer gate-controlled. In this specific mode, the timer is allowed to count only when the gate is activated. The gate is driven by the input pin connected to the echo pin. The timer counter value will tell the echo pulse width. 3.2. Use Input Capture \u2693\ufe0e This method will use the TIM1 with Input Capture on the Channel 1. Here are steps to capture the Echo pulse: Enable TIM1 using Internal Clock source, Enable Input Capture on Channel 1 For the best resolution, do not set the Pre-scaler, and let timers counts in full range of 16-bit Set the capture edge at the Rising edge Start TIM1, Start Input Capture on Channel 1 in Interrupt mode When Echo pulse goes high, handle the interrupt: Save the timer counter to T1 Set the capture edge at the Falling edge When Echo pulse goes low, handle the interrupt: Save the timer counter to T2 Different time is the width of the pulse Distance is calculated based on the pulse width and the tick interval of the clock Set the capture edge at the Rising edge to capture another pulse 3.2.1. Enable Timer and Input Capture \u2693\ufe0e Using IDE to enable the TIM1 in system peripherals: Select internal clock source, and choose Channel 1 to Input Capture direct mode , which also captures a Rising edge at startup. Enable interrupts for both break, update, trigger, communication and capture compare Setup Timer with Input Capture The pin wiring also needs to change: MCU Pin US-100 Pin PA1 (Output) Trigger/TX PA8 (TIM1_CH1 input capture) Echo/RX PC9 (Output) Timer Capture PC8 (Output) Timer Overflow 3.2.2. Generated code \u2693\ufe0e The function MX_TIM1_Init() is generated with below steps to set up the selected configs: Initialize TIM1 Base, including Pre-scaler, Counter Period, and Auto-Reload Select the clock source Initialize Input Capture mode and its settings: polarity, edge, filter static void MX_TIM1_Init ( void ) { TIM_ClockConfigTypeDef sClockSourceConfig = { 0 }; TIM_MasterConfigTypeDef sMasterConfig = { 0 }; TIM_IC_InitTypeDef sConfigIC = { 0 }; htim1 . Instance = TIM1 ; htim1 . Init . Prescaler = 0 ; htim1 . Init . CounterMode = TIM_COUNTERMODE_UP ; htim1 . Init . Period = 65535 ; htim1 . Init . ClockDivision = TIM_CLOCKDIVISION_DIV1 ; htim1 . Init . RepetitionCounter = 0 ; htim1 . Init . AutoReloadPreload = TIM_AUTORELOAD_PRELOAD_ENABLE ; if ( HAL_TIM_Base_Init ( & htim1 ) != HAL_OK ) { Error_Handler (); } sClockSourceConfig . ClockSource = TIM_CLOCKSOURCE_INTERNAL ; if ( HAL_TIM_ConfigClockSource ( & htim1 , & sClockSourceConfig ) != HAL_OK ) { Error_Handler (); } if ( HAL_TIM_IC_Init ( & htim1 ) != HAL_OK ) { Error_Handler (); } sMasterConfig . MasterOutputTrigger = TIM_TRGO_RESET ; sMasterConfig . MasterSlaveMode = TIM_MASTERSLAVEMODE_DISABLE ; if ( HAL_TIMEx_MasterConfigSynchronization ( & htim1 , & sMasterConfig ) != HAL_OK ) { Error_Handler (); } sConfigIC . ICPolarity = TIM_INPUTCHANNELPOLARITY_RISING ; sConfigIC . ICSelection = TIM_ICSELECTION_DIRECTTI ; sConfigIC . ICPrescaler = TIM_ICPSC_DIV1 ; sConfigIC . ICFilter = 0 ; if ( HAL_TIM_IC_ConfigChannel ( & htim1 , & sConfigIC , TIM_CHANNEL_1 ) != HAL_OK ) { Error_Handler (); } } Two interrupt handlers are generated too, TIM1_BRK_UP_TRG_COM_IRQHandler() and TIM1_CC_IRQHandler() which will call to: HAL_TIM_IC_CaptureCallback() : interrupt when input capture meets the capture edge HAL_TIM_PeriodElapsedCallback() : interrupt when counter finishes one cycle (from 0 to Auto-Reload value) 3.2.3. User code \u2693\ufe0e There are some variables to hold the system states, timer counter values, and distance value. enum { IDLE , WAIT , CALC }; int state = IDLE ; int try = 0 ; uint32_t T1 = 0 ; uint32_t T2 = 0 ; uint32_t overflow = 0 ; uint32_t period = 0 ; uint32_t counter = 0 ; uint32_t distance = 0 ; char edge = 1 ; // raising In the main() function, save the clock period, and start both base timer\u2019s interrupt and input capture\u2019s interrupt: int main () { period = __HAL_TIM_GET_AUTORELOAD ( & htim1 ); HAL_TIM_Base_Start_IT ( & htim1 ); // to get PeriodElapsedCallback HAL_TIM_IC_Start_IT ( & htim1 , TIM_CHANNEL_1 ); // to get IC_CaptureCallback while ( 1 ) {...} } Save capture time Application has to handle interrupts to save timer counter at each edge, to get overflow counter, and set correct state of system. void HAL_TIM_IC_CaptureCallback ( TIM_HandleTypeDef * htim ) { if ( state == WAIT ) { if ( edge ) { T1 = HAL_TIM_ReadCapturedValue ( & htim1 , TIM_CHANNEL_1 ); __HAL_TIM_SET_CAPTUREPOLARITY ( & htim1 , TIM_CHANNEL_1 , TIM_INPUTCHANNELPOLARITY_FALLING ); overflow = 0 ; // start check if timer is overflow } else { T2 = HAL_TIM_ReadCapturedValue ( & htim1 , TIM_CHANNEL_1 ); __HAL_TIM_SET_CAPTUREPOLARITY ( & htim1 , TIM_CHANNEL_1 , TIM_INPUTCHANNELPOLARITY_RISING ); state = CALC ; } edge = ! edge ; } HAL_GPIO_TogglePin ( LED_CC_GPIO_Port , LED_CC_Pin ); } void HAL_TIM_PeriodElapsedCallback ( TIM_HandleTypeDef * htim ) { if ( state == WAIT ) { overflow ++ ; } HAL_GPIO_TogglePin ( LED_OV_GPIO_Port , LED_OV_Pin ); } Main loop The main loop checks the current state and do corresponding actions. Overflow when calculating with big number In Embedded system, calculating with big number can cause overflow and returns wrong result. In this tutorial, timer counter is a 32-bit number, but when it is multiplied with 165700, it can cause overflow. Distance = Timer counter / Frequency * 165.7 (m) = Timer counter * 165700 / Frequency (mm) while ( 1 ) { if ( state == IDLE ) { // trigger HAL_GPIO_WritePin ( TRIGGER_GPIO_Port , TRIGGER_Pin , GPIO_PIN_SET ); HAL_Delay ( 1 ); HAL_GPIO_WritePin ( TRIGGER_GPIO_Port , TRIGGER_Pin , GPIO_PIN_RESET ); // change state state = WAIT ; try = 0 ; } else if ( state == CALC ) { // use overflow in case pulse occurs when timer counter is overflow T2 += overflow * period ; counter = T2 - T1 ; printf ( \"T = %lu ~ %lu us \\t \" , counter , counter * 1000 / 48000 ); // calc. distance distance = counter * 1657 ; distance /= ( SystemCoreClock / 100 ); printf ( \"D = %lu mm \\r\\n \" , distance ); // change state state = IDLE ; try = 0 ; } HAL_Delay ( 100 ); if ( ++ try > 10 ) { state = IDLE ; } } Toggling a pin helps showing when interrupts happen. Here is the output seen in a logic analyzer in a case that timer counter is overflow. Output of sensor is captured in timer Using an UART port to print the calculated distance in a terminal: Output of calculated distance","title":"US-100 Sensor"},{"location":"blog/stm32/sensor-us-100/#1-us-100-ultrasonic-sensor","text":"The US-100 Ultrasonic sensor is very similar to the popular HC-SR04, and even looks the same, but has a few extra tricks: Can run from 3V to 5V, so don\u2019t need any logic level shifters or dividers. Can use in \u201cPulse\u201d mode (like on HC-SR04) or in \u201cSerial UART\u201d mode. Range is about 2 cm to 450 cm away, but 10 cm to 250 cm will get the best results Ultrasonic sensor US-100 When the jumper is in place, use a 9600-baud UART to communicate with the sensor: Send 0x55 and read back two bytes (16 bit value) that is mm distance Send 0x50 to read the temperature in degrees C, with an offset of -45 degrees This mode works directly with a PC USB to Serial adapter. When the jumper on the back is removed, it acts like an HC-SR04 with a trigger and echo pin: The width of echo pulse is the time it takes for the ultrasonic sound to travel from the sensor to the object and back. No temperature data is read out using the Pulse mode Debug on UART1 using Redirection For more convenient, below labs use UART Redirection technique to use the UART1 as the debug terminal, and use standard printf() function to output messages.","title":"1. US-100 Ultrasonic sensor"},{"location":"blog/stm32/sensor-us-100/#2-lab-1-uart-mode","text":"The UART2 interface is used to communicate with US-100. As mentioned in the US-100 specification, the UART should be at 9600 baud-rate, 8 bit, N o parity, and 1 bit stop. Note to use the interrupt mode to receive data . MCU Pin US-100 Pin PA2 (UART2TX) Trigger/TX PA3 (UART2RX) Echo/RX Create variable to hold the states, trial counter, commands, and returned value: enum { IDLE , WAIT_DIST , CALC_DIST , WAIT_TEMP , CALC_TEMP }; char state = IDLE ; char try = 0 ; uint16_t value = 0 ; uint8_t cmd_dist [] = { 0x55 }; uint8_t cmd_temp [] = { 0x50 }; uint8_t buffer [ 2 ] = { 0 }; Then, in the main loop, process each state, note to use interrupt mode to receive data: int main ( void ) { while ( 1 ) { if ( state == IDLE ) { // send request to measure distance printf ( \"D? \\n\\r \" ); HAL_UART_Transmit ( US_100 , cmd_dist , 1 , HAL_MAX_DELAY ); HAL_UART_Receive_IT ( US_100 , buffer , 2 ); // change state state = WAIT_DIST ; try = 0 ; } else if ( state == CALC_DIST ) { // calculate distance value = ( buffer [ 0 ] << 8 ) + buffer [ 1 ]; printf ( \"D = %d mm \\n\\r \" , value ); // send request to get temperature printf ( \"T? \\n\\r \" ); HAL_UART_Transmit ( US_100 , cmd_temp , 1 , HAL_MAX_DELAY ); HAL_UART_Receive_IT ( US_100 , buffer , 1 ); // change state state = WAIT_TEMP ; try = 0 ; } else if ( state == CALC_TEMP ){ // calculate temperature value = buffer [ 0 ] - 45 ; printf ( \"T = %d \\n\\r \" , value ); // change state state = IDLE ; try = 0 ; } HAL_Delay ( 100 ); // retry after 5 seconds if ( ++ try >= 50 ) { printf ( \"Re-try \\n\\r \" ); state = IDLE ; } } } Finally, handle the interrupt callback by checking the state and set new state for the main loop: void HAL_UART_RxCpltCallback ( UART_HandleTypeDef * huart ) { if ( huart == US_100 ) { if ( state == WAIT_DIST ) { state = CALC_DIST ; } else if ( state == WAIT_TEMP ) { state = CALC_TEMP ; } } } Compile and run on the board, use a logic analyzer to check how fast the US-100 can response for each command, and here is the result: Distance response time: < 10 ms Temperature response time: < 5 ms Output of US-100 And on the debug terminal, the distance and temperature are printed in decimal value: Print output on terminal","title":"2. Lab 1: UART mode"},{"location":"blog/stm32/sensor-us-100/#3-lab-2-pulse-mode","text":"Triggering the sensor to start operation is done by sending a short pulse to the TRIGGER pin, and it should be anything wider than 5uS. It can be even a few milliseconds. The module sends an ultrasonic signal, eight pulses of 40kHz square wave from the transmitter; the echo is then picked up by the receiver and outputs a waveform with a time period proportional to the distance. The echo response pulse corresponds to the time it takes for the ultrasonic sound to travel from the sensor to the object and back. Hence, the distance is computed as: Distance = Pulse Width * Speed of Sound / 2 (m) The actual speed of sound depends on the several environment factors, with temperature having most pronounced effect: Speed of Sound = 331.4 + 0.6T (m/s) US-100 has built-in temperature compensation, so the distance formula is reduced to: Distance = Pulse width * 165.7 (m) The pulse with is calculated by the timer counter divided by the counting frequency: Pulse width = Timer counter / Frequency Therefore, the final equation is: Distance = Timer counter / Frequency * 165.7 (m) = Timer counter * 165700 / Frequency (mm)","title":"3. Lab 2: Pulse mode"},{"location":"blog/stm32/sensor-us-100/#31-methods-to-read-a-pulse-width","text":"GPIO Polling + Timer A very basic technique is to keep polling a GPIO input pin. The MCU will keep waiting until this pin goes HIGH, then it turns ON a timer module to start counting. And keep polling the input pin until it goes LOW, then the timer is turned OFF. The timer counter value will tell the echo pulse width. Polling the GPIO input pin is a time-wasting procedure that has a potential risk of freezing the entire system in case of sensor failure or whatever. Ext Interrupt + Timer An EXTI pin will be set to wait for a raising edge to start an internal timer. After the edge is captured, that will be set to wait for falling edge, while timer is counting. The 2 nd interrupt will stop the timer, and the timer counter value will tell the echo pulse width. Timer Input Capture Use a Timer with Input Capture mode to capture the timer value at the rising edge of the input pin, then capture the timer value at the falling edge. The different value will tell the echo pulse width. Differential Double Input Capture When measuring extremely short pulses, differential double IC provides accuracy and precision. Use 2 ICU channels: one triggers on the rising edge and the other triggers on the falling edge. The different value will tell the echo pulse width. Timer Gate-Controlled One technique that also works really well in extremely short pulse measurements is timer gate-controlled. In this specific mode, the timer is allowed to count only when the gate is activated. The gate is driven by the input pin connected to the echo pin. The timer counter value will tell the echo pulse width.","title":"3.1. Methods to read a pulse width."},{"location":"blog/stm32/sensor-us-100/#32-use-input-capture","text":"This method will use the TIM1 with Input Capture on the Channel 1. Here are steps to capture the Echo pulse: Enable TIM1 using Internal Clock source, Enable Input Capture on Channel 1 For the best resolution, do not set the Pre-scaler, and let timers counts in full range of 16-bit Set the capture edge at the Rising edge Start TIM1, Start Input Capture on Channel 1 in Interrupt mode When Echo pulse goes high, handle the interrupt: Save the timer counter to T1 Set the capture edge at the Falling edge When Echo pulse goes low, handle the interrupt: Save the timer counter to T2 Different time is the width of the pulse Distance is calculated based on the pulse width and the tick interval of the clock Set the capture edge at the Rising edge to capture another pulse","title":"3.2. Use Input Capture"},{"location":"blog/stm32/sensor-us-100/#321-enable-timer-and-input-capture","text":"Using IDE to enable the TIM1 in system peripherals: Select internal clock source, and choose Channel 1 to Input Capture direct mode , which also captures a Rising edge at startup. Enable interrupts for both break, update, trigger, communication and capture compare Setup Timer with Input Capture The pin wiring also needs to change: MCU Pin US-100 Pin PA1 (Output) Trigger/TX PA8 (TIM1_CH1 input capture) Echo/RX PC9 (Output) Timer Capture PC8 (Output) Timer Overflow","title":"3.2.1. Enable Timer and Input Capture"},{"location":"blog/stm32/sensor-us-100/#322-generated-code","text":"The function MX_TIM1_Init() is generated with below steps to set up the selected configs: Initialize TIM1 Base, including Pre-scaler, Counter Period, and Auto-Reload Select the clock source Initialize Input Capture mode and its settings: polarity, edge, filter static void MX_TIM1_Init ( void ) { TIM_ClockConfigTypeDef sClockSourceConfig = { 0 }; TIM_MasterConfigTypeDef sMasterConfig = { 0 }; TIM_IC_InitTypeDef sConfigIC = { 0 }; htim1 . Instance = TIM1 ; htim1 . Init . Prescaler = 0 ; htim1 . Init . CounterMode = TIM_COUNTERMODE_UP ; htim1 . Init . Period = 65535 ; htim1 . Init . ClockDivision = TIM_CLOCKDIVISION_DIV1 ; htim1 . Init . RepetitionCounter = 0 ; htim1 . Init . AutoReloadPreload = TIM_AUTORELOAD_PRELOAD_ENABLE ; if ( HAL_TIM_Base_Init ( & htim1 ) != HAL_OK ) { Error_Handler (); } sClockSourceConfig . ClockSource = TIM_CLOCKSOURCE_INTERNAL ; if ( HAL_TIM_ConfigClockSource ( & htim1 , & sClockSourceConfig ) != HAL_OK ) { Error_Handler (); } if ( HAL_TIM_IC_Init ( & htim1 ) != HAL_OK ) { Error_Handler (); } sMasterConfig . MasterOutputTrigger = TIM_TRGO_RESET ; sMasterConfig . MasterSlaveMode = TIM_MASTERSLAVEMODE_DISABLE ; if ( HAL_TIMEx_MasterConfigSynchronization ( & htim1 , & sMasterConfig ) != HAL_OK ) { Error_Handler (); } sConfigIC . ICPolarity = TIM_INPUTCHANNELPOLARITY_RISING ; sConfigIC . ICSelection = TIM_ICSELECTION_DIRECTTI ; sConfigIC . ICPrescaler = TIM_ICPSC_DIV1 ; sConfigIC . ICFilter = 0 ; if ( HAL_TIM_IC_ConfigChannel ( & htim1 , & sConfigIC , TIM_CHANNEL_1 ) != HAL_OK ) { Error_Handler (); } } Two interrupt handlers are generated too, TIM1_BRK_UP_TRG_COM_IRQHandler() and TIM1_CC_IRQHandler() which will call to: HAL_TIM_IC_CaptureCallback() : interrupt when input capture meets the capture edge HAL_TIM_PeriodElapsedCallback() : interrupt when counter finishes one cycle (from 0 to Auto-Reload value)","title":"3.2.2. Generated code"},{"location":"blog/stm32/sensor-us-100/#323-user-code","text":"There are some variables to hold the system states, timer counter values, and distance value. enum { IDLE , WAIT , CALC }; int state = IDLE ; int try = 0 ; uint32_t T1 = 0 ; uint32_t T2 = 0 ; uint32_t overflow = 0 ; uint32_t period = 0 ; uint32_t counter = 0 ; uint32_t distance = 0 ; char edge = 1 ; // raising In the main() function, save the clock period, and start both base timer\u2019s interrupt and input capture\u2019s interrupt: int main () { period = __HAL_TIM_GET_AUTORELOAD ( & htim1 ); HAL_TIM_Base_Start_IT ( & htim1 ); // to get PeriodElapsedCallback HAL_TIM_IC_Start_IT ( & htim1 , TIM_CHANNEL_1 ); // to get IC_CaptureCallback while ( 1 ) {...} } Save capture time Application has to handle interrupts to save timer counter at each edge, to get overflow counter, and set correct state of system. void HAL_TIM_IC_CaptureCallback ( TIM_HandleTypeDef * htim ) { if ( state == WAIT ) { if ( edge ) { T1 = HAL_TIM_ReadCapturedValue ( & htim1 , TIM_CHANNEL_1 ); __HAL_TIM_SET_CAPTUREPOLARITY ( & htim1 , TIM_CHANNEL_1 , TIM_INPUTCHANNELPOLARITY_FALLING ); overflow = 0 ; // start check if timer is overflow } else { T2 = HAL_TIM_ReadCapturedValue ( & htim1 , TIM_CHANNEL_1 ); __HAL_TIM_SET_CAPTUREPOLARITY ( & htim1 , TIM_CHANNEL_1 , TIM_INPUTCHANNELPOLARITY_RISING ); state = CALC ; } edge = ! edge ; } HAL_GPIO_TogglePin ( LED_CC_GPIO_Port , LED_CC_Pin ); } void HAL_TIM_PeriodElapsedCallback ( TIM_HandleTypeDef * htim ) { if ( state == WAIT ) { overflow ++ ; } HAL_GPIO_TogglePin ( LED_OV_GPIO_Port , LED_OV_Pin ); } Main loop The main loop checks the current state and do corresponding actions. Overflow when calculating with big number In Embedded system, calculating with big number can cause overflow and returns wrong result. In this tutorial, timer counter is a 32-bit number, but when it is multiplied with 165700, it can cause overflow. Distance = Timer counter / Frequency * 165.7 (m) = Timer counter * 165700 / Frequency (mm) while ( 1 ) { if ( state == IDLE ) { // trigger HAL_GPIO_WritePin ( TRIGGER_GPIO_Port , TRIGGER_Pin , GPIO_PIN_SET ); HAL_Delay ( 1 ); HAL_GPIO_WritePin ( TRIGGER_GPIO_Port , TRIGGER_Pin , GPIO_PIN_RESET ); // change state state = WAIT ; try = 0 ; } else if ( state == CALC ) { // use overflow in case pulse occurs when timer counter is overflow T2 += overflow * period ; counter = T2 - T1 ; printf ( \"T = %lu ~ %lu us \\t \" , counter , counter * 1000 / 48000 ); // calc. distance distance = counter * 1657 ; distance /= ( SystemCoreClock / 100 ); printf ( \"D = %lu mm \\r\\n \" , distance ); // change state state = IDLE ; try = 0 ; } HAL_Delay ( 100 ); if ( ++ try > 10 ) { state = IDLE ; } } Toggling a pin helps showing when interrupts happen. Here is the output seen in a logic analyzer in a case that timer counter is overflow. Output of sensor is captured in timer Using an UART port to print the calculated distance in a terminal: Output of calculated distance","title":"3.2.3. User code"},{"location":"blog/stm32/swv/","text":"Serial Wire Viewer 1. Serial Wire Viewer \u2693\ufe0e Cortex-M based microcontrollers integrate some debugging and tracing technologies, including JTAG and SWD. Tracing allows exporting in real-time internal activities performed by the CPU. The Instrumentation Trace MacroCell (ITM) allows sending software-generated debug messages through a specific signal I/O named Serial Wire Output (SWO). The protocol used by the SWO pin to exchange data with the debugger probe is called Serial Wire Viewer (SWV). The ITM support is available in Cortex-M3/M4/M7 microcontrollers Compared to other \u201cdebugging-alike\u201d peripherals like UART/VCOM redirection or the ARM SemiHosting , SWV is really fast. Its communication speed is proportional to the MCU speed. To properly decode the bytes sent over the SWO port, the host debugger needs to know the frequencies of CPU and SWO port. SWV protocol defines 32 different stimulus ports: a port is a \u201ctag\u201d on the SWV message used to enable/disable messages selectively. These channels allow for separating the diagnostic data into different categories. For instance, ARM recommends channel 0 for text data (e.g., from printf) and channel 31 for RTOS events, while the other channels can be used for any other purposes. 2. ITM Functions \u2693\ufe0e The ITM stimulus registers are standardized by ARM and found on address 0xE0000000 (port 0) through 0xE000007C (port 31). To write data, enable ITM tracing and write data to the corresponding register. The CMSIS-Core package for Cortex-M3/M4/M7 cores provides necessary glue to handle SWV protocol. For example, the ITM_SendChar() routines allows to send a character using the SWO pin. core_cm4.h __STATIC_INLINE int32_t ITM_ReceiveChar ( void ) { int32_t ch = -1 ; /* no character available */ if ( ITM_RxBuffer != ITM_RXBUFFER_EMPTY ) { ch = ITM_RxBuffer ; ITM_RxBuffer = ITM_RXBUFFER_EMPTY ; /* ready for next character */ } return ( ch ); } __STATIC_INLINE uint32_t ITM_SendChar ( uint32_t ch ) { if ((( ITM -> TCR & ITM_TCR_ITMENA_Msk ) != 0UL ) && /* ITM enabled */ (( ITM -> TER & 1UL ) != 0UL )) { /* ITM Port #0 enabled */ while ( ITM -> PORT [ 0U ]. u32 == 0UL ) { __NOP (); } ITM -> PORT [ 0U ]. u8 = ( uint8_t ) ch ; } return ( ch ); } 3. Print on SWO \u2693\ufe0e Let\u2019s start a Black pill board which has STM32F411CE MCU featured by Cortex-M4 running at 100 MHz. A Blue Pill can be used in this lab too. Find the differences between then in Blue Pill Vs Black Pill: Transitioning From STM32F103 to STMF411 . A blue pill STM32F103 A black pill STM32F411 3.1. Setup project \u2693\ufe0e Start a new project with STM32F411CE, and configure it under STM32CubeMX as below: Enable HSE and LSE crystal inputs Set the HCLK to 100 MHz by select HSE input for PLL and feed PLLCLK to HCLK Set Debug mode to Trace Asynchronous SW under the System Core configuration to enable the SWO function on the pin PB3 . Set PC13 as a GPIO Output as it is connected to an LED on the board Pin map STM32F411CE Description PA14 SWCLK PA13 SWDIO PB3 SWO PC13 LED 3.2. Print out on SWO \u2693\ufe0e After generating code from STM32CubeMX, there is a file syscalls.c containing implementation for standard input/output calls of the system, such as _write() function is used by printf() . newlib-nano library GNU ARM libs use newlib to provide standard implementation of C libraries.However, to reduce the code size and make it independent to hardware, there is a lightweight version newlib-nano used in MCUs. However, newlib-nano does not provide an implementation of low-level system calls which are used by C standard libs, such as _write() or _read() which are used in printf() or scanf() . To make the application compilable, a new library named nosys should be added. This library just provide an simple implementation of low-level system calls which mostly return a by-pass value. STM32CubeMX generates syscalls.c to provide low-level implementation for C libraries. syscalls.c __attribute__ (( weak )) int _write ( int file , char * ptr , int len ) { int DataIdx ; for ( DataIdx = 0 ; DataIdx < len ; DataIdx ++ ) { __io_putchar ( * ptr ++ ); } return len ; } Redirect to ITM To redirect the output to the ITM, override this function in main.c and replace the call to __io_putchar by ITM_SendChar : main.c int _write ( int file , char * ptr , int len ) { int DataIdx ; for ( DataIdx = 0 ; DataIdx < len ; DataIdx ++ ) { ITM_SendChar ( * ptr ++ ); } return len ; } Print a counter variable Create a variable char counter = 0 ; and in the main while loop, increase it by 1 and print out its value using standard function printf() every second. main.c char counter = 0 ; int main ( void ) { while ( 1 ) { counter ++ ; printf ( \"counter = %d \\n \" , counter ); HAL_GPIO_TogglePin ( LED_GPIO_Port , LED_Pin ); HAL_Delay ( 1000 ); } } 3.3. Open SWV View \u2693\ufe0e To enable the SWV function, in the Debugger Configuration screen, select below settings: Interface: SWD Serial Wire Viewer: Enable: true Core Clock: 100 MHz, should match the real CPU clock Setup Debugger to use SWV The next step is to add SWV Windows into the Debug perspective of IDE: Select Windows \u00bb Show View \u00bb SWV and select one of available windows type. For displaying ITM Print data, select the SWV ITM Data Console window. Add SWV windows Click on the Config icon in the SWV ITM Data Console tab, enable the ITM 0 and apply. Press on the Red button to start reading the SWV data. Configure ITM channel and start reading Resume the execution and observe the text appears on the ITM Data console: counter is printed in the ITM Data Console 4. Inspect variables \u2693\ufe0e The Debug IDE can inspect a variable in real-time using the Live Expression feature. For example, add uwTick to see the instant system time in milliseconds, add counter to show the instant value. Live Expression SWV also has a useful graph mode to monitor variables. Open the SWV Data Trace Timeline Graph and open its configuration to enable Comparator 0 to trace the counter variable. Enable tracing variable in SWV Press on the Red button to start reading the SWV data. Resume the execution and observe the data is drawn in the graph: counter is drawn on the graph 5. Trace events \u2693\ufe0e SWV can be used to trace different types of events as it can sample Program Counter (PC) register and access some special registers to calculate some statistics. Trace configuration for SWV 5.1. Events \u2693\ufe0e CPI \u2014 Cycles per instruction For each cycle beyond the first one that an instruction uses, an internal counter is increased with one. The counter (DWT CPI count) can count up to 256 and is then set to 0. Each time that happens, one of these packets are sent. This is one aspect of the processors performance and used to calculate instructions per seconds. The lower the value, the better the performance. SLEEP \u2014 Sleep cycles The number of cycles the CPU is in sleep mode. Counted in DWT Sleep count register. Each time the CPU has been in sleep mode for 256 cycles, one of these packets is sent. This is used when debugging for power consumption or waiting for external devices. FOLD \u2014 Folded instructions A counter for how many instructions are folded (removed). Every 256 instruction folded (taken zero cycles) will receive one of these events. Counted in DWT Fold count register. Branch folding is a technique where, on the prediction of most branches, the branch instruction is completely removed from the instruction stream presented to the execution pipeline. Branch folding can significantly improve the performance of branches, taking the CPI for branches below 1. EXC \u2014 Exception overhead The DWT Exception count register keeps track of the number of CPU cycles spent in exception overhead. This includes stack operations and returns but not the time spent processing the exception code. When the timer overflows, one of these events is sent. Used to calculate the actual exception handling cost to the program. LSU \u2014 Load Store Unit Cycles The DWT LSU count register counts the total number of cycles the processor is processing an LSU operation beyond the first cycle. When the timer overflows, one of these events is sent. With this measurement, it is possible to track the amount of time spent in memory operations. EXETRC \u2014 Trace Exceptions Whenever an exception occurs, exception entry, exception exit and exception return events are sent. These events can be monitored in the SWV Exception Trace Log view. From this view, it is possible to jump to the exception handler code for that exception. PC Sampling Enabling this starts sampling the Program Counter at some cycle interval. Since the SWO pin has a limited bandwidth, it is not advised to sample to fast. Experiment with the Resolution (cycles/ sample setting) to be able to sample often enough. The results from the sampling are used, among other things, for the SWV Statistical Profiling view. 5.2. Statistical Profiling \u2693\ufe0e When enable PC Sampling , the IDE can It show the amount of execution time spent within various functions. This is useful when optimizing code. When pause the execution, the SWV Statistical Profiling view will display a table with calculated information. Clear the collected data to start a new profiling session. Statistical profiling of function execution 5.3. Exception Trace \u2693\ufe0e Every event sent when CPU handles an exception will be recorded and these data is used to calculate some information about exceptions. There are two tabs, but the useful information is in the statistic tab. Statistic of exception execution 6. Receive data using scanf \u2693\ufe0e In above section, the _write function is overridden to redirect printf to ITM 0. The same method can be applied to override _read function to receive data for the function scanf . int _read ( int file , char * ptr , int len ) { for ( int DataIdx = 0 ; DataIdx < len ; DataIdx ++ ) { * ptr ++ = ITM_ReceiveChar (); } return len ; } However, when compile this code, an error will be raised due to undefined reference to the ITM_RxBuffer . This special variable is left to be defined by Debugger which support SWV input functions, such as Keil ARM. STM32CubeIDE does not support. There are ideas to use either SemiHosting or SWD to write data into the ITM_RxBuffer as mentioned in here . SEGGER RTT is well done of utilizing the ARM Debug Access Port (DAP) and background memory access to provide bi-direction communication.","title":"SWV"},{"location":"blog/stm32/swv/#1-serial-wire-viewer","text":"Cortex-M based microcontrollers integrate some debugging and tracing technologies, including JTAG and SWD. Tracing allows exporting in real-time internal activities performed by the CPU. The Instrumentation Trace MacroCell (ITM) allows sending software-generated debug messages through a specific signal I/O named Serial Wire Output (SWO). The protocol used by the SWO pin to exchange data with the debugger probe is called Serial Wire Viewer (SWV). The ITM support is available in Cortex-M3/M4/M7 microcontrollers Compared to other \u201cdebugging-alike\u201d peripherals like UART/VCOM redirection or the ARM SemiHosting , SWV is really fast. Its communication speed is proportional to the MCU speed. To properly decode the bytes sent over the SWO port, the host debugger needs to know the frequencies of CPU and SWO port. SWV protocol defines 32 different stimulus ports: a port is a \u201ctag\u201d on the SWV message used to enable/disable messages selectively. These channels allow for separating the diagnostic data into different categories. For instance, ARM recommends channel 0 for text data (e.g., from printf) and channel 31 for RTOS events, while the other channels can be used for any other purposes.","title":"1. Serial Wire Viewer"},{"location":"blog/stm32/swv/#2-itm-functions","text":"The ITM stimulus registers are standardized by ARM and found on address 0xE0000000 (port 0) through 0xE000007C (port 31). To write data, enable ITM tracing and write data to the corresponding register. The CMSIS-Core package for Cortex-M3/M4/M7 cores provides necessary glue to handle SWV protocol. For example, the ITM_SendChar() routines allows to send a character using the SWO pin. core_cm4.h __STATIC_INLINE int32_t ITM_ReceiveChar ( void ) { int32_t ch = -1 ; /* no character available */ if ( ITM_RxBuffer != ITM_RXBUFFER_EMPTY ) { ch = ITM_RxBuffer ; ITM_RxBuffer = ITM_RXBUFFER_EMPTY ; /* ready for next character */ } return ( ch ); } __STATIC_INLINE uint32_t ITM_SendChar ( uint32_t ch ) { if ((( ITM -> TCR & ITM_TCR_ITMENA_Msk ) != 0UL ) && /* ITM enabled */ (( ITM -> TER & 1UL ) != 0UL )) { /* ITM Port #0 enabled */ while ( ITM -> PORT [ 0U ]. u32 == 0UL ) { __NOP (); } ITM -> PORT [ 0U ]. u8 = ( uint8_t ) ch ; } return ( ch ); }","title":"2. ITM Functions"},{"location":"blog/stm32/swv/#3-print-on-swo","text":"Let\u2019s start a Black pill board which has STM32F411CE MCU featured by Cortex-M4 running at 100 MHz. A Blue Pill can be used in this lab too. Find the differences between then in Blue Pill Vs Black Pill: Transitioning From STM32F103 to STMF411 . A blue pill STM32F103 A black pill STM32F411","title":"3. Print on SWO"},{"location":"blog/stm32/swv/#31-setup-project","text":"Start a new project with STM32F411CE, and configure it under STM32CubeMX as below: Enable HSE and LSE crystal inputs Set the HCLK to 100 MHz by select HSE input for PLL and feed PLLCLK to HCLK Set Debug mode to Trace Asynchronous SW under the System Core configuration to enable the SWO function on the pin PB3 . Set PC13 as a GPIO Output as it is connected to an LED on the board Pin map STM32F411CE Description PA14 SWCLK PA13 SWDIO PB3 SWO PC13 LED","title":"3.1. Setup project"},{"location":"blog/stm32/swv/#32-print-out-on-swo","text":"After generating code from STM32CubeMX, there is a file syscalls.c containing implementation for standard input/output calls of the system, such as _write() function is used by printf() . newlib-nano library GNU ARM libs use newlib to provide standard implementation of C libraries.However, to reduce the code size and make it independent to hardware, there is a lightweight version newlib-nano used in MCUs. However, newlib-nano does not provide an implementation of low-level system calls which are used by C standard libs, such as _write() or _read() which are used in printf() or scanf() . To make the application compilable, a new library named nosys should be added. This library just provide an simple implementation of low-level system calls which mostly return a by-pass value. STM32CubeMX generates syscalls.c to provide low-level implementation for C libraries. syscalls.c __attribute__ (( weak )) int _write ( int file , char * ptr , int len ) { int DataIdx ; for ( DataIdx = 0 ; DataIdx < len ; DataIdx ++ ) { __io_putchar ( * ptr ++ ); } return len ; } Redirect to ITM To redirect the output to the ITM, override this function in main.c and replace the call to __io_putchar by ITM_SendChar : main.c int _write ( int file , char * ptr , int len ) { int DataIdx ; for ( DataIdx = 0 ; DataIdx < len ; DataIdx ++ ) { ITM_SendChar ( * ptr ++ ); } return len ; } Print a counter variable Create a variable char counter = 0 ; and in the main while loop, increase it by 1 and print out its value using standard function printf() every second. main.c char counter = 0 ; int main ( void ) { while ( 1 ) { counter ++ ; printf ( \"counter = %d \\n \" , counter ); HAL_GPIO_TogglePin ( LED_GPIO_Port , LED_Pin ); HAL_Delay ( 1000 ); } }","title":"3.2. Print out on SWO"},{"location":"blog/stm32/swv/#33-open-swv-view","text":"To enable the SWV function, in the Debugger Configuration screen, select below settings: Interface: SWD Serial Wire Viewer: Enable: true Core Clock: 100 MHz, should match the real CPU clock Setup Debugger to use SWV The next step is to add SWV Windows into the Debug perspective of IDE: Select Windows \u00bb Show View \u00bb SWV and select one of available windows type. For displaying ITM Print data, select the SWV ITM Data Console window. Add SWV windows Click on the Config icon in the SWV ITM Data Console tab, enable the ITM 0 and apply. Press on the Red button to start reading the SWV data. Configure ITM channel and start reading Resume the execution and observe the text appears on the ITM Data console: counter is printed in the ITM Data Console","title":"3.3. Open SWV View"},{"location":"blog/stm32/swv/#4-inspect-variables","text":"The Debug IDE can inspect a variable in real-time using the Live Expression feature. For example, add uwTick to see the instant system time in milliseconds, add counter to show the instant value. Live Expression SWV also has a useful graph mode to monitor variables. Open the SWV Data Trace Timeline Graph and open its configuration to enable Comparator 0 to trace the counter variable. Enable tracing variable in SWV Press on the Red button to start reading the SWV data. Resume the execution and observe the data is drawn in the graph: counter is drawn on the graph","title":"4. Inspect variables"},{"location":"blog/stm32/swv/#5-trace-events","text":"SWV can be used to trace different types of events as it can sample Program Counter (PC) register and access some special registers to calculate some statistics. Trace configuration for SWV","title":"5. Trace events"},{"location":"blog/stm32/swv/#51-events","text":"CPI \u2014 Cycles per instruction For each cycle beyond the first one that an instruction uses, an internal counter is increased with one. The counter (DWT CPI count) can count up to 256 and is then set to 0. Each time that happens, one of these packets are sent. This is one aspect of the processors performance and used to calculate instructions per seconds. The lower the value, the better the performance. SLEEP \u2014 Sleep cycles The number of cycles the CPU is in sleep mode. Counted in DWT Sleep count register. Each time the CPU has been in sleep mode for 256 cycles, one of these packets is sent. This is used when debugging for power consumption or waiting for external devices. FOLD \u2014 Folded instructions A counter for how many instructions are folded (removed). Every 256 instruction folded (taken zero cycles) will receive one of these events. Counted in DWT Fold count register. Branch folding is a technique where, on the prediction of most branches, the branch instruction is completely removed from the instruction stream presented to the execution pipeline. Branch folding can significantly improve the performance of branches, taking the CPI for branches below 1. EXC \u2014 Exception overhead The DWT Exception count register keeps track of the number of CPU cycles spent in exception overhead. This includes stack operations and returns but not the time spent processing the exception code. When the timer overflows, one of these events is sent. Used to calculate the actual exception handling cost to the program. LSU \u2014 Load Store Unit Cycles The DWT LSU count register counts the total number of cycles the processor is processing an LSU operation beyond the first cycle. When the timer overflows, one of these events is sent. With this measurement, it is possible to track the amount of time spent in memory operations. EXETRC \u2014 Trace Exceptions Whenever an exception occurs, exception entry, exception exit and exception return events are sent. These events can be monitored in the SWV Exception Trace Log view. From this view, it is possible to jump to the exception handler code for that exception. PC Sampling Enabling this starts sampling the Program Counter at some cycle interval. Since the SWO pin has a limited bandwidth, it is not advised to sample to fast. Experiment with the Resolution (cycles/ sample setting) to be able to sample often enough. The results from the sampling are used, among other things, for the SWV Statistical Profiling view.","title":"5.1. Events"},{"location":"blog/stm32/swv/#52-statistical-profiling","text":"When enable PC Sampling , the IDE can It show the amount of execution time spent within various functions. This is useful when optimizing code. When pause the execution, the SWV Statistical Profiling view will display a table with calculated information. Clear the collected data to start a new profiling session. Statistical profiling of function execution","title":"5.2. Statistical Profiling"},{"location":"blog/stm32/swv/#53-exception-trace","text":"Every event sent when CPU handles an exception will be recorded and these data is used to calculate some information about exceptions. There are two tabs, but the useful information is in the statistic tab. Statistic of exception execution","title":"5.3. Exception Trace"},{"location":"blog/stm32/swv/#6-receive-data-using-scanf","text":"In above section, the _write function is overridden to redirect printf to ITM 0. The same method can be applied to override _read function to receive data for the function scanf . int _read ( int file , char * ptr , int len ) { for ( int DataIdx = 0 ; DataIdx < len ; DataIdx ++ ) { * ptr ++ = ITM_ReceiveChar (); } return len ; } However, when compile this code, an error will be raised due to undefined reference to the ITM_RxBuffer . This special variable is left to be defined by Debugger which support SWV input functions, such as Keil ARM. STM32CubeIDE does not support. There are ideas to use either SemiHosting or SWD to write data into the ITM_RxBuffer as mentioned in here . SEGGER RTT is well done of utilizing the ARM Debug Access Port (DAP) and background memory access to provide bi-direction communication.","title":"6. Receive data using scanf"},{"location":"blog/stm32/timer/","text":"Basic Timer - Blinking LED PWM - LED Brightness 1. Timer overview \u2693\ufe0e A timer is a free-running counter with a counting frequency that is a fraction of its source clock. The counting speed can be reduced using a dedicated pre-scaler for each timer. Depending on the timer type, it can be clocked by the internal clock (which is derived from the bus where it is connected), by an external clock source or by another timer used as a \u201cmaster\u201d. The F sys is not the frequency that is incrementing the timer module, but it gets divided by the Pre-scaler, then it gets fed to the timer. Every clock cycle, the value of the timer is incremented by 1. A timer can have additional pre-load register, therefore, timer will count from 0 to the pre-load value, and then go back to count again from 0. Let\u2019s see an example to calculate the timer period. F sys = 80 MHz Pre-scaler = 1024 Timer gets incremented by 1 every 1024* 1/80000000 s = 12.8 us If set overflow at full 16-bit (at 65535), and start counting from 0, it will generate a signal every 12.8 us * 65535 = 838848 us = 838.848 ms Main groups of Timers : Basic timers : 16-bit timers used as time base generator; do not have output/input pins; used as a master of other timers or used to feed the DAC peripherals. General purpose timers : 16/32-bit timers with multiple purposes; have four-programmable input/output channels; used in any application for output compare (timing and delay generation), One-Pulse Mode, input capture (for external signal frequency measurement), sensor interface (encoder, hall sensor), etc. This type has sub-groups: 1-channel/2-channels, or 1-channel/2-channels with one complimentary output (a dead time generator on one channel). Advanced timers : have more features than General purpose timers such as features related to motor control and digital power conversion applications: three complementary signals with dead time insertion, emergency shut-down input. High resolution timer : a timer allows generating digital signals with high-accuracy timings, such as PWM or phase-shifted pulses. It has Delay lines with closed loop control guarantee a very small resolution whatever the voltage, temperature or chip-to-chip manufacturing process deviation. Low-power timers : have a diversity of clock sources to run in low frequencies, or from external clock-like inputs, and have the capability to wake up the system from low-power modes. 2. Timer modes \u2693\ufe0e An STM32 timer module can operate in any of the following modes, however, have to check the datasheet to figure out which modes are supported by which timers. Timer Mode In timer mode, the timer module gets clocked from an internal clock source with a known frequency. Hence, the clocking frequency is known, the overflow time can also be calculated and controlled by the pre-load register to get any arbitrarily chosen time interval. Each timer overflow, the timer signals the CPU with an interrupt that indicates the end of the specified time interval. This mode of operation is usually used to get a specific operation done at each specific time interval, and to achieve timing & synchronization between various tasks and events in the system. It can also replace delays in various situations for better system response. Counter Mode In counter mode, the timer module gets clocked from an external source (timer input pin). So the timer counts up or down on each rising or falling edge of the external input. This mode is really helpful in numerous situations when need to implement a digital counter without polling input pins or periodically reading a GPIO or continuously interrupt the CPU when hooking with an EXTI pin. If using another timer as an interval, this mode can be used to measure frequency. PWM Mode In Pulse-Width Modulation (PWM) mode, the timer module is clocked from an internal clock source and produces a digital waveform on the output channel pin called the PWM signal. By using output compare registers OCR , the incrementing timer\u2019s register value is constantly compared against this OCR register. When a match occurs the output pin state is flipped until the end of the period and the whole process is repeated. Advanced PWM Mode The advanced PWM signal generation refers to the hardware ability to control more parameters and add some hardware circuitry to support extra features for the PWM signal generation. Which includes: The ability to produce a complementary PWM signal that is typically the same as the PWM on the main channel but logically inverted The ability to inject dead-time band in the PWM signal for motor driving applications to prevent shoot-through currents that result from PWM signals overlapping The ability to perform auto-shutdown for the PWM signal, it\u2019s also called \u201cauto brake\u201d which an important feature for safety-critical applications The ability to phase-adjust the PWM signal Output Compare Mode In output compare mode, a timer module controls an output waveform or indicates when a period of time has elapsed. When a match is detected between the output compare register OCR and the counter, the output compare function assigns the corresponding output pin to a programmable value. One-Pulse Mode One-pulse mode (OPM) is a particular case of the previous modes. It allows the counter to be started in response to a stimulus and to generate a pulse with a programmable length after a programmable delay. Starting the counter can be controlled through the slave mode controller. Generating the waveform can be done in output compare mode or PWM mode. Input Capture Mode In Input capture mode, the Capture/Compare Registers TIMx_CCRx are used to latch the value of the counter after a transition detected by the corresponding ICx signal. When a capture occurs, the corresponding CCXIF flag ( TIMx_SR register) is set and an interrupt or a DMA request can be sent if they are enabled. This mode is extremely important for external signal measurement or external event timing detection. The current value of the timer counts is captured when an external event occurs and an interrupt is fired. Encoder Mode In the encoder interface mode, the timer module operates as a digital counter with two inputs. The counter is clocked by each valid transition on both input pins. The sequence of transitions of the two inputs is evaluated and generates count pulses as well as the direction signal. Depending on the sequence, the counter will count up or down. Timer Gate Mode In timer gated mode, a timer module is also said to be working in \u201cslave mode\u201d. Where it only counts as long as an external input pin is held high or low. This input pin is said to be the timer gate that allows the timer to count or not at all. Timer DMA Burst Mode The STM32 timers, not all of them, have the capability to generate multiple DMA requests upon a single event. The main purpose is to be able to re-program part of the timer multiple times without software overhead, but it can also be used to read several registers in a row, at regular intervals. Infrared Mode An infrared interface ( IRTIM ) for remote control can be used with an infrared LED to perform remote control functions. It uses internal connections with TIM15 and TIM16 as shown in the diagram down below. To generate the infrared remote control signals, the IR interface must be enabled and TIM15 channel 1 ( TIM15_OC1 ) and TIM16 channel 1 ( TIM16_OC1 ) must be properly configured to generate correct waveforms. The infrared receiver can be implemented easily through a basic input capture mode. 3. STM32CubeHAL Usage \u2693\ufe0e The Hardware Abstract Layer (HAL) is designed so that it abstracts from the specific peripheral memory mapping. But, it also provides a general and more user-friendly way to configure the peripheral, without forcing the programmers to now how to configure its registers in detail. Excerpt from Description of STM32F0 HAL and low-layer drivers How to use TIM HAL Initialize the TIM low level resources by implementing the following functions depending on from feature to be used : Time Base : HAL_TIM_Base_MspInit() Input Capture : HAL_TIM_IC_MspInit() Output Compare : HAL_TIM_OC_MspInit() PWM generation : HAL_TIM_PWM_MspInit() One-pulse mode output : HAL_TIM_OnePulse_MspInit() Encoder mode output : HAL_TIM_Encoder_MspInit() Initialize the TIM low level resources : Use __HAL_RCC_TIMx_CLK_ENABLE() to enable the TIM interface clock TIM pins configuration Use __HAL_RCC_GPIOx_CLK_ENABLE() to enable the clock for the TIM GPIOs Configure these TIM pins in Alternate function mode using HAL_GPIO_Init() The external Clock can be configured, if needed (the default clock is the internal clock from the APBx), using the following function: HAL_TIM_ConfigClockSource , the clock configuration should be done before any start function. Configure the TIM in the desired functioning mode using one of the Initialization function of this driver: HAL_TIM_Base_Init : to use the Timer to generate a simple time base HAL_TIM_OC_Init and HAL_TIM_OC_ConfigChannel : to use the Timer to generate an Output Compare signal. HAL_TIM_PWM_Init and HAL_TIM_PWM_ConfigChannel : to use the Timer to generate a PWM signal. HAL_TIM_IC_Init and HAL_TIM_IC_ConfigChannel : to use the Timer to measure an external signal. HAL_TIM_OnePulse_Init and HAL_TIM_OnePulse_ConfigChannel : to use the Timer in One Pulse Mode. HAL_TIM_Encoder_Init : to use the Timer Encoder Interface. Activate the TIM peripheral using one of the start functions depending on from the feature used: Time Base : HAL_TIM_Base_Start() , HAL_TIM_Base_Start_DMA() , HAL_TIM_Base_Start_IT() Input Capture : HAL_TIM_IC_Start() , HAL_TIM_IC_Start_DMA() , HAL_TIM_IC_Start_IT() Output Compare : HAL_TIM_OC_Start() , HAL_TIM_OC_Start_DMA() , HAL_TIM_OC_Start_IT() PWM generation : HAL_TIM_PWM_Start() , HAL_TIM_PWM_Start_DMA() , HAL_TIM_PWM_Start_IT() One-pulse mode output : HAL_TIM_OnePulse_Start() , HAL_TIM_OnePulse_Start_IT() Encoder mode output : HAL_TIM_Encoder_Start() , HAL_TIM_Encoder_Start_DMA() , HAL_TIM_Encoder_Start_IT() . The DMA Burst is managed with the two following functions: HAL_TIM_DMABurst_WriteStart() and HAL_TIM_DMABurst_ReadStart() 4. Lab 1: Blink LED with Timer \u2693\ufe0e This is a basic usage of a timer. Application will enable a basic timer with a pre-scaler and a pre-load value and let the timer run. Then the timer will keep counting and fire up an interrupt to application to do something. Requirements : Use a Timer to toggle an LED every 250ms Target board : Any board as a basic timer and a GPIO are always available. 4.1. Create a new project \u2693\ufe0e This tutorial will use the STM32F0 Discovery board which features an STM32F051R8 MCU. Starting a new project with below starting configs: System Clock set to 48 MHz, which also drives the Timers on the APB bus. Set PC9 as the output for the on-board Blue LED Setup clock for Timers 4.2. Enable a Timer \u2693\ufe0e For this simple lab, a basic timer will be used. Look at the Datasheet of the MCU to know how many timers are in the MCU and their types, and read the Reference Manual to get details about a specific timer. Note that a specific timer TIMx is the same in all STM32 MCUs to guarantee the compatibility and portability of the timer on different target. STM32F051xx Timers The STM32F051xx devices include up to six general-purpose timers, one basic timer and an advanced control timer. Timer features in STM32F051xx The basic timer TIM6 is mainly used for DAC trigger generation. It can also be used as a generic 16-bit time base. TIM6/TIM7 main features 16-bit auto-reload up-counter 16-bit programmable pre-scaler used to divide (also \u201con the fly\u201d) the counter clock frequency Synchronization circuit to trigger the DAC Interrupt/DMA generation on the update event: counter overflow In the STM32CubeMX, activate TIM6 module and then calculate the pre-scaler and auto reload register values: Toggle every 250ms, meaning the rate is 4 Hz Timer frequency is 48 MHz, so it should be reduced 12 000 000 times. Choose any combination of pre-scaler and auto-reload whose multiplication result is 12 000 000. Because these values are counted from zero, therefore, the filled number should be decreased by one. One Pulse mode will make timer run once, do not select this to put timer in repeat mode. Enable the Interrupt for this timer Setting a basic timer Do NOT use Polling mode on Timer Polling mode on Timer is just keep reading the timer\u2019s counter to compare with a given counter. However, please note that the timer is an independent asynchronous peripheral which may run at higher frequency of the CPU core. This line of code if ( __HAL_TIM_GET_COUNTER ( & tim ) == value ){...} does not guarantee that the CPU accesses to the counter register exactly at the same time the timer reaches the given value. 4.3. Generated code \u2693\ufe0e After code generation, there is a function MX_TIM6_Init() to initialize the activated timers. static void MX_TIM6_Init ( void ) { TIM_MasterConfigTypeDef sMasterConfig = { 0 }; htim6 . Instance = TIM6 ; htim6 . Init . Prescaler = 3000-1 ; htim6 . Init . CounterMode = TIM_COUNTERMODE_UP ; htim6 . Init . Period = 4000-1 ; htim6 . Init . AutoReloadPreload = TIM_AUTORELOAD_PRELOAD_DISABLE ; if ( HAL_TIM_Base_Init ( & htim6 ) != HAL_OK ) { Error_Handler (); } sMasterConfig . MasterOutputTrigger = TIM_TRGO_RESET ; sMasterConfig . MasterSlaveMode = TIM_MASTERSLAVEMODE_DISABLE ; if ( HAL_TIMEx_MasterConfigSynchronization ( & htim6 , & sMasterConfig ) != HAL_OK ) { Error_Handler (); } } The clock and interrupt of the selected timer is configured in HAL_TIM_Base_MspInit() function: void HAL_TIM_Base_MspInit ( TIM_HandleTypeDef * htim_base ) { __HAL_RCC_TIM6_CLK_ENABLE (); HAL_NVIC_SetPriority ( TIM6_DAC_IRQn , 0 , 0 ); HAL_NVIC_EnableIRQ ( TIM6_DAC_IRQn ); } Because the timer has enabled its interrupt, HAL calls to HAL_TIM_IRQHandler() in the interrupt handler, then finally informs to application via different callback. In this lab, application only need to know when a full period is done through the callback of HAL_TIM_PeriodElapsedCallback() and toggle the LED. 4.4. User code \u2693\ufe0e This simple lab only needs to override the callback when a full period elapses. void HAL_TIM_PeriodElapsedCallback ( TIM_HandleTypeDef * htim ) { HAL_GPIO_TogglePin ( LED_GPIO_Port , LED_Pin ); } And then start the timer in Interrupt mode in the main application: int main () { HAL_TIM_Base_Start_IT ( & htim6 ); while ( 1 ){...} } 5. Lab 2: PWM on LED brightness \u2693\ufe0e 5.1. PWM Duty \u2693\ufe0e The square waves have a common characteristic: they have a T ON period equal to the T OFF one. For this reason they are also said to have a 50% duty cycle. A duty cycle is the percentage of one period of time (for example, 1s) in which a signal is active. As a formula, a duty cycle is expressed as the T ON /Period. Pulse-width modulation (PWM) is a technique used to generate several pulses with different duty cycles in a given period of time at a given frequency. PWM has many applications in digital electronics, but all of them can be grouped in two main categories: PWM output and its average voltage Control the output voltage (and hence the current); encoding (that is, modulate) a message (that is, a series of bytes in digital electronics) on a carrier wave (which runs at a given frequency). Those two categories can be expanded in several practical usages of the PWM technique. If only focusing on the control of the output voltage, here are several applications: generation of an output voltage ranging from 0V up to VDD (that is, the maximum allowed voltage for an I/O, which in an STM32 is 3.3V); dimming of LEDs; motor control; power conversion; generation of an output wave running at a given frequency (sine wave, triangle, square, and so on); sound output; There are two PWM modes available: PWM mode 1 : in up-counting, the channel is active as long as Counter < Period , else inactive. In down-counting, the channel is inactive as long as Counter > Period , else active. PWM mode 2 : in up-counting, channel is inactive as long as Counter < Period , else active. In down-counting, channel 1 is active as long as Counter > Period , else inactive. 5.2. Drive the brightness \u2693\ufe0e This lab will generate changeable-duty PWM signal on pin PC8 which connected to the blue LED on the STM32F0 Discovery board. If the duty goes up to 100%, the LED will have the highest brightness, and it becomes off when the duty goes down to 0%. The target application should slowly change the duty of the generated PWM. 5.3. Setup PWM on a Timer \u2693\ufe0e The Blue LED on PC8 is connected to Timer 3 \u2014 Channel 3 Output . Therefore, select the Alternate Function of PC8 as TIM3_CH3 firstly. After that, when configuring the TIM3 , select Channel 3 as PWM Generation CH3 . Setup PWM on the Timer 3 Channel 3 Next step is configure the PWM frequency and duty: Use the internal clock source, which is 48 MHz in this lab PWM Frequency = 100 Hz, let\u2019s use Pre-scaler = 480-1, and Counter period = 1000-1. PWM Duty: the Counter period is set to 1000, the if duty is 25%, the Pulse counter must be set at 250-1 5.4. Setup delay on a Timer \u2693\ufe0e Do the same thing as it\u2019s done in the previous lab to set up an 100 Hz interrupt on a basic timer TIM6. The period is now only 10 ms 5.5. Generated code \u2693\ufe0e Let\u2019s see how TIM3 is configured in the generated function MX_TIM3_Init() which setups the timer\u2019s parameters and setup PWM mode. Note that PWM is Output Compare register to mark the point where pulse is inverted. PWM output based on Output Compare and Period registers static void MX_TIM3_Init ( void ) { TIM_ClockConfigTypeDef sClockSourceConfig = { 0 }; TIM_MasterConfigTypeDef sMasterConfig = { 0 }; TIM_OC_InitTypeDef sConfigOC = { 0 }; /* Setup base */ htim3 . Instance = TIM3 ; htim3 . Init . Prescaler = 480-1 ; htim3 . Init . CounterMode = TIM_COUNTERMODE_UP ; htim3 . Init . Period = 1000-1 ; htim3 . Init . ClockDivision = TIM_CLOCKDIVISION_DIV1 ; htim3 . Init . AutoReloadPreload = TIM_AUTORELOAD_PRELOAD_DISABLE ; if ( HAL_TIM_Base_Init ( & htim3 ) != HAL_OK ) { Error_Handler (); } /* Setup clock source */ sClockSourceConfig . ClockSource = TIM_CLOCKSOURCE_INTERNAL ; if ( HAL_TIM_ConfigClockSource ( & htim3 , & sClockSourceConfig ) != HAL_OK ) { Error_Handler (); } /* Init PWM */ if ( HAL_TIM_PWM_Init ( & htim3 ) != HAL_OK ) { Error_Handler (); } sMasterConfig . MasterOutputTrigger = TIM_TRGO_RESET ; sMasterConfig . MasterSlaveMode = TIM_MASTERSLAVEMODE_DISABLE ; if ( HAL_TIMEx_MasterConfigSynchronization ( & htim3 , & sMasterConfig ) != HAL_OK ) { Error_Handler (); } /* Setup PWM params*/ sConfigOC . OCMode = TIM_OCMODE_PWM1 ; sConfigOC . Pulse = 250-1 ; sConfigOC . OCPolarity = TIM_OCPOLARITY_HIGH ; sConfigOC . OCFastMode = TIM_OCFAST_DISABLE ; if ( HAL_TIM_PWM_ConfigChannel ( & htim3 , & sConfigOC , TIM_CHANNEL_3 ) != HAL_OK ) { Error_Handler (); } /* Setup GPIO for PWM Output */ HAL_TIM_MspPostInit ( & htim3 ); } 5.6. User code \u2693\ufe0e The Counter period (aka. Auto Reload ) is stored in the register ARR of the timer. And the duty of the PWM is set in the Compare Control register named CRx . In the main application, save the PWM duty and use it to control PWM duty later. All timers must be started exclusively. uint16_t dutyCycle = 0 ; int main () { dutyCycle = __HAL_TIM_GET_AUTORELOAD ( & htim3 ); HAL_TIM_PWM_Start ( & htim3 , TIM_CHANNEL_3 ); HAL_TIM_Base_Start_IT ( & htim6 ); while ( 1 ) { HAL_Delay ( 1000 ); } } To change the duty of the output PWM inside the 100 Hz basic timer\u2019s interrupt, override the callback and set the Output Compare value with changed duty. void HAL_TIM_PeriodElapsedCallback ( TIM_HandleTypeDef * htim ) { if ( dutyCycle >= __HAL_TIM_GET_AUTORELOAD ( & htim3 )) { dutyInc = -1 ; } else if ( dutyCycle == 0 ) { dutyInc = + 1 ; } dutyCycle += dutyInc ; __HAL_TIM_SET_COMPARE ( & htim3 , TIM_CHANNEL_3 , dutyCycle ); } PWM at 100Hz with changing duty \u2014 video LED brightness with changing PWM 6. Other modes \u2693\ufe0e Other modes of timers will be covered in some examples in upcoming posts.","title":"Timers"},{"location":"blog/stm32/timer/#1-timer-overview","text":"A timer is a free-running counter with a counting frequency that is a fraction of its source clock. The counting speed can be reduced using a dedicated pre-scaler for each timer. Depending on the timer type, it can be clocked by the internal clock (which is derived from the bus where it is connected), by an external clock source or by another timer used as a \u201cmaster\u201d. The F sys is not the frequency that is incrementing the timer module, but it gets divided by the Pre-scaler, then it gets fed to the timer. Every clock cycle, the value of the timer is incremented by 1. A timer can have additional pre-load register, therefore, timer will count from 0 to the pre-load value, and then go back to count again from 0. Let\u2019s see an example to calculate the timer period. F sys = 80 MHz Pre-scaler = 1024 Timer gets incremented by 1 every 1024* 1/80000000 s = 12.8 us If set overflow at full 16-bit (at 65535), and start counting from 0, it will generate a signal every 12.8 us * 65535 = 838848 us = 838.848 ms Main groups of Timers : Basic timers : 16-bit timers used as time base generator; do not have output/input pins; used as a master of other timers or used to feed the DAC peripherals. General purpose timers : 16/32-bit timers with multiple purposes; have four-programmable input/output channels; used in any application for output compare (timing and delay generation), One-Pulse Mode, input capture (for external signal frequency measurement), sensor interface (encoder, hall sensor), etc. This type has sub-groups: 1-channel/2-channels, or 1-channel/2-channels with one complimentary output (a dead time generator on one channel). Advanced timers : have more features than General purpose timers such as features related to motor control and digital power conversion applications: three complementary signals with dead time insertion, emergency shut-down input. High resolution timer : a timer allows generating digital signals with high-accuracy timings, such as PWM or phase-shifted pulses. It has Delay lines with closed loop control guarantee a very small resolution whatever the voltage, temperature or chip-to-chip manufacturing process deviation. Low-power timers : have a diversity of clock sources to run in low frequencies, or from external clock-like inputs, and have the capability to wake up the system from low-power modes.","title":"1. Timer overview"},{"location":"blog/stm32/timer/#2-timer-modes","text":"An STM32 timer module can operate in any of the following modes, however, have to check the datasheet to figure out which modes are supported by which timers. Timer Mode In timer mode, the timer module gets clocked from an internal clock source with a known frequency. Hence, the clocking frequency is known, the overflow time can also be calculated and controlled by the pre-load register to get any arbitrarily chosen time interval. Each timer overflow, the timer signals the CPU with an interrupt that indicates the end of the specified time interval. This mode of operation is usually used to get a specific operation done at each specific time interval, and to achieve timing & synchronization between various tasks and events in the system. It can also replace delays in various situations for better system response. Counter Mode In counter mode, the timer module gets clocked from an external source (timer input pin). So the timer counts up or down on each rising or falling edge of the external input. This mode is really helpful in numerous situations when need to implement a digital counter without polling input pins or periodically reading a GPIO or continuously interrupt the CPU when hooking with an EXTI pin. If using another timer as an interval, this mode can be used to measure frequency. PWM Mode In Pulse-Width Modulation (PWM) mode, the timer module is clocked from an internal clock source and produces a digital waveform on the output channel pin called the PWM signal. By using output compare registers OCR , the incrementing timer\u2019s register value is constantly compared against this OCR register. When a match occurs the output pin state is flipped until the end of the period and the whole process is repeated. Advanced PWM Mode The advanced PWM signal generation refers to the hardware ability to control more parameters and add some hardware circuitry to support extra features for the PWM signal generation. Which includes: The ability to produce a complementary PWM signal that is typically the same as the PWM on the main channel but logically inverted The ability to inject dead-time band in the PWM signal for motor driving applications to prevent shoot-through currents that result from PWM signals overlapping The ability to perform auto-shutdown for the PWM signal, it\u2019s also called \u201cauto brake\u201d which an important feature for safety-critical applications The ability to phase-adjust the PWM signal Output Compare Mode In output compare mode, a timer module controls an output waveform or indicates when a period of time has elapsed. When a match is detected between the output compare register OCR and the counter, the output compare function assigns the corresponding output pin to a programmable value. One-Pulse Mode One-pulse mode (OPM) is a particular case of the previous modes. It allows the counter to be started in response to a stimulus and to generate a pulse with a programmable length after a programmable delay. Starting the counter can be controlled through the slave mode controller. Generating the waveform can be done in output compare mode or PWM mode. Input Capture Mode In Input capture mode, the Capture/Compare Registers TIMx_CCRx are used to latch the value of the counter after a transition detected by the corresponding ICx signal. When a capture occurs, the corresponding CCXIF flag ( TIMx_SR register) is set and an interrupt or a DMA request can be sent if they are enabled. This mode is extremely important for external signal measurement or external event timing detection. The current value of the timer counts is captured when an external event occurs and an interrupt is fired. Encoder Mode In the encoder interface mode, the timer module operates as a digital counter with two inputs. The counter is clocked by each valid transition on both input pins. The sequence of transitions of the two inputs is evaluated and generates count pulses as well as the direction signal. Depending on the sequence, the counter will count up or down. Timer Gate Mode In timer gated mode, a timer module is also said to be working in \u201cslave mode\u201d. Where it only counts as long as an external input pin is held high or low. This input pin is said to be the timer gate that allows the timer to count or not at all. Timer DMA Burst Mode The STM32 timers, not all of them, have the capability to generate multiple DMA requests upon a single event. The main purpose is to be able to re-program part of the timer multiple times without software overhead, but it can also be used to read several registers in a row, at regular intervals. Infrared Mode An infrared interface ( IRTIM ) for remote control can be used with an infrared LED to perform remote control functions. It uses internal connections with TIM15 and TIM16 as shown in the diagram down below. To generate the infrared remote control signals, the IR interface must be enabled and TIM15 channel 1 ( TIM15_OC1 ) and TIM16 channel 1 ( TIM16_OC1 ) must be properly configured to generate correct waveforms. The infrared receiver can be implemented easily through a basic input capture mode.","title":"2. Timer modes"},{"location":"blog/stm32/timer/#3-stm32cubehal-usage","text":"The Hardware Abstract Layer (HAL) is designed so that it abstracts from the specific peripheral memory mapping. But, it also provides a general and more user-friendly way to configure the peripheral, without forcing the programmers to now how to configure its registers in detail. Excerpt from Description of STM32F0 HAL and low-layer drivers How to use TIM HAL Initialize the TIM low level resources by implementing the following functions depending on from feature to be used : Time Base : HAL_TIM_Base_MspInit() Input Capture : HAL_TIM_IC_MspInit() Output Compare : HAL_TIM_OC_MspInit() PWM generation : HAL_TIM_PWM_MspInit() One-pulse mode output : HAL_TIM_OnePulse_MspInit() Encoder mode output : HAL_TIM_Encoder_MspInit() Initialize the TIM low level resources : Use __HAL_RCC_TIMx_CLK_ENABLE() to enable the TIM interface clock TIM pins configuration Use __HAL_RCC_GPIOx_CLK_ENABLE() to enable the clock for the TIM GPIOs Configure these TIM pins in Alternate function mode using HAL_GPIO_Init() The external Clock can be configured, if needed (the default clock is the internal clock from the APBx), using the following function: HAL_TIM_ConfigClockSource , the clock configuration should be done before any start function. Configure the TIM in the desired functioning mode using one of the Initialization function of this driver: HAL_TIM_Base_Init : to use the Timer to generate a simple time base HAL_TIM_OC_Init and HAL_TIM_OC_ConfigChannel : to use the Timer to generate an Output Compare signal. HAL_TIM_PWM_Init and HAL_TIM_PWM_ConfigChannel : to use the Timer to generate a PWM signal. HAL_TIM_IC_Init and HAL_TIM_IC_ConfigChannel : to use the Timer to measure an external signal. HAL_TIM_OnePulse_Init and HAL_TIM_OnePulse_ConfigChannel : to use the Timer in One Pulse Mode. HAL_TIM_Encoder_Init : to use the Timer Encoder Interface. Activate the TIM peripheral using one of the start functions depending on from the feature used: Time Base : HAL_TIM_Base_Start() , HAL_TIM_Base_Start_DMA() , HAL_TIM_Base_Start_IT() Input Capture : HAL_TIM_IC_Start() , HAL_TIM_IC_Start_DMA() , HAL_TIM_IC_Start_IT() Output Compare : HAL_TIM_OC_Start() , HAL_TIM_OC_Start_DMA() , HAL_TIM_OC_Start_IT() PWM generation : HAL_TIM_PWM_Start() , HAL_TIM_PWM_Start_DMA() , HAL_TIM_PWM_Start_IT() One-pulse mode output : HAL_TIM_OnePulse_Start() , HAL_TIM_OnePulse_Start_IT() Encoder mode output : HAL_TIM_Encoder_Start() , HAL_TIM_Encoder_Start_DMA() , HAL_TIM_Encoder_Start_IT() . The DMA Burst is managed with the two following functions: HAL_TIM_DMABurst_WriteStart() and HAL_TIM_DMABurst_ReadStart()","title":"3. STM32CubeHAL Usage"},{"location":"blog/stm32/timer/#4-lab-1-blink-led-with-timer","text":"This is a basic usage of a timer. Application will enable a basic timer with a pre-scaler and a pre-load value and let the timer run. Then the timer will keep counting and fire up an interrupt to application to do something. Requirements : Use a Timer to toggle an LED every 250ms Target board : Any board as a basic timer and a GPIO are always available.","title":"4. Lab 1: Blink LED with Timer"},{"location":"blog/stm32/timer/#41-create-a-new-project","text":"This tutorial will use the STM32F0 Discovery board which features an STM32F051R8 MCU. Starting a new project with below starting configs: System Clock set to 48 MHz, which also drives the Timers on the APB bus. Set PC9 as the output for the on-board Blue LED Setup clock for Timers","title":"4.1. Create a new project"},{"location":"blog/stm32/timer/#42-enable-a-timer","text":"For this simple lab, a basic timer will be used. Look at the Datasheet of the MCU to know how many timers are in the MCU and their types, and read the Reference Manual to get details about a specific timer. Note that a specific timer TIMx is the same in all STM32 MCUs to guarantee the compatibility and portability of the timer on different target. STM32F051xx Timers The STM32F051xx devices include up to six general-purpose timers, one basic timer and an advanced control timer. Timer features in STM32F051xx The basic timer TIM6 is mainly used for DAC trigger generation. It can also be used as a generic 16-bit time base. TIM6/TIM7 main features 16-bit auto-reload up-counter 16-bit programmable pre-scaler used to divide (also \u201con the fly\u201d) the counter clock frequency Synchronization circuit to trigger the DAC Interrupt/DMA generation on the update event: counter overflow In the STM32CubeMX, activate TIM6 module and then calculate the pre-scaler and auto reload register values: Toggle every 250ms, meaning the rate is 4 Hz Timer frequency is 48 MHz, so it should be reduced 12 000 000 times. Choose any combination of pre-scaler and auto-reload whose multiplication result is 12 000 000. Because these values are counted from zero, therefore, the filled number should be decreased by one. One Pulse mode will make timer run once, do not select this to put timer in repeat mode. Enable the Interrupt for this timer Setting a basic timer Do NOT use Polling mode on Timer Polling mode on Timer is just keep reading the timer\u2019s counter to compare with a given counter. However, please note that the timer is an independent asynchronous peripheral which may run at higher frequency of the CPU core. This line of code if ( __HAL_TIM_GET_COUNTER ( & tim ) == value ){...} does not guarantee that the CPU accesses to the counter register exactly at the same time the timer reaches the given value.","title":"4.2. Enable a Timer"},{"location":"blog/stm32/timer/#43-generated-code","text":"After code generation, there is a function MX_TIM6_Init() to initialize the activated timers. static void MX_TIM6_Init ( void ) { TIM_MasterConfigTypeDef sMasterConfig = { 0 }; htim6 . Instance = TIM6 ; htim6 . Init . Prescaler = 3000-1 ; htim6 . Init . CounterMode = TIM_COUNTERMODE_UP ; htim6 . Init . Period = 4000-1 ; htim6 . Init . AutoReloadPreload = TIM_AUTORELOAD_PRELOAD_DISABLE ; if ( HAL_TIM_Base_Init ( & htim6 ) != HAL_OK ) { Error_Handler (); } sMasterConfig . MasterOutputTrigger = TIM_TRGO_RESET ; sMasterConfig . MasterSlaveMode = TIM_MASTERSLAVEMODE_DISABLE ; if ( HAL_TIMEx_MasterConfigSynchronization ( & htim6 , & sMasterConfig ) != HAL_OK ) { Error_Handler (); } } The clock and interrupt of the selected timer is configured in HAL_TIM_Base_MspInit() function: void HAL_TIM_Base_MspInit ( TIM_HandleTypeDef * htim_base ) { __HAL_RCC_TIM6_CLK_ENABLE (); HAL_NVIC_SetPriority ( TIM6_DAC_IRQn , 0 , 0 ); HAL_NVIC_EnableIRQ ( TIM6_DAC_IRQn ); } Because the timer has enabled its interrupt, HAL calls to HAL_TIM_IRQHandler() in the interrupt handler, then finally informs to application via different callback. In this lab, application only need to know when a full period is done through the callback of HAL_TIM_PeriodElapsedCallback() and toggle the LED.","title":"4.3. Generated code"},{"location":"blog/stm32/timer/#44-user-code","text":"This simple lab only needs to override the callback when a full period elapses. void HAL_TIM_PeriodElapsedCallback ( TIM_HandleTypeDef * htim ) { HAL_GPIO_TogglePin ( LED_GPIO_Port , LED_Pin ); } And then start the timer in Interrupt mode in the main application: int main () { HAL_TIM_Base_Start_IT ( & htim6 ); while ( 1 ){...} }","title":"4.4. User code"},{"location":"blog/stm32/timer/#5-lab-2-pwm-on-led-brightness","text":"","title":"5. Lab 2: PWM on LED brightness"},{"location":"blog/stm32/timer/#51-pwm-duty","text":"The square waves have a common characteristic: they have a T ON period equal to the T OFF one. For this reason they are also said to have a 50% duty cycle. A duty cycle is the percentage of one period of time (for example, 1s) in which a signal is active. As a formula, a duty cycle is expressed as the T ON /Period. Pulse-width modulation (PWM) is a technique used to generate several pulses with different duty cycles in a given period of time at a given frequency. PWM has many applications in digital electronics, but all of them can be grouped in two main categories: PWM output and its average voltage Control the output voltage (and hence the current); encoding (that is, modulate) a message (that is, a series of bytes in digital electronics) on a carrier wave (which runs at a given frequency). Those two categories can be expanded in several practical usages of the PWM technique. If only focusing on the control of the output voltage, here are several applications: generation of an output voltage ranging from 0V up to VDD (that is, the maximum allowed voltage for an I/O, which in an STM32 is 3.3V); dimming of LEDs; motor control; power conversion; generation of an output wave running at a given frequency (sine wave, triangle, square, and so on); sound output; There are two PWM modes available: PWM mode 1 : in up-counting, the channel is active as long as Counter < Period , else inactive. In down-counting, the channel is inactive as long as Counter > Period , else active. PWM mode 2 : in up-counting, channel is inactive as long as Counter < Period , else active. In down-counting, channel 1 is active as long as Counter > Period , else inactive.","title":"5.1. PWM Duty"},{"location":"blog/stm32/timer/#52-drive-the-brightness","text":"This lab will generate changeable-duty PWM signal on pin PC8 which connected to the blue LED on the STM32F0 Discovery board. If the duty goes up to 100%, the LED will have the highest brightness, and it becomes off when the duty goes down to 0%. The target application should slowly change the duty of the generated PWM.","title":"5.2. Drive the brightness"},{"location":"blog/stm32/timer/#53-setup-pwm-on-a-timer","text":"The Blue LED on PC8 is connected to Timer 3 \u2014 Channel 3 Output . Therefore, select the Alternate Function of PC8 as TIM3_CH3 firstly. After that, when configuring the TIM3 , select Channel 3 as PWM Generation CH3 . Setup PWM on the Timer 3 Channel 3 Next step is configure the PWM frequency and duty: Use the internal clock source, which is 48 MHz in this lab PWM Frequency = 100 Hz, let\u2019s use Pre-scaler = 480-1, and Counter period = 1000-1. PWM Duty: the Counter period is set to 1000, the if duty is 25%, the Pulse counter must be set at 250-1","title":"5.3. Setup PWM on a Timer"},{"location":"blog/stm32/timer/#54-setup-delay-on-a-timer","text":"Do the same thing as it\u2019s done in the previous lab to set up an 100 Hz interrupt on a basic timer TIM6. The period is now only 10 ms","title":"5.4. Setup delay on a Timer"},{"location":"blog/stm32/timer/#55-generated-code","text":"Let\u2019s see how TIM3 is configured in the generated function MX_TIM3_Init() which setups the timer\u2019s parameters and setup PWM mode. Note that PWM is Output Compare register to mark the point where pulse is inverted. PWM output based on Output Compare and Period registers static void MX_TIM3_Init ( void ) { TIM_ClockConfigTypeDef sClockSourceConfig = { 0 }; TIM_MasterConfigTypeDef sMasterConfig = { 0 }; TIM_OC_InitTypeDef sConfigOC = { 0 }; /* Setup base */ htim3 . Instance = TIM3 ; htim3 . Init . Prescaler = 480-1 ; htim3 . Init . CounterMode = TIM_COUNTERMODE_UP ; htim3 . Init . Period = 1000-1 ; htim3 . Init . ClockDivision = TIM_CLOCKDIVISION_DIV1 ; htim3 . Init . AutoReloadPreload = TIM_AUTORELOAD_PRELOAD_DISABLE ; if ( HAL_TIM_Base_Init ( & htim3 ) != HAL_OK ) { Error_Handler (); } /* Setup clock source */ sClockSourceConfig . ClockSource = TIM_CLOCKSOURCE_INTERNAL ; if ( HAL_TIM_ConfigClockSource ( & htim3 , & sClockSourceConfig ) != HAL_OK ) { Error_Handler (); } /* Init PWM */ if ( HAL_TIM_PWM_Init ( & htim3 ) != HAL_OK ) { Error_Handler (); } sMasterConfig . MasterOutputTrigger = TIM_TRGO_RESET ; sMasterConfig . MasterSlaveMode = TIM_MASTERSLAVEMODE_DISABLE ; if ( HAL_TIMEx_MasterConfigSynchronization ( & htim3 , & sMasterConfig ) != HAL_OK ) { Error_Handler (); } /* Setup PWM params*/ sConfigOC . OCMode = TIM_OCMODE_PWM1 ; sConfigOC . Pulse = 250-1 ; sConfigOC . OCPolarity = TIM_OCPOLARITY_HIGH ; sConfigOC . OCFastMode = TIM_OCFAST_DISABLE ; if ( HAL_TIM_PWM_ConfigChannel ( & htim3 , & sConfigOC , TIM_CHANNEL_3 ) != HAL_OK ) { Error_Handler (); } /* Setup GPIO for PWM Output */ HAL_TIM_MspPostInit ( & htim3 ); }","title":"5.5. Generated code"},{"location":"blog/stm32/timer/#56-user-code","text":"The Counter period (aka. Auto Reload ) is stored in the register ARR of the timer. And the duty of the PWM is set in the Compare Control register named CRx . In the main application, save the PWM duty and use it to control PWM duty later. All timers must be started exclusively. uint16_t dutyCycle = 0 ; int main () { dutyCycle = __HAL_TIM_GET_AUTORELOAD ( & htim3 ); HAL_TIM_PWM_Start ( & htim3 , TIM_CHANNEL_3 ); HAL_TIM_Base_Start_IT ( & htim6 ); while ( 1 ) { HAL_Delay ( 1000 ); } } To change the duty of the output PWM inside the 100 Hz basic timer\u2019s interrupt, override the callback and set the Output Compare value with changed duty. void HAL_TIM_PeriodElapsedCallback ( TIM_HandleTypeDef * htim ) { if ( dutyCycle >= __HAL_TIM_GET_AUTORELOAD ( & htim3 )) { dutyInc = -1 ; } else if ( dutyCycle == 0 ) { dutyInc = + 1 ; } dutyCycle += dutyInc ; __HAL_TIM_SET_COMPARE ( & htim3 , TIM_CHANNEL_3 , dutyCycle ); } PWM at 100Hz with changing duty \u2014 video LED brightness with changing PWM","title":"5.6. User code"},{"location":"blog/stm32/timer/#6-other-modes","text":"Other modes of timers will be covered in some examples in upcoming posts.","title":"6. Other modes"},{"location":"blog/stm32/tools/","text":"1. STM32 Ecosystem \u2693\ufe0e A tool-chain is a set of programming tools that allow developers to: Configure the settings on the target MCU Write code and navigate inside source files of the project Inspect the code to show additional information about variables, function definitions, etc. Compile the source code to an executable application Program the target MCU Debug the application running on the target MCU Monitor the application on the target MCU The STM32Cube ecosystem is a complete software solution for STM32 microcontrollers and microprocessors. It has a complete tool chain and extended packages to well support developers on STM32 MCUs. STM32 Ecosystem STM32CubeMX , a configuration tool for any STM32 device. This easy-to-use graphical user interface generates initialization C code for Cortex-M cores and generates the Linux device tree source for Cortex-A cores. STM32CubeIDE , an Integrated Development Environment. Based on open-source solutions like Eclipse or the GNU C/C++ tool chain, this IDE includes compilation reporting features and advanced debug features. It also integrates additional features present in other tools from the ecosystem, such as the HW and SW initialization and code generation from STM32CubeMX. This software includes: Eclipse IDE \u2014 an open source code editor and manager which supports many plugins such as C/C++ Development Platform, GCC Cross-Compiler, GDB Hardware Debugger, Make and build scripts. GNU ARM Cross-compiler with ST patch for STM32 MCUs \u2014 a compiler that converts code to executable and linkable file (.elf) or binary file (.bin, .hex). GDB for inspecting, debugging the target application. STM32CubeProgrammer , a programming tool. It provides an easy-to-use and efficient environment for reading, writing and verifying devices and external memories via a wide variety of available communication media (JTAG, SWD, UART, USB DFU, I2C, SPI, CAN, etc.). STM32CubeMonitor , a monitoring tool. Powerful monitoring tools that help developers fine-tune the behavior and performance of their applications in real time. STM32Cube MCU and MPU packages , dedicated to each STM32 series. Packages offer all the required to be embedded software bricks to operate the available set of STM32 peripherals. They include drivers (HAL, low-layer, etc.), middleware, and lots of example code used in a wide variety of real-world use cases. STM32Cube expansion packages , for application-oriented solutions. Complementing and expanding the STM32Cube MCU Package offer with additional embedded software bricks, STM32 expansion packages come either from ST or approved partners to create an extensive and scalable embedded software offer around the STM32. 4 steps of an interactive development process 2. STM32CubeIDE \u2693\ufe0e STM32CubeIDE is an advanced C/C++ development platform with peripheral configuration, code generation, code compilation, and debug features for STM32 microcontrollers and microprocessors. It is based on the Eclipse\u00ae/CDT framework and GCC tool chain for the development, and GDB for the debugging. It allows the integration of the hundreds of existing plugins that complete the features of the Eclipse\u00ae IDE. This tool includes the STM32CubeMX for code generation. At any time during the development, the user can return to the initialization and configuration of the peripherals or middleware and regenerate the initialization code with no impact on the user code written in the user blocks. STM32CubeIDE includes build and stack analyzers that provide the user with useful information about project status and memory requirements. STM32CubeIDE also includes standard and advanced debugging features including views of CPU core registers, memories, and peripheral registers, as well as live variable watch, Serial Wire Viewer interface, or fault analyzer. Other IDEs that support ARM Cortex: ARM\u00ae, Atollic TrueSTUDIO\u00ae: was bought by ST, included in STM32CubeIDE Keil\u2122, MDK-ARM\u2122: only free for STM32F0 and STM32L0 processes Altium\u00ae, TASKING\u2122 VX-toolset: paid license IAR\u2122, EWARM (IAR Embedded Workbench\u00ae): paid license 2.1. Installation \u2693\ufe0e Download STM32CubeIDE STM32CubeIDE User Manual During the installation, please be sure to install ST-LINK and SEGGER J-Link drivers. 2.2. Create a workspace \u2693\ufe0e When start the program, it will ask to select a directory as a workspace \u2014 the location to save projects. Consider to make new workspaces for different big projects. Select a workspace Each workspace has its own Preferences settings under the Windows menu. Some personal settings Due to the generated code from STM32CubeMX is 2-space tab width, it is better to configure the Text Editor to adapt with the tab width behavior in General \u2192 Editor \u2192 Text Editor : Displayed tab width: 2 Insert spaces for tabs: Checked Remove multiple spaces on backspace/delete: Checked There are some options for Code Analysis under the C/C++ \u2192 Build . I recommended to enable some check for Potential Programming Problems : Assignment in condition if ( a = b ) No return in a function which is declared to return a value int func (){} Return without value int func(){ return;} Return the address of a local variable int* func(){int a; return &a;} Virtual method call in constructor/ destructor Next is the formatting style under the option C/C++ \u2192 Code Style \u2192 Formatter : Create a new profile from K&R In the Indentation , change Tab Policy to Space Only; then set Indentation size and Tab size both to 2. Finally, it should increase the buffer for terminals in Terminal option to 1000 or more. 2.3. Create a project \u2693\ufe0e It is recommended to start a new project with STM32CubeIDE as it will automatically configure the project for the selected target processor. When start a new STM32 project, IDE shows up the Device Finder screen first. There are options to select the target MCU/MPU by name, board, example, and cross-reference. The first project I am using a STM32F0-Discovery board (STM32F051R8) to make an example project for this post. This project does not require any knowledge about the target microprocessor, as it will be written like a normal C application. Select the target MCU by name After selecting the microprocessor, it\u2019s time to name the project, and select the STM32Cube MCU packages version for the selected target. In this example, it is STM32Cube FW F0 v1.11.2 . Set name and select firmware package for a new project Press on Finish then IDE will run a screen named Device Configuration Tool from the STM32CubeMX tool, in there, it\u2019s easy to enable any supported features in graphical mode. If the selected target is a development board, this tool will ask to use a default system config for the target board \u2014 usually including ST-Link pins, on-board buttons, LEDs, USB connect. 2.4. STM32CubeMX \u2693\ufe0e STM32CubeMX is a graphical tool that allows a very easy configuration of STM32 microcontrollers and microprocessors, as well as the generation of the corresponding initialization C code for the Arm\u00ae Cortex\u00ae-M cores. STM32CubeMX User Manual STM32CubeMX allows the user to create, save and load previously saved projects. MCU configuration .ioc file is saved in the project folder, and user can open it in the STM32CubeMX for editing. 2.4.1. Pinout Configuration \u2693\ufe0e This tab shows available Components in categories or in A-Z list. Select on a component will show its Configuration screen. The large Pinout view shows a graphic representation of the pin assignment. Left-click to select the function, and Right-click to do extra actions such as assigning a custom name. The Pinout config screen 2.4.2. Clock Configuration \u2693\ufe0e This tab provides a schematic overview of the clock paths, clock sources, dividers, and multipliers. Drop-down menus and buttons can be used to modify the actual clock tree configuration, to meet the application requirements. IDE has ability to automatically calculate multipliers and dividers to provide requested frequency, user can set a desired frequency in the clock node, and press enter, then IDE will re-configure the PLL, pre-scaler. The frequency on each node can be locked via the right-click menu. The Clock config screen 2.4.3. Project Manager \u2693\ufe0e This tab provides information about general project setting: to specify the project name, location, tool chain, and firmware version. It also has configs for code generation options such as the location of peripheral initialization code, library copy/link options, and to select templates for customized code. The Project config view 2.4.4. Code generation \u2693\ufe0e After configuring pins, save the settings first and then start generating code. Manually request to generate code by pressing Alt + K or choosing menu Project \u2192 Generate Code . The tool will create sub-folders and add necessary files into project. The general file structure is: \u2514\u2500\u2500\u2500Core \u2502 \u251c\u2500\u2500\u2500Inc \u2502 \u251c\u2500\u2500\u2500Src \u2502 \u2514\u2500\u2500\u2500Startup \u2514\u2500\u2500\u2500Drivers \u2514\u2500\u2500\u2500CMSIS \u2502 \u2514\u2500\u2500\u2500Device \u2502 \u2502 \u2514\u2500\u2500\u2500ST \u2502 \u2502 \u2514\u2500\u2500\u2500STM32F0xx \u2502 \u2502 \u2514\u2500\u2500\u2500Include \u2502 \u2502 \u2514\u2500\u2500\u2500Source \u2502 \u2502 \u2514\u2500\u2500\u2500Templates \u2502 \u2514\u2500\u2500\u2500Include \u2514\u2500\u2500\u2500STM32F0xx_HAL_Driver \u2514\u2500\u2500\u2500Inc \u2502 \u2514\u2500\u2500\u2500Legacy \u2514\u2500\u2500\u2500Src When chosen to use a Firmware Library in the project, IDE automatically uses ST Hardware Abstract Layer (HAL) library as the main way of controlling the processor and peripherals. HAL also makes use of Cortex Microcontroller Software Interface Standard (CMSIS) library to access processor\u2019s registers. In the Project Manager tab, it can change to use Low-Level (LL) library instead of HAL. Code dependency starts from the main.h source file. This file includes HAL files which eventually includes CMSIS files. The main function is called from the startup file startup_*.s . Code dependency A HAL driver includes the following set of files: File Description stm32f0xx_hal.h/.c This file is used for HAL initialization and contains DBGMCU, Remap and Time Delay based on SysTick APIs. This also include stm32f0xx_hal_def.h . stm32f0xx_hal_def.h Common HAL resources such as common define statements, enumerations, structures and macros. This includes CMSIS headers. stm32f0xx_hal_ppp.h/.c Main peripheral/module driver file. It includes the APIs that are common to all STM32 devices, example: stm32f0xx_hal_adc.c , stm32f0xx_hal_irda.c stm32f0xx_hal_ppp_ex.h/.c Extension file of a peripheral/module driver. It includes the specific APIs for a given part number or family, as well as the newly defined APIs that overwrite the default generic APIs if the internal process is implemented in different way, for example: stm32f0xx_hal_adc_ex.c , stm32f0xx_hal_flash_ex.c . The minimum files required to build an application using the HAL are listed in the table below: File Description startup_stm32f0xx.s Tool chain specific file that contains reset handler and exception vectors. For some tool chains, it allows adapting the stack/heap size to fit the application requirements system_stm32f0xx.c This file contains SystemInit() which is called at startup just after reset and before branching to the main program. It does not configure the system clock at startup (contrary to the standard library). This is to be done using the HAL APIs in the user files. It allows relocating the vector table in internal SRAM. stm32f0xx_hal_conf.h This file allows the user to customize the HAL drivers for a specific application. It is not mandatory to modify this configuration. The application can use the default configuration without any modification. This call to STM32F0 HAL headers. stm32f0xx_hal_msp.c This file contains the MSP initialization and deinitialization (main routine and callbacks) of the peripheral used in the user application. stm32f0xx_it.h/.c This file contains the exceptions handler and peripherals interrupt service routine, and calls HAL_IncTick() at regular time intervals to increment a local variable (declared in stm32f0xx_hal.c ) used as HAL time base. By default, this function is called each 1ms in SysTick ISR. The PPP_IRQHandler() routine must call HAL_PPP_IRQHandler() if an interrupt based process is used within the application. main.h/.c This file contains the main program routine, mainly: \u2022 call to HAL_Init() \u2022 set system clock configuration declare peripheral HAL initialization user application code. 2.5. Add user code \u2693\ufe0e User code sections are marked with a pair of phrases /* USER CODE BEGIN x */ and /* USER CODE END x */ . User code inside those marks are kept remaining during code generation. I am going to add a variable counter with type of char , then inside the main while loop in the main() function, increase it by 1 after 100ms. Don\u2019t mind the HAL function at this time. main.c /* USER CODE BEGIN PV */ char counter = 0 ; /* USER CODE END PV */ int main ( void ) { /* other setup function */ /* USER CODE BEGIN WHILE */ while ( 1 ) { counter ++ ; HAL_Delay ( 100 ); /* USER CODE END WHILE */ /* USER CODE BEGIN 3 */ } /* USER CODE END 3 */ } 2.6. Compiler options \u2693\ufe0e Project has options for the compiler under its properties. Right-click on the project name in the right panel, then select Properties menu. The default included folders are all the folders created in the project by the STM32CubeMX tool. There are also some symbols created for the project build, such DEBUG mode, or the MCU name STM32F051x8 . The including paths and symbols Then in the Build Options, there are options to be used by GCC compiler, GNU Linker, GNU Assembler. Build options 2.7. Build Project \u2693\ufe0e Build the application by pressing Ctrl + B , or in menu Project \u2192 Build All . There are some reports about the resource usage to check after the compilation. The first thing it reports is the memory usage, in terms of RAM and FLASH free space. 2.8. Setup debugger \u2693\ufe0e Before Run or Debug on the target chip, it is needed to configure the programming/ debugging interface. By default, the application code can be programmed through the debugger interface, therefore, in Run Config or Debug Config, there is a tab named Debugger to select: Debug Probe: ST-LINK GDB, ST-LINK OpenOCD, SEGGER J-LINK, or other available probes Interface: SWD or JTAG. If there are multiple boards connected, use debugger board Serial Number to choose the correct target Advanced features: Serial Wire Viewer: read data from MCU in a dedicated SW0 pin, available on Cortext-M3 and above Live Expression: read out the value at a memory address without halting the CPU Setup Debugger 2.9. Run Mode \u2693\ufe0e In the Run Mode, IDE flashes the firmware via the Debugging interface, and then disconnect the debugger to make the target board run freely. Just use the menu Run \u2192 Run . 2.10. Debug Mode \u2693\ufe0e Putting the target under the Debug Mode is to control its execution, step by step. Breakpoint is where the CPU will be halted and debugger will inspect its current status: registers, memory values. By default, the first breakpoint is right after entering the main function. The start address and the first break point can be set in the Startup tab in Debug Configurations. Startup option for debug When CPU is halted at a breakpoint, user can control the execution step by step, through the commands or buttons: Debug controls 3. STM32CubeProgrammer \u2693\ufe0e STM32CubeProgrammer (previous name was ST-Link Utility) provides an easy-to-use and efficient environment for reading, writing and verifying device memory through both the debug interface (JTAG and SWD) and the bootloader interface (UART, USB DFU, I2C, SPI, and CAN). STM32CubeProgrammer offers a wide range of features to program STM32 internal memories (such as Flash, RAM, and OTP) as well as external memories. Download STM32CubeProgrammer STM32CubeProgrammer User Manual STM32 Programmer 3.1. Target connection \u2693\ufe0e On the original development boards, please select ST-LINK interface, and then select either SWD or JTAG port. If the custom board has a USB port with Device Firmware Update mode, it can be connected on the USB interface. Before pressing Connect on the software, find on the board to press and hold the Boot button (Boot0 or Boot1) and press Reset button (NRST) to make device run into DFU mode. Different connections 3.2. Erase and Program \u2693\ufe0e Once connected to a target, the memory sectors are displayed in the right-hand panel showing the start address and the size of each sector. To erase one or more sectors, select them in the first column and then click on the Erase selected sectors button. To download firmware to the target chip, select the Erasing & Programming tab. Click on the browse button and select the file to be programmed. The file format supported are binary files ( .bin ), ELF files ( .elf , .axf , .out ), Intel hex files ( .hex ) and Motorola S-record files ( .srec ). In case of programming a binary file, the address must be set. 3.3. Other features \u2693\ufe0e Other advanced features will be covered in other posts. Here is the list of those features: Option Bytes CPU Instruction debug Serial Wire View Fault Analyzer External Flash programming Program a binary file 4. STM32CubeMonitor \u2693\ufe0e The STM32CubeMonitor helps to fine-tune and diagnose STM32 applications at run-time by reading and visualizing their variables in real-time. It provides a flow-based graphical editor to build custom dashboards simply, and quickly add widgets such as gauges, bar graphs and plots. With non-intrusive monitoring, STM32CubeMonitor preserves the real-time behavior of applications, and perfectly complements traditional debugging tools to perform application profiling. Download STM32CubeMonitor STM32CubeMonitor Guide This tool use SWD/JTAG interface to access the memory addresses and read their value. The block editor When start the tool, there is a basic flow created with: Start/ Stop/ Clear buttons myVariables block holds the addresses under monitoring myProbe_Out block has configs to connect to the target device through debug interface myProbe_In block has script to read the value of the addresses listed in the myVariables block myVariables processing block read the captured value and process it myChart displays the dashboard which visualizes the processed data To configure a block, double-click on it, and follow the guide. The steps go through file selection, variable list, connect probe, and assign probe. To demonstrate how it works, add a counter variable of type char as a global variable in the main.c file. In the main loop, increase the counter value every 100ms. This variable will be shown in the list of variables after selecting the compiled .elf firmware file. Configure the variable block Connect the target board via ST-LINK or other SWD/ JTAG compatible debugger. The debugger will be shown a probe in the STM32CubeMonitor. Select the protocol and assign to the in or out probe. Configure the probe block The chart can be drawn in line or bar chart. At this time, just use a default one. Finally, press on Deploy to configure the probes, and then click on Dashboard to show the graphical interface. Start button will send start message to the probe and variable processing block. The captured data will be drawn on the chart. The interactive dashboard 5. Other tools \u2693\ufe0e There are many other tools that work on ARM cores. I will have other posts to share about those tools such as Cross-Compiler, Config File, Make File, or System View.","title":"Toolchain"},{"location":"blog/stm32/tools/#1-stm32-ecosystem","text":"A tool-chain is a set of programming tools that allow developers to: Configure the settings on the target MCU Write code and navigate inside source files of the project Inspect the code to show additional information about variables, function definitions, etc. Compile the source code to an executable application Program the target MCU Debug the application running on the target MCU Monitor the application on the target MCU The STM32Cube ecosystem is a complete software solution for STM32 microcontrollers and microprocessors. It has a complete tool chain and extended packages to well support developers on STM32 MCUs. STM32 Ecosystem STM32CubeMX , a configuration tool for any STM32 device. This easy-to-use graphical user interface generates initialization C code for Cortex-M cores and generates the Linux device tree source for Cortex-A cores. STM32CubeIDE , an Integrated Development Environment. Based on open-source solutions like Eclipse or the GNU C/C++ tool chain, this IDE includes compilation reporting features and advanced debug features. It also integrates additional features present in other tools from the ecosystem, such as the HW and SW initialization and code generation from STM32CubeMX. This software includes: Eclipse IDE \u2014 an open source code editor and manager which supports many plugins such as C/C++ Development Platform, GCC Cross-Compiler, GDB Hardware Debugger, Make and build scripts. GNU ARM Cross-compiler with ST patch for STM32 MCUs \u2014 a compiler that converts code to executable and linkable file (.elf) or binary file (.bin, .hex). GDB for inspecting, debugging the target application. STM32CubeProgrammer , a programming tool. It provides an easy-to-use and efficient environment for reading, writing and verifying devices and external memories via a wide variety of available communication media (JTAG, SWD, UART, USB DFU, I2C, SPI, CAN, etc.). STM32CubeMonitor , a monitoring tool. Powerful monitoring tools that help developers fine-tune the behavior and performance of their applications in real time. STM32Cube MCU and MPU packages , dedicated to each STM32 series. Packages offer all the required to be embedded software bricks to operate the available set of STM32 peripherals. They include drivers (HAL, low-layer, etc.), middleware, and lots of example code used in a wide variety of real-world use cases. STM32Cube expansion packages , for application-oriented solutions. Complementing and expanding the STM32Cube MCU Package offer with additional embedded software bricks, STM32 expansion packages come either from ST or approved partners to create an extensive and scalable embedded software offer around the STM32. 4 steps of an interactive development process","title":"1. STM32 Ecosystem"},{"location":"blog/stm32/tools/#2-stm32cubeide","text":"STM32CubeIDE is an advanced C/C++ development platform with peripheral configuration, code generation, code compilation, and debug features for STM32 microcontrollers and microprocessors. It is based on the Eclipse\u00ae/CDT framework and GCC tool chain for the development, and GDB for the debugging. It allows the integration of the hundreds of existing plugins that complete the features of the Eclipse\u00ae IDE. This tool includes the STM32CubeMX for code generation. At any time during the development, the user can return to the initialization and configuration of the peripherals or middleware and regenerate the initialization code with no impact on the user code written in the user blocks. STM32CubeIDE includes build and stack analyzers that provide the user with useful information about project status and memory requirements. STM32CubeIDE also includes standard and advanced debugging features including views of CPU core registers, memories, and peripheral registers, as well as live variable watch, Serial Wire Viewer interface, or fault analyzer. Other IDEs that support ARM Cortex: ARM\u00ae, Atollic TrueSTUDIO\u00ae: was bought by ST, included in STM32CubeIDE Keil\u2122, MDK-ARM\u2122: only free for STM32F0 and STM32L0 processes Altium\u00ae, TASKING\u2122 VX-toolset: paid license IAR\u2122, EWARM (IAR Embedded Workbench\u00ae): paid license","title":"2. STM32CubeIDE"},{"location":"blog/stm32/tools/#21-installation","text":"Download STM32CubeIDE STM32CubeIDE User Manual During the installation, please be sure to install ST-LINK and SEGGER J-Link drivers.","title":"2.1. Installation"},{"location":"blog/stm32/tools/#22-create-a-workspace","text":"When start the program, it will ask to select a directory as a workspace \u2014 the location to save projects. Consider to make new workspaces for different big projects. Select a workspace Each workspace has its own Preferences settings under the Windows menu. Some personal settings Due to the generated code from STM32CubeMX is 2-space tab width, it is better to configure the Text Editor to adapt with the tab width behavior in General \u2192 Editor \u2192 Text Editor : Displayed tab width: 2 Insert spaces for tabs: Checked Remove multiple spaces on backspace/delete: Checked There are some options for Code Analysis under the C/C++ \u2192 Build . I recommended to enable some check for Potential Programming Problems : Assignment in condition if ( a = b ) No return in a function which is declared to return a value int func (){} Return without value int func(){ return;} Return the address of a local variable int* func(){int a; return &a;} Virtual method call in constructor/ destructor Next is the formatting style under the option C/C++ \u2192 Code Style \u2192 Formatter : Create a new profile from K&R In the Indentation , change Tab Policy to Space Only; then set Indentation size and Tab size both to 2. Finally, it should increase the buffer for terminals in Terminal option to 1000 or more.","title":"2.2. Create a workspace"},{"location":"blog/stm32/tools/#23-create-a-project","text":"It is recommended to start a new project with STM32CubeIDE as it will automatically configure the project for the selected target processor. When start a new STM32 project, IDE shows up the Device Finder screen first. There are options to select the target MCU/MPU by name, board, example, and cross-reference. The first project I am using a STM32F0-Discovery board (STM32F051R8) to make an example project for this post. This project does not require any knowledge about the target microprocessor, as it will be written like a normal C application. Select the target MCU by name After selecting the microprocessor, it\u2019s time to name the project, and select the STM32Cube MCU packages version for the selected target. In this example, it is STM32Cube FW F0 v1.11.2 . Set name and select firmware package for a new project Press on Finish then IDE will run a screen named Device Configuration Tool from the STM32CubeMX tool, in there, it\u2019s easy to enable any supported features in graphical mode. If the selected target is a development board, this tool will ask to use a default system config for the target board \u2014 usually including ST-Link pins, on-board buttons, LEDs, USB connect.","title":"2.3. Create a project"},{"location":"blog/stm32/tools/#24-stm32cubemx","text":"STM32CubeMX is a graphical tool that allows a very easy configuration of STM32 microcontrollers and microprocessors, as well as the generation of the corresponding initialization C code for the Arm\u00ae Cortex\u00ae-M cores. STM32CubeMX User Manual STM32CubeMX allows the user to create, save and load previously saved projects. MCU configuration .ioc file is saved in the project folder, and user can open it in the STM32CubeMX for editing.","title":"2.4. STM32CubeMX"},{"location":"blog/stm32/tools/#241-pinout-configuration","text":"This tab shows available Components in categories or in A-Z list. Select on a component will show its Configuration screen. The large Pinout view shows a graphic representation of the pin assignment. Left-click to select the function, and Right-click to do extra actions such as assigning a custom name. The Pinout config screen","title":"2.4.1. Pinout Configuration"},{"location":"blog/stm32/tools/#242-clock-configuration","text":"This tab provides a schematic overview of the clock paths, clock sources, dividers, and multipliers. Drop-down menus and buttons can be used to modify the actual clock tree configuration, to meet the application requirements. IDE has ability to automatically calculate multipliers and dividers to provide requested frequency, user can set a desired frequency in the clock node, and press enter, then IDE will re-configure the PLL, pre-scaler. The frequency on each node can be locked via the right-click menu. The Clock config screen","title":"2.4.2. Clock Configuration"},{"location":"blog/stm32/tools/#243-project-manager","text":"This tab provides information about general project setting: to specify the project name, location, tool chain, and firmware version. It also has configs for code generation options such as the location of peripheral initialization code, library copy/link options, and to select templates for customized code. The Project config view","title":"2.4.3. Project Manager"},{"location":"blog/stm32/tools/#244-code-generation","text":"After configuring pins, save the settings first and then start generating code. Manually request to generate code by pressing Alt + K or choosing menu Project \u2192 Generate Code . The tool will create sub-folders and add necessary files into project. The general file structure is: \u2514\u2500\u2500\u2500Core \u2502 \u251c\u2500\u2500\u2500Inc \u2502 \u251c\u2500\u2500\u2500Src \u2502 \u2514\u2500\u2500\u2500Startup \u2514\u2500\u2500\u2500Drivers \u2514\u2500\u2500\u2500CMSIS \u2502 \u2514\u2500\u2500\u2500Device \u2502 \u2502 \u2514\u2500\u2500\u2500ST \u2502 \u2502 \u2514\u2500\u2500\u2500STM32F0xx \u2502 \u2502 \u2514\u2500\u2500\u2500Include \u2502 \u2502 \u2514\u2500\u2500\u2500Source \u2502 \u2502 \u2514\u2500\u2500\u2500Templates \u2502 \u2514\u2500\u2500\u2500Include \u2514\u2500\u2500\u2500STM32F0xx_HAL_Driver \u2514\u2500\u2500\u2500Inc \u2502 \u2514\u2500\u2500\u2500Legacy \u2514\u2500\u2500\u2500Src When chosen to use a Firmware Library in the project, IDE automatically uses ST Hardware Abstract Layer (HAL) library as the main way of controlling the processor and peripherals. HAL also makes use of Cortex Microcontroller Software Interface Standard (CMSIS) library to access processor\u2019s registers. In the Project Manager tab, it can change to use Low-Level (LL) library instead of HAL. Code dependency starts from the main.h source file. This file includes HAL files which eventually includes CMSIS files. The main function is called from the startup file startup_*.s . Code dependency A HAL driver includes the following set of files: File Description stm32f0xx_hal.h/.c This file is used for HAL initialization and contains DBGMCU, Remap and Time Delay based on SysTick APIs. This also include stm32f0xx_hal_def.h . stm32f0xx_hal_def.h Common HAL resources such as common define statements, enumerations, structures and macros. This includes CMSIS headers. stm32f0xx_hal_ppp.h/.c Main peripheral/module driver file. It includes the APIs that are common to all STM32 devices, example: stm32f0xx_hal_adc.c , stm32f0xx_hal_irda.c stm32f0xx_hal_ppp_ex.h/.c Extension file of a peripheral/module driver. It includes the specific APIs for a given part number or family, as well as the newly defined APIs that overwrite the default generic APIs if the internal process is implemented in different way, for example: stm32f0xx_hal_adc_ex.c , stm32f0xx_hal_flash_ex.c . The minimum files required to build an application using the HAL are listed in the table below: File Description startup_stm32f0xx.s Tool chain specific file that contains reset handler and exception vectors. For some tool chains, it allows adapting the stack/heap size to fit the application requirements system_stm32f0xx.c This file contains SystemInit() which is called at startup just after reset and before branching to the main program. It does not configure the system clock at startup (contrary to the standard library). This is to be done using the HAL APIs in the user files. It allows relocating the vector table in internal SRAM. stm32f0xx_hal_conf.h This file allows the user to customize the HAL drivers for a specific application. It is not mandatory to modify this configuration. The application can use the default configuration without any modification. This call to STM32F0 HAL headers. stm32f0xx_hal_msp.c This file contains the MSP initialization and deinitialization (main routine and callbacks) of the peripheral used in the user application. stm32f0xx_it.h/.c This file contains the exceptions handler and peripherals interrupt service routine, and calls HAL_IncTick() at regular time intervals to increment a local variable (declared in stm32f0xx_hal.c ) used as HAL time base. By default, this function is called each 1ms in SysTick ISR. The PPP_IRQHandler() routine must call HAL_PPP_IRQHandler() if an interrupt based process is used within the application. main.h/.c This file contains the main program routine, mainly: \u2022 call to HAL_Init() \u2022 set system clock configuration declare peripheral HAL initialization user application code.","title":"2.4.4. Code generation"},{"location":"blog/stm32/tools/#25-add-user-code","text":"User code sections are marked with a pair of phrases /* USER CODE BEGIN x */ and /* USER CODE END x */ . User code inside those marks are kept remaining during code generation. I am going to add a variable counter with type of char , then inside the main while loop in the main() function, increase it by 1 after 100ms. Don\u2019t mind the HAL function at this time. main.c /* USER CODE BEGIN PV */ char counter = 0 ; /* USER CODE END PV */ int main ( void ) { /* other setup function */ /* USER CODE BEGIN WHILE */ while ( 1 ) { counter ++ ; HAL_Delay ( 100 ); /* USER CODE END WHILE */ /* USER CODE BEGIN 3 */ } /* USER CODE END 3 */ }","title":"2.5. Add user code"},{"location":"blog/stm32/tools/#26-compiler-options","text":"Project has options for the compiler under its properties. Right-click on the project name in the right panel, then select Properties menu. The default included folders are all the folders created in the project by the STM32CubeMX tool. There are also some symbols created for the project build, such DEBUG mode, or the MCU name STM32F051x8 . The including paths and symbols Then in the Build Options, there are options to be used by GCC compiler, GNU Linker, GNU Assembler. Build options","title":"2.6. Compiler options"},{"location":"blog/stm32/tools/#27-build-project","text":"Build the application by pressing Ctrl + B , or in menu Project \u2192 Build All . There are some reports about the resource usage to check after the compilation. The first thing it reports is the memory usage, in terms of RAM and FLASH free space.","title":"2.7. Build Project"},{"location":"blog/stm32/tools/#28-setup-debugger","text":"Before Run or Debug on the target chip, it is needed to configure the programming/ debugging interface. By default, the application code can be programmed through the debugger interface, therefore, in Run Config or Debug Config, there is a tab named Debugger to select: Debug Probe: ST-LINK GDB, ST-LINK OpenOCD, SEGGER J-LINK, or other available probes Interface: SWD or JTAG. If there are multiple boards connected, use debugger board Serial Number to choose the correct target Advanced features: Serial Wire Viewer: read data from MCU in a dedicated SW0 pin, available on Cortext-M3 and above Live Expression: read out the value at a memory address without halting the CPU Setup Debugger","title":"2.8. Setup debugger"},{"location":"blog/stm32/tools/#29-run-mode","text":"In the Run Mode, IDE flashes the firmware via the Debugging interface, and then disconnect the debugger to make the target board run freely. Just use the menu Run \u2192 Run .","title":"2.9. Run Mode"},{"location":"blog/stm32/tools/#210-debug-mode","text":"Putting the target under the Debug Mode is to control its execution, step by step. Breakpoint is where the CPU will be halted and debugger will inspect its current status: registers, memory values. By default, the first breakpoint is right after entering the main function. The start address and the first break point can be set in the Startup tab in Debug Configurations. Startup option for debug When CPU is halted at a breakpoint, user can control the execution step by step, through the commands or buttons: Debug controls","title":"2.10. Debug Mode"},{"location":"blog/stm32/tools/#3-stm32cubeprogrammer","text":"STM32CubeProgrammer (previous name was ST-Link Utility) provides an easy-to-use and efficient environment for reading, writing and verifying device memory through both the debug interface (JTAG and SWD) and the bootloader interface (UART, USB DFU, I2C, SPI, and CAN). STM32CubeProgrammer offers a wide range of features to program STM32 internal memories (such as Flash, RAM, and OTP) as well as external memories. Download STM32CubeProgrammer STM32CubeProgrammer User Manual STM32 Programmer","title":"3. STM32CubeProgrammer"},{"location":"blog/stm32/tools/#31-target-connection","text":"On the original development boards, please select ST-LINK interface, and then select either SWD or JTAG port. If the custom board has a USB port with Device Firmware Update mode, it can be connected on the USB interface. Before pressing Connect on the software, find on the board to press and hold the Boot button (Boot0 or Boot1) and press Reset button (NRST) to make device run into DFU mode. Different connections","title":"3.1. Target connection"},{"location":"blog/stm32/tools/#32-erase-and-program","text":"Once connected to a target, the memory sectors are displayed in the right-hand panel showing the start address and the size of each sector. To erase one or more sectors, select them in the first column and then click on the Erase selected sectors button. To download firmware to the target chip, select the Erasing & Programming tab. Click on the browse button and select the file to be programmed. The file format supported are binary files ( .bin ), ELF files ( .elf , .axf , .out ), Intel hex files ( .hex ) and Motorola S-record files ( .srec ). In case of programming a binary file, the address must be set.","title":"3.2. Erase and Program"},{"location":"blog/stm32/tools/#33-other-features","text":"Other advanced features will be covered in other posts. Here is the list of those features: Option Bytes CPU Instruction debug Serial Wire View Fault Analyzer External Flash programming Program a binary file","title":"3.3. Other features"},{"location":"blog/stm32/tools/#4-stm32cubemonitor","text":"The STM32CubeMonitor helps to fine-tune and diagnose STM32 applications at run-time by reading and visualizing their variables in real-time. It provides a flow-based graphical editor to build custom dashboards simply, and quickly add widgets such as gauges, bar graphs and plots. With non-intrusive monitoring, STM32CubeMonitor preserves the real-time behavior of applications, and perfectly complements traditional debugging tools to perform application profiling. Download STM32CubeMonitor STM32CubeMonitor Guide This tool use SWD/JTAG interface to access the memory addresses and read their value. The block editor When start the tool, there is a basic flow created with: Start/ Stop/ Clear buttons myVariables block holds the addresses under monitoring myProbe_Out block has configs to connect to the target device through debug interface myProbe_In block has script to read the value of the addresses listed in the myVariables block myVariables processing block read the captured value and process it myChart displays the dashboard which visualizes the processed data To configure a block, double-click on it, and follow the guide. The steps go through file selection, variable list, connect probe, and assign probe. To demonstrate how it works, add a counter variable of type char as a global variable in the main.c file. In the main loop, increase the counter value every 100ms. This variable will be shown in the list of variables after selecting the compiled .elf firmware file. Configure the variable block Connect the target board via ST-LINK or other SWD/ JTAG compatible debugger. The debugger will be shown a probe in the STM32CubeMonitor. Select the protocol and assign to the in or out probe. Configure the probe block The chart can be drawn in line or bar chart. At this time, just use a default one. Finally, press on Deploy to configure the probes, and then click on Dashboard to show the graphical interface. Start button will send start message to the probe and variable processing block. The captured data will be drawn on the chart. The interactive dashboard","title":"4. STM32CubeMonitor"},{"location":"blog/stm32/tools/#5-other-tools","text":"There are many other tools that work on ARM cores. I will have other posts to share about those tools such as Cross-Compiler, Config File, Make File, or System View.","title":"5. Other tools"},{"location":"blog/stm32/uart/","text":"UART in Polling mode UART in Interrupt mode UART in DMA mode 1. Hardware \u2693\ufe0e Universal Synchronous/Asynchronous Receiver/Transmitter interface, also simply known as USART, is a device that translates a parallel sequence of bits (usually grouped in a byte) in a continuous stream of signals flowing on a single wire. 1.1. Wires \u2693\ufe0e When the information flows between two devices inside a common channel, both devices (as the sender and also the receiver) have to agree on the timing , that defines how long it takes to transmit each individual bit of the information. In a synchronous transmission, the sender and the receiver share a common clock generated by one of the two devices Shared clock in synchronous USART In an asynchronous transmission, the clock line is omitted, and both devices have an internal clock source and a mechanism to detect start/ stop bit. One line of data in asynchronous USART In a bi-direction communication, it needs a pair of lines for Transmitter (TX) and Receiver (RX): USART vs UART 1.2. Flow control \u2693\ufe0e The presence of a dedicated clock line, or a common agreement about transmission frequency, does not guarantee that the receiver of a byte stream is able to process them at the same transmission rate of the master. For this reason, some communication standards, like the RS232 and the RS485, provide the possibility to use a dedicated Hardware Flow Control line. For example, two devices communicating using the RS232 interface can share two additional lines, named Request To Send (RTS) and Clear To Send (CTS) : the sender sets its RTS, which signals the receiver to begin monitoring its data input line. When ready for data, the receiver will raise its complementary line, CTS, which signals the sender to start sending data, and for the sender to begin monitoring the slave\u2019s data output line. 1.3. Data frame \u2693\ufe0e The frames are comprised of: An Idle Line prior to transmission or reception A start bit A data word (7, 8 or 9 bits) with the least significant bit first A 0.5, 1, 1.5, or 2 stop bits indicating that the frame is complete By default, the signal (TX or RX) is in low state during the start bit. It is in high state during the stop bit. These values can be inverted, separately for each signal, through polarity configuration control. An Idle character is interpreted as an entire frame of \u201c1\u201ds (the number of \u201c1\u201ds includes the number of stop bits). A Break character is interpreted on receiving \u201c0\u201ds for a frame period. At the end of the break frame, the transmitter inserts 2 stop bits. Frames in USART 1.4. Clock \u2693\ufe0e The choice of the clock source is done through the Clock Control system (see Section Reset and clock control (RCC) ). The clock source must be chosen before enabling the USART (by setting the UE bit). Choosing LSE or HSI as clock source may allow the USART to receive data while the MCU is in low-power mode. Clock source is used to do oversampling by 16 or by 8 to detect the start bit. It samples the RX line and try to detect a falling edge and following patterns of zeros. Detect start bit using oversampling 1.5. Baud rate \u2693\ufe0e Baud rate determines the speed of transmitting and receiving, as the speed depends on the clock source and USARTDIV value. USARTDIV is an unsigned fixed point number that is coded on the USART_BRR register. When OVER8 = 0, BRR = USARTDIV . When OVER8 = 1: BRR[2:0] = USARTDIV[3:0] shifted 1 bit to the right. BRR[3] must be kept cleared. BRR[15:4] = USARTDIV[15:4]. Example: To obtain 9600 baud with core clock frequency at 8 MHz. In case of oversampling by 16: BRR = USARTDIV = 8 000 000/9600 = 833d = 0341h In case of oversampling by 8: USARTDIV = 2 * 8 000 000/9600 = 1666,66 (~1667d) = 683h BRR[3:0] = 3h >> 1 = 1h BRR = 0x681 Auto baud rate detection The USART is able to detect and automatically set the USART_BRR register value based on the reception of one character. Automatic baud rate detection is useful under two circumstances: The communication speed of the system is not known in advance The system is using a relatively low accuracy clock source and this mechanism allows the correct baud rate to be obtained without measuring the clock deviation. Before activating the auto baud rate detection, the auto baud rate detection mode must be chosen. There are various modes based on different character patterns. Prior to activating auto baud rate detection, the USART_BRR register must be initialized by writing a non-zero baud rate value. 1.6. Multiprocessor \u2693\ufe0e In multiprocessor communication, the following bits are to be kept cleared: LINEN bit in the USART_CR2 register, HDSEL , IREN and SCEN bits in the USART_CR3 register. It is possible to perform multiprocessor communication with the USART (with several USARTs connected in a network). For instance one of the USARTs can be the master, its TX output connected to the RX inputs of the other USARTs. The others are slaves, their respective TX outputs are logically AND ed together and connected to the RX input of the master. 2. STM32CubeHAL Usage \u2693\ufe0e The Hardware Abstract Layer (HAL) is designed so that it abstracts from the specific peripheral memory mapping. But, it also provides a general and more user-friendly way to configure the peripheral, without forcing the programmers to now how to configure its registers in detail. Excerpt from Description of STM32F0 HAL and low-layer drivers How to use USART HAL Declare a UART_HandleTypeDef handle structure (e.g. UART_HandleTypeDef huart ). Initialize the UART low level resources by implementing the HAL_UART_MspInit() API when needed: Enable the USARTx interface clock. UART pins configuration: Enable the clock for the UART GPIOs. Configure these UART pins as alternate function pull-up. NVIC configuration if you use interrupt process ( HAL_UART_Transmit_IT() and HAL_UART_Receive_IT() APIs): Configure the USARTx interrupt priority. Enable the NVIC USART IRQ handle. UART interrupts handling: DMA Configuration if you use DMA process ( HAL_UART_Transmit_DMA() and HAL_UART_Receive_DMA() APIs): Declare a DMA handle structure for the Tx/Rx channel. Enable the DMAx interface clock. Configure the declared DMA handle structure with the required Tx/Rx parameters. Configure the DMA Tx/Rx channel. Associate the initialized DMA handle to the UART DMA Tx/Rx handle. Configure the priority and enable the NVIC for the transfer complete interrupt on the DMA Tx/Rx channel. Program the Baud Rate, Word Length, Stop Bit, Parity, Hardware flow control and Mode (Receiver/Transmitter) in the huart handle initial structure. If required, program UART advanced features (TX/RX pins swap, auto Baud rate detection, etc.) in the huart handle AdvancedInit structure. For the UART asynchronous mode, initialize the UART registers by calling the HAL_UART_Init() API. For the UART Half duplex mode, initialize the UART registers by calling the HAL_HalfDuplex_Init() API. For the UART Multiprocessor mode, initialize the UART registers by calling the HAL_MultiProcessor_Init() API. For the UART RS485 Driver Enabled mode, initialize the UART registers by calling the HAL_RS485Ex_Init() API. 3. Lab 1: Polling mode \u2693\ufe0e This project aims to learn how to configure USART via STM32CubeIDE and STM32CubeMX in polling mode. In polling mode, also called blocking mode, the main application, or one of its threads, synchronously waits for the data transmission and reception. This is the simplest form of data communication using this peripheral, and it can be used when the transmit rate is not too much low and when the UART is not used as critical peripheral. Requirements : Increase a counter by 1 and print its value to UART1 every second Get user commands: stop to pause increasing the counter resume to resume increasing the counter Target board : Any board which has STM32 MCUs. This tutorial will be using the STM32F0 Discovery board, which features an STM32F051R8 Cortex-M0 MCU. STM32F051R8 Mode External peripheral PA9 Alternate Function UART1 TX PA10 Alternate Function UART1 RX PC9 GPIO Output Green LED 3.1. Start a new project \u2693\ufe0e Open STM32CubeIDE and create a new STM32 with STM32F051R8 MCU by selecting the target board or just the target MCU. Make sure to configure below settings: Set the HLCK to 48 MHz Set the Debug mode to Debug Serial Wire or Trace Asynchronous SW 3.2. Enable USART1 \u2693\ufe0e Open Connectivity section in Pinout & Configs tab and select USART1 module, then edit some settings: Mode: Asynchronous Parameter: Baud rate: 115200 bps Word length: 8 bits (including Parity) Parity: None Stop bits: 1 Enable USART1 Note that PA9 and PA10 are automatically configured to Alternative Function to use as USART1 pinout. 3.3. Generated code \u2693\ufe0e When generate code from configs, there are some noticeable code blocks: Peripheral instance IDE will add an instance handler for the USART1 module in main.c . This instance will be used for manage USART1 peripheral then it should be global access: UART_HandleTypeDef huart1 ; Initializing functions The function SystemClock_Config() is included to set up the system clock, bus clocks. In addition, it will set the clock source for the USART1: void SystemClock_Config ( void ) { RCC_OscInitTypeDef RCC_OscInitStruct = { 0 }; RCC_ClkInitTypeDef RCC_ClkInitStruct = { 0 }; RCC_PeriphCLKInitTypeDef PeriphClkInit = { 0 }; /** Initializes the RCC Oscillators according to the specified parameters in the RCC_OscInitTypeDef structure. */ RCC_OscInitStruct . OscillatorType = RCC_OSCILLATORTYPE_HSI ; RCC_OscInitStruct . HSIState = RCC_HSI_ON ; RCC_OscInitStruct . HSICalibrationValue = RCC_HSICALIBRATION_DEFAULT ; RCC_OscInitStruct . PLL . PLLState = RCC_PLL_ON ; RCC_OscInitStruct . PLL . PLLSource = RCC_PLLSOURCE_HSI ; RCC_OscInitStruct . PLL . PLLMUL = RCC_PLL_MUL12 ; RCC_OscInitStruct . PLL . PREDIV = RCC_PREDIV_DIV1 ; if ( HAL_RCC_OscConfig ( & RCC_OscInitStruct ) != HAL_OK ) { Error_Handler (); } /** Initializes the CPU, AHB and APB buses clocks */ RCC_ClkInitStruct . ClockType = RCC_CLOCKTYPE_HCLK | RCC_CLOCKTYPE_SYSCLK | RCC_CLOCKTYPE_PCLK1 ; RCC_ClkInitStruct . SYSCLKSource = RCC_SYSCLKSOURCE_PLLCLK ; RCC_ClkInitStruct . AHBCLKDivider = RCC_SYSCLK_DIV1 ; RCC_ClkInitStruct . APB1CLKDivider = RCC_HCLK_DIV1 ; if ( HAL_RCC_ClockConfig ( & RCC_ClkInitStruct , FLASH_LATENCY_1 ) != HAL_OK ) { Error_Handler (); } PeriphClkInit . PeriphClockSelection = RCC_PERIPHCLK_USART1 ; PeriphClkInit . Usart1ClockSelection = RCC_USART1CLKSOURCE_PCLK1 ; if ( HAL_RCCEx_PeriphCLKConfig ( & PeriphClkInit ) != HAL_OK ) { Error_Handler (); } } The function MX_USART1_UART_Init() initializes the USART1 instance with the values put into the initial struct. This function, at the end, calls to HAL_UART_Init() which is an HAL function to check the initial parameters and finally calls to HAL_UART_MspInit() to do low-level configs. static void MX_USART1_UART_Init ( void ) { huart1 . Instance = USART1 ; huart1 . Init . BaudRate = 115200 ; huart1 . Init . WordLength = UART_WORDLENGTH_8B ; huart1 . Init . StopBits = UART_STOPBITS_1 ; huart1 . Init . Parity = UART_PARITY_NONE ; huart1 . Init . Mode = UART_MODE_TX_RX ; huart1 . Init . HwFlowCtl = UART_HWCONTROL_NONE ; huart1 . Init . OverSampling = UART_OVERSAMPLING_16 ; huart1 . Init . OneBitSampling = UART_ONE_BIT_SAMPLE_DISABLE ; huart1 . AdvancedInit . AdvFeatureInit = UART_ADVFEATURE_NO_INIT ; if ( HAL_UART_Init ( & huart1 ) != HAL_OK ) { Error_Handler (); } } The function HAL_UART_MspInit() is generated in stm32f0xx_hal_msp.c to override the function declared in HAL Lib. This low-level config will set up the peripheral clocks, and set alternative functions on GPIO pins. void HAL_UART_MspInit ( UART_HandleTypeDef * huart ) { GPIO_InitTypeDef GPIO_InitStruct = { 0 }; if ( huart -> Instance == USART1 ) { /* Peripheral clock enable */ __HAL_RCC_USART1_CLK_ENABLE (); __HAL_RCC_GPIOA_CLK_ENABLE (); /**USART1 GPIO Configuration PA9 ------> USART1_TX PA10 ------> USART1_RX */ GPIO_InitStruct . Pin = GPIO_PIN_9 | GPIO_PIN_10 ; GPIO_InitStruct . Mode = GPIO_MODE_AF_PP ; GPIO_InitStruct . Pull = GPIO_NOPULL ; GPIO_InitStruct . Speed = GPIO_SPEED_FREQ_HIGH ; GPIO_InitStruct . Alternate = GPIO_AF1_USART1 ; HAL_GPIO_Init ( GPIOA , & GPIO_InitStruct ); } } 3.4. Send data \u2693\ufe0e With generated code, just need to use HAL_UART_Transmit() function to send a buffer over the USART instance. Let\u2019s create a buffer, a counter variable, and make a message to send every second. #include <stdio.h> // sprintf #include <string.h> // strlen char counter = 0 ; char buffer [ 16 ] = { 0 }; // counter=xxx\\n\\r int main ( void ) { while ( 1 ) { counter ++ ; sprintf ( buffer , \"counter=%03d \\n\\r \" , counter ); HAL_UART_Transmit ( & huart1 , ( uint8_t * ) buffer , strlen ( buffer ), HAL_MAX_DELAY ); HAL_Delay ( 1000 ); } } 3.5. Connect UART to PC \u2693\ufe0e Because STM32F0 Discovery does not have a Virtual COM port on ST-LINK/V2, so use a TTL-to-USB converter go get UART data. Connect pins PA9 and PA10 to UART terminal on PC. It\u2019s recommend to check the voltage because MCU board is running at 3.3V while PC USB or COM port might be running at 5V. Another option is to use an Arduino Uno board with RESET pin connected to GND, and use its TX, RX pins which are connected to the Arduino Virtual COM port. Build and run the code on the target board, and open a COM terminal on PC to see the message from the target board. Use a digital logic analyzer to see raw bits transferred in RX and TX pins. UART output on digital logic analyzer UART output in a terminal 3.6. Receive data \u2693\ufe0e Next step is to read from UART in polling mode. Polling mode Block the program flow Have to wait for the exact number of characters Use the function HAL_UART_Receive(&huart1, (uint8_t *)buffer, 4, 2000) to read the input, which means: All received data is written into buffer Function will exit if one of the below condition meets: 4 chars are received, or 2000 ms timeout, use HAL_MAX_DELAY will block the while loop Let\u2019s modify the code to get helper functions and process input in main while loop: char counter = 0 ; char buffer [ 16 ] = { 0 }; // counter=xxx\\n\\r const char MSG_PAUSE [] = \"PAUSED \\n\\r \" ; const char MSG_RESUME [] = \"RESUMED \\n\\r \" ; const char MSG_OK [] = \"OK \\n\\r \" ; const char MSG_BUSY [] = \"BUSY \\n\\r \" ; const char MSG_ERROR [] = \"ERROR \\n\\r \" ; const char MSG_TIMEOUT [] = \"TIMEOUT \\n\\r \" ; HAL_StatusTypeDef Write ( const char * buffer ) { return HAL_UART_Transmit ( & huart1 , ( uint8_t * ) buffer , strlen ( buffer ), HAL_MAX_DELAY ); } HAL_StatusTypeDef Read ( char * buffer , int n ) { HAL_StatusTypeDef ret = HAL_TIMEOUT ; ret = HAL_UART_Receive ( & huart1 , ( uint8_t * ) buffer , n , 2000 ); if ( ret == HAL_OK ) { Write ( MSG_OK ); } else if ( ret == HAL_BUSY ) { Write ( MSG_BUSY ); } else if ( ret == HAL_ERROR ) { Write ( MSG_ERROR ); } else if ( ret == HAL_TIMEOUT ) { Write ( MSG_TIMEOUT ); } return ret ; } int main ( void ) { char pause = 0 ; while ( 1 ) { if ( pause == 0 ) { counter ++ ; sprintf ( buffer , \"counter=%03d \\n\\r \" , counter ); Write ( buffer ); } Read ( buffer , 4 ); if ( strncmp ( buffer , \"stop\" , 4 ) == 0 ) { pause = 1 ; Write ( MSG_PAUSE ); } else if ( strncmp ( buffer , \"resu\" , 4 ) == 0 ) { Read ( buffer , 2 ); if ( strncmp ( buffer , \"me\" , 2 ) == 0 ) { pause = 0 ; Write ( MSG_RESUME ); } } } } Receive user\u2019s input Bug: Uncontrollable input It\u2019s hard to input correct command because the timeout behavior may break the flow, and the number of remaining characters is not predictable. Timeout mechanism It is important to remark that the timeout mechanism offered used in the receiving function works only if the HAL_IncTick() routine is called every 1ms , as done by the code generated by STM32CubeMX (the function that increments the HAL tick counter is called inside the SysTick timer ISR). 4. Lab 2: Interrupt Mode \u2693\ufe0e 4.1. Interruptions \u2693\ufe0e Every USART peripheral provides the interrupts listed below: Interrupt Event Event Flag Enable Control Bit Transmit Data Register Empty TXE TXEIE Clear To Send (CTS) flag CTS CTSIE Transmission Complete TC TCIE Received Data Ready to be Read RXNE RXNEIE Overrun Error Detected ORE RXNEIE Idle Line Detected IDLE IDLEIE Parity Error PE PEIE Break Flag LBD LBDIE Noise Flag, Overrun error and Framing Error in multi buffer communication NF or ORE or FE EIE These events generate an interrupt if the corresponding to the Enable Control Bit is set. However, STM32 MCUs are designed so that all these IRQs are bound to just one ISR for every USART peripheral. It is up to the user code to analyze the corresponding Event Flag to infer which interrupt has generated the request. The STM32CubeHAL is designed to automatically do that job. Then user is warned about the interrupt thanks to a series of callback functions invoked by the HAL_UART_IRQHandler() . From a technical point of view, there is not so much difference between UART transmission in polling and in interrupt mode. Both the methods transfer an array of bytes using the UART Data Register (DR) with the following algorithm: For data transmission, place a byte inside the USART->DR register and wait until the Transmit Data Register Empty (TXE) flag is asserted true. For data reception, wait until the Received Data Ready to be Read (RXNE) is asserted true, and then store the content of the USART->DR register inside the application memory. The difference between the two methods consists in how they wait for the completion of data transmission: In polling mode, the HAL_UART_Receive() / HAL_UART_Transmit() functions are designed so that it waits for the corresponding event flag to be set, for every byte of data. In interrupt mode, the HAL_UART_Receive_IT() / HAL_UART_Transmit_IT() functions are designed so that they do not wait for data transmission completion, but the job to place a new byte inside the DR register, or to load its content inside the application memory, is accomplished by the ISR routine when the RXNEIE / TXEIE interrupt is generated. 4.2. Start a new project \u2693\ufe0e Open STM32CubeIDE and create a new STM32 with the same steps in the previous lab, including configuration for clocks, debug, and UART1. 4.3. Enable interrupt \u2693\ufe0e Go to USART1 module, select NVIC Settings tab and enable the interrupt. Enable interrupt for USART1 After generating code, the functions to enable interrupt are written in function HAL_UART_MspInit() in stm32f0xx_hal_msp.c file: HAL_NVIC_SetPriority ( USART1_IRQn , 0 , 0 ); HAL_NVIC_EnableIRQ ( USART1_IRQn ); The interrupt handler is added to stm32f0xx_it.c file too. Trace the function HAL_UART_IRQHandler() to understand about how it processes the data. Basically, it checks the error, check the state, and mode of the USART instance; then it save or transfer data on RX or TX wire. void USART1_IRQHandler ( void ) { HAL_UART_IRQHandler ( & huart1 ); } 4.4. Send data with interrupt \u2693\ufe0e As said above, use HAL_UART_Transmit_IT() function to send data. main.c char counter = 0 ; char buffer [ 16 ] = { 0 }; // counter=xxx\\n\\r HAL_StatusTypeDef Write ( const char * buffer ) { return HAL_UART_Transmit_IT ( & huart1 , ( uint8_t * ) buffer , strlen ( buffer )); } int main () { char pause = 0 ; while ( 1 ) { if ( pause == 0 ) { sprintf ( buffer , \"counter=%03d \\n\\r \" , counter ++ ); Write ( buffer ); } HAL_Delay ( 1000 ); } } Race condition in Interrupt Mode Consider below code: void printWelcomeMessage ( void ) { HAL_UART_Transmit_IT ( & huart1 , buffer1 , strlen ( buffer1 )); HAL_UART_Transmit_IT ( & huart1 , buffer2 , strlen ( buffer2 )); HAL_UART_Transmit_IT ( & huart1 , buffer3 , strlen ( buffer3 )); } The above code will never work correctly, since each call to the function HAL_UART_Transmit_IT() is much faster than the UART transmission, and the subsequent calls to the HAL_UART_Transmit_IT() will fail as it will see that UART is in the Busy state. If speed is not a strict requirement for the application, and the use of the HAL_UART_Transmit_IT() is limited to few parts of the application, the above code could be rearranged in the following way: void printWelcomeMessage ( void ) { char * strings [] = { buffer1 , buffer2 , buffer3 }; for ( uint8_t i = 0 ; i < 3 ; i ++ ) { HAL_UART_Transmit_IT ( & huart1 , strings [ i ], strlen ( strings [ i ])); while ( HAL_UART_GetState ( & huart1 ) == HAL_UART_STATE_BUSY_TX || HAL_UART_GetState ( & huart1 ) == HAL_UART_STATE_BUSY_TX_RX ); } } When all data in the buffer are sent, HAL library will call to a callback function named HAL_UART_TxCpltCallback() to notify about the end of the transmission. There is no callback when half of data is transferred . This function can be overridden to do something after the buffer is transmitted. main.c char uart_tx_done = 0 ; void HAL_UART_TxCpltCallback ( UART_HandleTypeDef * huart ) { if ( huart == & huart1 ) { uart_tx_done = 1 ; } } 4.5. Receive data with interrupt \u2693\ufe0e Next step is to read data using interrupt with the function HAL_UART_Receive_IT() . Because its unknown time when a character comes, so the buffer for receiving will be filled in at anytime, even when buffer is being used in the sprinf() function, therefore, should use a new buffer to store received data, e.g. command . When the receiver gets enough characters, it will fire an interrupt to run the HAL_UART_RxCpltCallback() function. That function can be overridden to handle received data in the main: char uart_rx_int = 0 ; void HAL_UART_RxCpltCallback ( UART_HandleTypeDef * huart ) { if ( huart == & huart1 ) { uart_rx_int = 1 ; } } In the main function, process received data only when the flag is on: char uart_rx_int = 0 ; char command [ 16 ] = { 0 }; const char MSG_PAUSE [] = \"PAUSED \\n\\r \" ; const char MSG_RESUME [] = \"RESUMED \\n\\r \" ; HAL_StatusTypeDef Read ( char * buffer , int n ) { return HAL_UART_Receive_IT ( & huart1 , ( uint8_t * ) buffer , n ); } void HAL_UART_RxCpltCallback ( UART_HandleTypeDef * huart ) { if ( huart == & huart1 ) { uart_rx_int = 1 ; } } int main () { char pause = 0 ; while ( 1 ) { if ( pause == 0 ) { counter ++ ; sprintf ( buffer , \"counter=%03d \\n\\r \" , counter ); Write ( buffer ); } if ( uart_rx_int == 1 ) { uart_rx_int = 0 ; if ( strncmp ( command , \"stop\" , 4 ) == 0 ) { pause = 1 ; Write ( MSG_PAUSE ); } else if ( strncmp ( command , \"resume\" , 6 ) == 0 ) { pause = 0 ; Write ( MSG_RESUME ); } } Read ( command , 6 ); HAL_Delay ( 1000 ); } } Communicate with UART in interrupt mode Bug: Input length is fixed The above implementation has an issue: The receiving interrupt only is fired when it receives enough number of characters. In the above example, enter stopxx for stop command will work, but stop will never do. To fix this, set the receive mode to get only one byte at a time, then check for the new line / line feed \\n or carriage return \\r character to to determine input sentences. However, this will lead to run the interrupt handler many times if the incoming data rate is high. Here is an example to handle every byte in the Interrupt mode: Received one byte at a time Check the received by with the new line \\n character to separate strings Call Receive function again to listen to a new character char rx_buffer [ 16 ] = { 0 }; int rx_idx = 0 ; char rx = 0 ; void HAL_UART_RxCpltCallback ( UART_HandleTypeDef * huart ) { if ( rx == '\\n' ) { rx_buffer [ rx_idx ] = '\\0' ; strncpy ( command , rx_buffer , 16 ); rx_idx = 0 ; uart_rx_int = 1 ; } else { rx_buffer [ rx_idx ++ ] = rx ; } Read ( & rx , 1 ); } int main ( void ) { Read ( & rx , 1 ); while ( 1 ) { if ( uart_rx_int == 1 ) { uart_rx_int = 0 ; if ( strncmp ( command , \"stop\" , 4 ) == 0 ) {...} } } } This approach can be optimized more by not using the HAL function (both HAL_UART_Receive_IT() and HAL_UART_IRQHandler() ), but by setting up UART_IT_RXNE (Received Data Not Empty) interrupt and then handle this interrupt manually in the USART1_IRQHandler() ISR. __HAL_UART_ENABLE_IT ( & huart1 , UART_IT_RXNE ); void USART1_IRQHandler ( void ) { handle_received_byte (); } 5. Lab 3: DMA mode \u2693\ufe0e The DMA can be used to transfer data in or out through an UART interface. However, DMA still needs to know how many bytes of data should be exchanged. In case of transmitting, it is easy to calculate the length of data, but in case of receiving, it may be unknown length of data. 5.1. Start a new project \u2693\ufe0e Open STM32CubeIDE and create a new STM32 with the same steps in the previous lab, including configuration for clocks, debug, and UART1. 5.2. Enable DMA \u2693\ufe0e Go to USART1 module, select DMA Settings tab and Add two DMA requests: USART1_TX : This DMA Request has direction of Memory to Peripheral, it means DMA processor will read data from Memory and write to the USART1 Transmit Data Register, therefore, only Memory Address will be increased USART1_RX : This DMA Request has direction of Peripheral to Memory, it means DMA processor will read data from USART1 Receive Data Register and write to Memory, therefore, only Memory Address will be increased DMA only works when the peripheral\u2019s interrupt is enabled, as it needs triggered from the peripheral. Make sure to enable USART1 global / wake-up interrupts through the external interrupt line. Note that STM32CubeMX automatically enable DMA interrupts. To disable it, go to NVIC module under the System Core category. After generating code, there is a new function MX_DMA_Init() added to the main.c file to initialize the DMA module: static void MX_DMA_Init ( void ) { /* DMA controller clock enable */ __HAL_RCC_DMA1_CLK_ENABLE (); /* DMA interrupt init */ /* DMA1_Channel2_3_IRQn interrupt configuration */ HAL_NVIC_SetPriority ( DMA1_Channel2_3_IRQn , 0 , 0 ); HAL_NVIC_EnableIRQ ( DMA1_Channel2_3_IRQn ); } Enable DMA requests on USART1 Inside the HAL_UART_MspInit() function, there are calls to initialize DMA instances for USART1_TX and USART1_RX, and finally links of DMA instances with the USART instance with the function __HAL_LINKDMA . void HAL_UART_MspInit ( UART_HandleTypeDef * huart ) { ... /* DMA USART1_RX Init */ hdma_usart1_rx . Instance = DMA1_Channel3 ; hdma_usart1_rx . Init . Direction = DMA_PERIPH_TO_MEMORY ; hdma_usart1_rx . Init . PeriphInc = DMA_PINC_DISABLE ; hdma_usart1_rx . Init . MemInc = DMA_MINC_ENABLE ; hdma_usart1_rx . Init . PeriphDataAlignment = DMA_PDATAALIGN_BYTE ; hdma_usart1_rx . Init . MemDataAlignment = DMA_MDATAALIGN_BYTE ; hdma_usart1_rx . Init . Mode = DMA_NORMAL ; hdma_usart1_rx . Init . Priority = DMA_PRIORITY_LOW ; if ( HAL_DMA_Init ( & hdma_usart1_rx ) != HAL_OK ) { Error_Handler (); } __HAL_LINKDMA ( huart , hdmarx , hdma_usart1_rx ); /* DMA USART1_TX Init */ hdma_usart1_tx . Instance = DMA1_Channel2 ; hdma_usart1_tx . Init . Direction = DMA_MEMORY_TO_PERIPH ; hdma_usart1_tx . Init . PeriphInc = DMA_PINC_DISABLE ; hdma_usart1_tx . Init . MemInc = DMA_MINC_ENABLE ; hdma_usart1_tx . Init . PeriphDataAlignment = DMA_PDATAALIGN_BYTE ; hdma_usart1_tx . Init . MemDataAlignment = DMA_MDATAALIGN_BYTE ; hdma_usart1_tx . Init . Mode = DMA_NORMAL ; hdma_usart1_tx . Init . Priority = DMA_PRIORITY_LOW ; if ( HAL_DMA_Init ( & hdma_usart1_tx ) != HAL_OK ) { Error_Handler (); } __HAL_LINKDMA ( huart , hdmatx , hdma_usart1_tx ); /* USART1 interrupt Init */ HAL_NVIC_SetPriority ( USART1_IRQn , 0 , 0 ); HAL_NVIC_EnableIRQ ( USART1_IRQn ); } There is also an implementation for DMA interrupt in the file stm32f0xx_it.c which calls to the HAL_DMA_IRQHandler() function. There is no default callback for DMA. User has to set the callbacks manually , as described in the DMA Interrupts section. However, HAL functions will assign a callback when they need to handle an interrupt. 5.3. Send data with DMA \u2693\ufe0e Sending data with DMA is quite easy, just provide the tx_buffer and the length of data to the function HAL_UART_Transmit_DMA() . #define DMA_BUFFER_MAX 16 char tx_buffer [ DMA_BUFFER_MAX ] = { 0 }; HAL_StatusTypeDef Write ( const char * buffer ) { return HAL_UART_Transmit_DMA ( & huart1 , ( uint8_t * ) buffer , strlen ( buffer )); } int main () { char pause = 0 ; while ( 1 ) { if ( pause == 0 ) { sprintf ( tx_buffer , \"counter=%03d \\n\\r \" , counter ++ ); Write ( tx_buffer ); } HAL_Delay ( 1000 ); } } There are two interrupts will be fired for transmission, which are helpful when sending a huge amount of data: DMA notifies application to start loading new data into the first half of the buffer after the TxHalfCpltCallback is fired, while the second half of the buffer is being transmitted by the DMA; then application can load the new data into the second half of the buffer after the TxCpltCallback is fired, while the first half is being transmitted. Using DMA mode can significantly resude the number of UART interrupts, comparing to using Interrupt mode. If there is a variable to keep track of the numbers of UART interrupts, for example in the below code, this number will be increased for every bytes in the transmitting buffer in Interrupt mode (each byte sent causes an interrupt to load the next byte). However, in DMA mode, there is only one interrupt added only when the buffer is completely transfered. size_t uart_irq_counter = 0 ; void USART1_IRQHandler ( void ) { uart_irq_counter ++ ; } 5.4. Receive data with DMA \u2693\ufe0e Normally, when calling to HAL_UART_Receive_DMA() , the DMA module will stop transferring data when it counts enough bytes set in the parameters. There is the Circular mode that makes DMA continues get data and fills into memory like a ring buffer. Go back to the DMA Settings tab of the USART1 module to set the mode of USART1_RX request to Circular. Enable Circular mode for DMA on USART1_RX Then create a buffer for receiving data, and start DMA Request in the main function: #define DMA_BUFFER_MAX 16 char rx_buffer [ DMA_BUFFER_MAX ] = { 0 }; int main ( void ) { HAL_UART_Receive_DMA ( & huart1 , ( uint8_t * ) rx_buffer , DMA_BUFFER_MAX ); while ( 1 ) {...} } By calling the HAL_UART_Receive_DMA() function, USART1_RX DMA instance will get some callback functions assigned to its Half-transfer and Full-Transfer callbacks. Refer to the function UART_Start_Receive_DMA() for more details. It is possible to configure DMA to transfer one byte at a time and call to an interrupt function to handle the newly received character like in Interrupt mode, but it wastes of resource and performance. However, if application lets DMA to notify only then it receives enough the required number of characters, sometimes there is no notification sent. Assume that application expects to receive 20 chars, but UART only receives 14 chars: Application would be notified when 10 bytes received by Half-Transfer event Application would never be notified the rest of 4 bytes has arrived If UART get more chars, application would be nofified by Full-Transfer event but some chars may be left over 5.5. UART IDLE Detection \u2693\ufe0e Most of STM32 series have USARTs with IDLE Line detection. If IDLE Line detection is not available, some of them have Receiver Timeout feature with programmable delay. IDLE line detection (or Receiver Timeout) can trigger USART interrupt when receive line is steady without any communication for at least 1 character for reception. IDLE Detection Right after enable the UART, the IDLE bit in Interrupt Status Register ISR will be set. However, the interrupt for IDLE detection only gets fired when the bit IDLEIE is set on the Control Register CRx . Therefore, the IDLE interrupt always fire up once rigth after the bit IDLEIE is set. To clear the IDLE interrupt status, either set the IDLECF in the Clear Register or do a read sequence on SR and DR registers. Refer to the Reference Manual documents to get more detail. When IDLE dection is enable, make sure the RX line is not floating to prevent the IDLE flag from being set continuously. DMA RX and IDLE Line detection The good combination for using DMA to get unknown length of data is to use DMA in Circular mode, with big enough memory buffer, then use DMA Half-Transfer, Full-Transfer and the IDLE line detection to notify application to process received data. HAL DMA Receiving function automatically notifies the application by calling HAL_UART_RxHalfCpltCallback() and HAL_UART_RxCpltCallback() . Therefore, it is only needed to override the USART1_IRQHandler() function. To more simple and still left HAL Handler processes other cases, it is better to add a small code just to check the IDLE flag and process received data before handing over the interrupt to original HAL_UART_IRQHandler() function. stm32f0xx_it.c void USART1_IRQHandler ( void ) { if ((( & huart1 ) -> Instance -> ISR & UART_FLAG_IDLE ) != 0 && (( & huart1 ) -> Instance -> CR1 & USART_CR1_IDLEIE ) != 0 ) { __HAL_UART_CLEAR_IDLEFLAG ( & huart1 ); HAL_UART_RxCpltCallback ( & huart1 ); } // pass the work to HAL function HAL_UART_IRQHandler ( & huart1 ); } main.c void HAL_UART_RxCpltCallback ( UART_HandleTypeDef * huart ) { UART_RX_Check ( & hdma_usart1_rx ); } void HAL_UART_RxHalfCpltCallback ( UART_HandleTypeDef * huart ) { UART_RX_Check ( & hdma_usart1_rx ); } 5.6. Process continuous received data \u2693\ufe0e Due to DMA buffer is a Ring buffer with small number of bytes, it is necessary to copy received bytes from DMA buffer to a bigger UART buffer. There are 2 indexes to mark the bytes position in DMA buffer: new_pos at the last received byte, and old_pos at last processed byte. There is one index uart_index to mark the last byte in the UART buffer. Visualization of memory copy between DMA buffer and UART buffer In DMA buffer, if the new_pos is bigger than the old_pos , it means there is no roll-over, application can copy bytes [ old_pos : new_pos ] to the UART buffer. In DMA buffer, if the new_pos is less than the old_pos , it means there is a roll-over, application can copy bytes [ old_pos : max ] and [0: new_pos ] to the UART buffer. In UART buffer, when buffer is full, it does not get any more character, only character new line \\n will reset the index to 0 To get the new_pos index, aka. Number of received bytes, use the register CNDTR of the DMA instance. Read more about \u201cDMA channel x number of data register ( DMA_CNDTRx and DMA2_CNDTRx )\u201d section in the Reference Manual document. Here is the implementation example for the above solution of processing the received data: #define UART_BUFFER_MAX 64 char uart_buffer [ UART_BUFFER_MAX ] = { 0 }; size_t uart_buffer_idx = 0 ; char uart_new_string = 0 ; void UART_RX_Process ( const void * data , size_t len ) { for ( int i = 0 ; i < len ; i ++ ) { char c = (( char * ) data )[ i ]; if ( uart_buffer_idx < UART_BUFFER_MAX -2 ) { uart_buffer [ uart_buffer_idx ++ ] = c ; uart_buffer [ uart_buffer_idx ] = '\\0' ; } if ( c == '\\n' ) { uart_buffer_idx = 0 ; uart_new_string = 1 ; } } } void UART_RX_Check ( DMA_HandleTypeDef * hdma ) { static size_t old_pos = 0 ; size_t rx_pos = DMA_BUFFER_MAX - hdma -> Instance -> CNDTR ; if ( rx_pos != old_pos ) { // new data if ( rx_pos > old_pos ) { // no overflow UART_RX_Process ( & rx_buffer [ old_pos ], rx_pos - old_pos ); } else { // overflow UART_RX_Process ( & rx_buffer [ old_pos ], DMA_BUFFER_MAX - old_pos ); if ( rx_pos > 0 ) { // run up UART_RX_Process ( & rx_buffer [ old_pos ], rx_pos ); } } old_pos = rx_pos ; } } int main ( void ) { while ( 1 ) { if ( uart_new_string == 1 ) { uart_new_string = 0 ; if ( strncmp ( uart_buffer , \"stop\" , 4 ) == 0 ) {...} } } } This tutorial only show a method to process variable string length in a continuous byte stream. The function UART_RX_Process() should be modified to handle different streaming format. Compile and run with variable string length to find how it works. Below captured image was in a debug section to see how many IDLE interrupts are called, how received bytes are saved into the rx_buffer and to monitor the uart_buffer . Communicate with UART in DMA mode","title":"UART"},{"location":"blog/stm32/uart/#1-hardware","text":"Universal Synchronous/Asynchronous Receiver/Transmitter interface, also simply known as USART, is a device that translates a parallel sequence of bits (usually grouped in a byte) in a continuous stream of signals flowing on a single wire.","title":"1. Hardware"},{"location":"blog/stm32/uart/#11-wires","text":"When the information flows between two devices inside a common channel, both devices (as the sender and also the receiver) have to agree on the timing , that defines how long it takes to transmit each individual bit of the information. In a synchronous transmission, the sender and the receiver share a common clock generated by one of the two devices Shared clock in synchronous USART In an asynchronous transmission, the clock line is omitted, and both devices have an internal clock source and a mechanism to detect start/ stop bit. One line of data in asynchronous USART In a bi-direction communication, it needs a pair of lines for Transmitter (TX) and Receiver (RX): USART vs UART","title":"1.1. Wires"},{"location":"blog/stm32/uart/#12-flow-control","text":"The presence of a dedicated clock line, or a common agreement about transmission frequency, does not guarantee that the receiver of a byte stream is able to process them at the same transmission rate of the master. For this reason, some communication standards, like the RS232 and the RS485, provide the possibility to use a dedicated Hardware Flow Control line. For example, two devices communicating using the RS232 interface can share two additional lines, named Request To Send (RTS) and Clear To Send (CTS) : the sender sets its RTS, which signals the receiver to begin monitoring its data input line. When ready for data, the receiver will raise its complementary line, CTS, which signals the sender to start sending data, and for the sender to begin monitoring the slave\u2019s data output line.","title":"1.2. Flow control"},{"location":"blog/stm32/uart/#13-data-frame","text":"The frames are comprised of: An Idle Line prior to transmission or reception A start bit A data word (7, 8 or 9 bits) with the least significant bit first A 0.5, 1, 1.5, or 2 stop bits indicating that the frame is complete By default, the signal (TX or RX) is in low state during the start bit. It is in high state during the stop bit. These values can be inverted, separately for each signal, through polarity configuration control. An Idle character is interpreted as an entire frame of \u201c1\u201ds (the number of \u201c1\u201ds includes the number of stop bits). A Break character is interpreted on receiving \u201c0\u201ds for a frame period. At the end of the break frame, the transmitter inserts 2 stop bits. Frames in USART","title":"1.3. Data frame"},{"location":"blog/stm32/uart/#14-clock","text":"The choice of the clock source is done through the Clock Control system (see Section Reset and clock control (RCC) ). The clock source must be chosen before enabling the USART (by setting the UE bit). Choosing LSE or HSI as clock source may allow the USART to receive data while the MCU is in low-power mode. Clock source is used to do oversampling by 16 or by 8 to detect the start bit. It samples the RX line and try to detect a falling edge and following patterns of zeros. Detect start bit using oversampling","title":"1.4. Clock"},{"location":"blog/stm32/uart/#15-baud-rate","text":"Baud rate determines the speed of transmitting and receiving, as the speed depends on the clock source and USARTDIV value. USARTDIV is an unsigned fixed point number that is coded on the USART_BRR register. When OVER8 = 0, BRR = USARTDIV . When OVER8 = 1: BRR[2:0] = USARTDIV[3:0] shifted 1 bit to the right. BRR[3] must be kept cleared. BRR[15:4] = USARTDIV[15:4]. Example: To obtain 9600 baud with core clock frequency at 8 MHz. In case of oversampling by 16: BRR = USARTDIV = 8 000 000/9600 = 833d = 0341h In case of oversampling by 8: USARTDIV = 2 * 8 000 000/9600 = 1666,66 (~1667d) = 683h BRR[3:0] = 3h >> 1 = 1h BRR = 0x681 Auto baud rate detection The USART is able to detect and automatically set the USART_BRR register value based on the reception of one character. Automatic baud rate detection is useful under two circumstances: The communication speed of the system is not known in advance The system is using a relatively low accuracy clock source and this mechanism allows the correct baud rate to be obtained without measuring the clock deviation. Before activating the auto baud rate detection, the auto baud rate detection mode must be chosen. There are various modes based on different character patterns. Prior to activating auto baud rate detection, the USART_BRR register must be initialized by writing a non-zero baud rate value.","title":"1.5. Baud rate"},{"location":"blog/stm32/uart/#16-multiprocessor","text":"In multiprocessor communication, the following bits are to be kept cleared: LINEN bit in the USART_CR2 register, HDSEL , IREN and SCEN bits in the USART_CR3 register. It is possible to perform multiprocessor communication with the USART (with several USARTs connected in a network). For instance one of the USARTs can be the master, its TX output connected to the RX inputs of the other USARTs. The others are slaves, their respective TX outputs are logically AND ed together and connected to the RX input of the master.","title":"1.6. Multiprocessor"},{"location":"blog/stm32/uart/#2-stm32cubehal-usage","text":"The Hardware Abstract Layer (HAL) is designed so that it abstracts from the specific peripheral memory mapping. But, it also provides a general and more user-friendly way to configure the peripheral, without forcing the programmers to now how to configure its registers in detail. Excerpt from Description of STM32F0 HAL and low-layer drivers How to use USART HAL Declare a UART_HandleTypeDef handle structure (e.g. UART_HandleTypeDef huart ). Initialize the UART low level resources by implementing the HAL_UART_MspInit() API when needed: Enable the USARTx interface clock. UART pins configuration: Enable the clock for the UART GPIOs. Configure these UART pins as alternate function pull-up. NVIC configuration if you use interrupt process ( HAL_UART_Transmit_IT() and HAL_UART_Receive_IT() APIs): Configure the USARTx interrupt priority. Enable the NVIC USART IRQ handle. UART interrupts handling: DMA Configuration if you use DMA process ( HAL_UART_Transmit_DMA() and HAL_UART_Receive_DMA() APIs): Declare a DMA handle structure for the Tx/Rx channel. Enable the DMAx interface clock. Configure the declared DMA handle structure with the required Tx/Rx parameters. Configure the DMA Tx/Rx channel. Associate the initialized DMA handle to the UART DMA Tx/Rx handle. Configure the priority and enable the NVIC for the transfer complete interrupt on the DMA Tx/Rx channel. Program the Baud Rate, Word Length, Stop Bit, Parity, Hardware flow control and Mode (Receiver/Transmitter) in the huart handle initial structure. If required, program UART advanced features (TX/RX pins swap, auto Baud rate detection, etc.) in the huart handle AdvancedInit structure. For the UART asynchronous mode, initialize the UART registers by calling the HAL_UART_Init() API. For the UART Half duplex mode, initialize the UART registers by calling the HAL_HalfDuplex_Init() API. For the UART Multiprocessor mode, initialize the UART registers by calling the HAL_MultiProcessor_Init() API. For the UART RS485 Driver Enabled mode, initialize the UART registers by calling the HAL_RS485Ex_Init() API.","title":"2. STM32CubeHAL Usage"},{"location":"blog/stm32/uart/#3-lab-1-polling-mode","text":"This project aims to learn how to configure USART via STM32CubeIDE and STM32CubeMX in polling mode. In polling mode, also called blocking mode, the main application, or one of its threads, synchronously waits for the data transmission and reception. This is the simplest form of data communication using this peripheral, and it can be used when the transmit rate is not too much low and when the UART is not used as critical peripheral. Requirements : Increase a counter by 1 and print its value to UART1 every second Get user commands: stop to pause increasing the counter resume to resume increasing the counter Target board : Any board which has STM32 MCUs. This tutorial will be using the STM32F0 Discovery board, which features an STM32F051R8 Cortex-M0 MCU. STM32F051R8 Mode External peripheral PA9 Alternate Function UART1 TX PA10 Alternate Function UART1 RX PC9 GPIO Output Green LED","title":"3. Lab 1: Polling mode"},{"location":"blog/stm32/uart/#31-start-a-new-project","text":"Open STM32CubeIDE and create a new STM32 with STM32F051R8 MCU by selecting the target board or just the target MCU. Make sure to configure below settings: Set the HLCK to 48 MHz Set the Debug mode to Debug Serial Wire or Trace Asynchronous SW","title":"3.1. Start a new project"},{"location":"blog/stm32/uart/#32-enable-usart1","text":"Open Connectivity section in Pinout & Configs tab and select USART1 module, then edit some settings: Mode: Asynchronous Parameter: Baud rate: 115200 bps Word length: 8 bits (including Parity) Parity: None Stop bits: 1 Enable USART1 Note that PA9 and PA10 are automatically configured to Alternative Function to use as USART1 pinout.","title":"3.2. Enable USART1"},{"location":"blog/stm32/uart/#33-generated-code","text":"When generate code from configs, there are some noticeable code blocks: Peripheral instance IDE will add an instance handler for the USART1 module in main.c . This instance will be used for manage USART1 peripheral then it should be global access: UART_HandleTypeDef huart1 ; Initializing functions The function SystemClock_Config() is included to set up the system clock, bus clocks. In addition, it will set the clock source for the USART1: void SystemClock_Config ( void ) { RCC_OscInitTypeDef RCC_OscInitStruct = { 0 }; RCC_ClkInitTypeDef RCC_ClkInitStruct = { 0 }; RCC_PeriphCLKInitTypeDef PeriphClkInit = { 0 }; /** Initializes the RCC Oscillators according to the specified parameters in the RCC_OscInitTypeDef structure. */ RCC_OscInitStruct . OscillatorType = RCC_OSCILLATORTYPE_HSI ; RCC_OscInitStruct . HSIState = RCC_HSI_ON ; RCC_OscInitStruct . HSICalibrationValue = RCC_HSICALIBRATION_DEFAULT ; RCC_OscInitStruct . PLL . PLLState = RCC_PLL_ON ; RCC_OscInitStruct . PLL . PLLSource = RCC_PLLSOURCE_HSI ; RCC_OscInitStruct . PLL . PLLMUL = RCC_PLL_MUL12 ; RCC_OscInitStruct . PLL . PREDIV = RCC_PREDIV_DIV1 ; if ( HAL_RCC_OscConfig ( & RCC_OscInitStruct ) != HAL_OK ) { Error_Handler (); } /** Initializes the CPU, AHB and APB buses clocks */ RCC_ClkInitStruct . ClockType = RCC_CLOCKTYPE_HCLK | RCC_CLOCKTYPE_SYSCLK | RCC_CLOCKTYPE_PCLK1 ; RCC_ClkInitStruct . SYSCLKSource = RCC_SYSCLKSOURCE_PLLCLK ; RCC_ClkInitStruct . AHBCLKDivider = RCC_SYSCLK_DIV1 ; RCC_ClkInitStruct . APB1CLKDivider = RCC_HCLK_DIV1 ; if ( HAL_RCC_ClockConfig ( & RCC_ClkInitStruct , FLASH_LATENCY_1 ) != HAL_OK ) { Error_Handler (); } PeriphClkInit . PeriphClockSelection = RCC_PERIPHCLK_USART1 ; PeriphClkInit . Usart1ClockSelection = RCC_USART1CLKSOURCE_PCLK1 ; if ( HAL_RCCEx_PeriphCLKConfig ( & PeriphClkInit ) != HAL_OK ) { Error_Handler (); } } The function MX_USART1_UART_Init() initializes the USART1 instance with the values put into the initial struct. This function, at the end, calls to HAL_UART_Init() which is an HAL function to check the initial parameters and finally calls to HAL_UART_MspInit() to do low-level configs. static void MX_USART1_UART_Init ( void ) { huart1 . Instance = USART1 ; huart1 . Init . BaudRate = 115200 ; huart1 . Init . WordLength = UART_WORDLENGTH_8B ; huart1 . Init . StopBits = UART_STOPBITS_1 ; huart1 . Init . Parity = UART_PARITY_NONE ; huart1 . Init . Mode = UART_MODE_TX_RX ; huart1 . Init . HwFlowCtl = UART_HWCONTROL_NONE ; huart1 . Init . OverSampling = UART_OVERSAMPLING_16 ; huart1 . Init . OneBitSampling = UART_ONE_BIT_SAMPLE_DISABLE ; huart1 . AdvancedInit . AdvFeatureInit = UART_ADVFEATURE_NO_INIT ; if ( HAL_UART_Init ( & huart1 ) != HAL_OK ) { Error_Handler (); } } The function HAL_UART_MspInit() is generated in stm32f0xx_hal_msp.c to override the function declared in HAL Lib. This low-level config will set up the peripheral clocks, and set alternative functions on GPIO pins. void HAL_UART_MspInit ( UART_HandleTypeDef * huart ) { GPIO_InitTypeDef GPIO_InitStruct = { 0 }; if ( huart -> Instance == USART1 ) { /* Peripheral clock enable */ __HAL_RCC_USART1_CLK_ENABLE (); __HAL_RCC_GPIOA_CLK_ENABLE (); /**USART1 GPIO Configuration PA9 ------> USART1_TX PA10 ------> USART1_RX */ GPIO_InitStruct . Pin = GPIO_PIN_9 | GPIO_PIN_10 ; GPIO_InitStruct . Mode = GPIO_MODE_AF_PP ; GPIO_InitStruct . Pull = GPIO_NOPULL ; GPIO_InitStruct . Speed = GPIO_SPEED_FREQ_HIGH ; GPIO_InitStruct . Alternate = GPIO_AF1_USART1 ; HAL_GPIO_Init ( GPIOA , & GPIO_InitStruct ); } }","title":"3.3. Generated code"},{"location":"blog/stm32/uart/#34-send-data","text":"With generated code, just need to use HAL_UART_Transmit() function to send a buffer over the USART instance. Let\u2019s create a buffer, a counter variable, and make a message to send every second. #include <stdio.h> // sprintf #include <string.h> // strlen char counter = 0 ; char buffer [ 16 ] = { 0 }; // counter=xxx\\n\\r int main ( void ) { while ( 1 ) { counter ++ ; sprintf ( buffer , \"counter=%03d \\n\\r \" , counter ); HAL_UART_Transmit ( & huart1 , ( uint8_t * ) buffer , strlen ( buffer ), HAL_MAX_DELAY ); HAL_Delay ( 1000 ); } }","title":"3.4. Send data"},{"location":"blog/stm32/uart/#35-connect-uart-to-pc","text":"Because STM32F0 Discovery does not have a Virtual COM port on ST-LINK/V2, so use a TTL-to-USB converter go get UART data. Connect pins PA9 and PA10 to UART terminal on PC. It\u2019s recommend to check the voltage because MCU board is running at 3.3V while PC USB or COM port might be running at 5V. Another option is to use an Arduino Uno board with RESET pin connected to GND, and use its TX, RX pins which are connected to the Arduino Virtual COM port. Build and run the code on the target board, and open a COM terminal on PC to see the message from the target board. Use a digital logic analyzer to see raw bits transferred in RX and TX pins. UART output on digital logic analyzer UART output in a terminal","title":"3.5. Connect UART to PC"},{"location":"blog/stm32/uart/#36-receive-data","text":"Next step is to read from UART in polling mode. Polling mode Block the program flow Have to wait for the exact number of characters Use the function HAL_UART_Receive(&huart1, (uint8_t *)buffer, 4, 2000) to read the input, which means: All received data is written into buffer Function will exit if one of the below condition meets: 4 chars are received, or 2000 ms timeout, use HAL_MAX_DELAY will block the while loop Let\u2019s modify the code to get helper functions and process input in main while loop: char counter = 0 ; char buffer [ 16 ] = { 0 }; // counter=xxx\\n\\r const char MSG_PAUSE [] = \"PAUSED \\n\\r \" ; const char MSG_RESUME [] = \"RESUMED \\n\\r \" ; const char MSG_OK [] = \"OK \\n\\r \" ; const char MSG_BUSY [] = \"BUSY \\n\\r \" ; const char MSG_ERROR [] = \"ERROR \\n\\r \" ; const char MSG_TIMEOUT [] = \"TIMEOUT \\n\\r \" ; HAL_StatusTypeDef Write ( const char * buffer ) { return HAL_UART_Transmit ( & huart1 , ( uint8_t * ) buffer , strlen ( buffer ), HAL_MAX_DELAY ); } HAL_StatusTypeDef Read ( char * buffer , int n ) { HAL_StatusTypeDef ret = HAL_TIMEOUT ; ret = HAL_UART_Receive ( & huart1 , ( uint8_t * ) buffer , n , 2000 ); if ( ret == HAL_OK ) { Write ( MSG_OK ); } else if ( ret == HAL_BUSY ) { Write ( MSG_BUSY ); } else if ( ret == HAL_ERROR ) { Write ( MSG_ERROR ); } else if ( ret == HAL_TIMEOUT ) { Write ( MSG_TIMEOUT ); } return ret ; } int main ( void ) { char pause = 0 ; while ( 1 ) { if ( pause == 0 ) { counter ++ ; sprintf ( buffer , \"counter=%03d \\n\\r \" , counter ); Write ( buffer ); } Read ( buffer , 4 ); if ( strncmp ( buffer , \"stop\" , 4 ) == 0 ) { pause = 1 ; Write ( MSG_PAUSE ); } else if ( strncmp ( buffer , \"resu\" , 4 ) == 0 ) { Read ( buffer , 2 ); if ( strncmp ( buffer , \"me\" , 2 ) == 0 ) { pause = 0 ; Write ( MSG_RESUME ); } } } } Receive user\u2019s input Bug: Uncontrollable input It\u2019s hard to input correct command because the timeout behavior may break the flow, and the number of remaining characters is not predictable. Timeout mechanism It is important to remark that the timeout mechanism offered used in the receiving function works only if the HAL_IncTick() routine is called every 1ms , as done by the code generated by STM32CubeMX (the function that increments the HAL tick counter is called inside the SysTick timer ISR).","title":"3.6. Receive data"},{"location":"blog/stm32/uart/#4-lab-2-interrupt-mode","text":"","title":"4. Lab 2: Interrupt Mode"},{"location":"blog/stm32/uart/#41-interruptions","text":"Every USART peripheral provides the interrupts listed below: Interrupt Event Event Flag Enable Control Bit Transmit Data Register Empty TXE TXEIE Clear To Send (CTS) flag CTS CTSIE Transmission Complete TC TCIE Received Data Ready to be Read RXNE RXNEIE Overrun Error Detected ORE RXNEIE Idle Line Detected IDLE IDLEIE Parity Error PE PEIE Break Flag LBD LBDIE Noise Flag, Overrun error and Framing Error in multi buffer communication NF or ORE or FE EIE These events generate an interrupt if the corresponding to the Enable Control Bit is set. However, STM32 MCUs are designed so that all these IRQs are bound to just one ISR for every USART peripheral. It is up to the user code to analyze the corresponding Event Flag to infer which interrupt has generated the request. The STM32CubeHAL is designed to automatically do that job. Then user is warned about the interrupt thanks to a series of callback functions invoked by the HAL_UART_IRQHandler() . From a technical point of view, there is not so much difference between UART transmission in polling and in interrupt mode. Both the methods transfer an array of bytes using the UART Data Register (DR) with the following algorithm: For data transmission, place a byte inside the USART->DR register and wait until the Transmit Data Register Empty (TXE) flag is asserted true. For data reception, wait until the Received Data Ready to be Read (RXNE) is asserted true, and then store the content of the USART->DR register inside the application memory. The difference between the two methods consists in how they wait for the completion of data transmission: In polling mode, the HAL_UART_Receive() / HAL_UART_Transmit() functions are designed so that it waits for the corresponding event flag to be set, for every byte of data. In interrupt mode, the HAL_UART_Receive_IT() / HAL_UART_Transmit_IT() functions are designed so that they do not wait for data transmission completion, but the job to place a new byte inside the DR register, or to load its content inside the application memory, is accomplished by the ISR routine when the RXNEIE / TXEIE interrupt is generated.","title":"4.1. Interruptions"},{"location":"blog/stm32/uart/#42-start-a-new-project","text":"Open STM32CubeIDE and create a new STM32 with the same steps in the previous lab, including configuration for clocks, debug, and UART1.","title":"4.2. Start a new project"},{"location":"blog/stm32/uart/#43-enable-interrupt","text":"Go to USART1 module, select NVIC Settings tab and enable the interrupt. Enable interrupt for USART1 After generating code, the functions to enable interrupt are written in function HAL_UART_MspInit() in stm32f0xx_hal_msp.c file: HAL_NVIC_SetPriority ( USART1_IRQn , 0 , 0 ); HAL_NVIC_EnableIRQ ( USART1_IRQn ); The interrupt handler is added to stm32f0xx_it.c file too. Trace the function HAL_UART_IRQHandler() to understand about how it processes the data. Basically, it checks the error, check the state, and mode of the USART instance; then it save or transfer data on RX or TX wire. void USART1_IRQHandler ( void ) { HAL_UART_IRQHandler ( & huart1 ); }","title":"4.3. Enable interrupt"},{"location":"blog/stm32/uart/#44-send-data-with-interrupt","text":"As said above, use HAL_UART_Transmit_IT() function to send data. main.c char counter = 0 ; char buffer [ 16 ] = { 0 }; // counter=xxx\\n\\r HAL_StatusTypeDef Write ( const char * buffer ) { return HAL_UART_Transmit_IT ( & huart1 , ( uint8_t * ) buffer , strlen ( buffer )); } int main () { char pause = 0 ; while ( 1 ) { if ( pause == 0 ) { sprintf ( buffer , \"counter=%03d \\n\\r \" , counter ++ ); Write ( buffer ); } HAL_Delay ( 1000 ); } } Race condition in Interrupt Mode Consider below code: void printWelcomeMessage ( void ) { HAL_UART_Transmit_IT ( & huart1 , buffer1 , strlen ( buffer1 )); HAL_UART_Transmit_IT ( & huart1 , buffer2 , strlen ( buffer2 )); HAL_UART_Transmit_IT ( & huart1 , buffer3 , strlen ( buffer3 )); } The above code will never work correctly, since each call to the function HAL_UART_Transmit_IT() is much faster than the UART transmission, and the subsequent calls to the HAL_UART_Transmit_IT() will fail as it will see that UART is in the Busy state. If speed is not a strict requirement for the application, and the use of the HAL_UART_Transmit_IT() is limited to few parts of the application, the above code could be rearranged in the following way: void printWelcomeMessage ( void ) { char * strings [] = { buffer1 , buffer2 , buffer3 }; for ( uint8_t i = 0 ; i < 3 ; i ++ ) { HAL_UART_Transmit_IT ( & huart1 , strings [ i ], strlen ( strings [ i ])); while ( HAL_UART_GetState ( & huart1 ) == HAL_UART_STATE_BUSY_TX || HAL_UART_GetState ( & huart1 ) == HAL_UART_STATE_BUSY_TX_RX ); } } When all data in the buffer are sent, HAL library will call to a callback function named HAL_UART_TxCpltCallback() to notify about the end of the transmission. There is no callback when half of data is transferred . This function can be overridden to do something after the buffer is transmitted. main.c char uart_tx_done = 0 ; void HAL_UART_TxCpltCallback ( UART_HandleTypeDef * huart ) { if ( huart == & huart1 ) { uart_tx_done = 1 ; } }","title":"4.4. Send data with interrupt"},{"location":"blog/stm32/uart/#45-receive-data-with-interrupt","text":"Next step is to read data using interrupt with the function HAL_UART_Receive_IT() . Because its unknown time when a character comes, so the buffer for receiving will be filled in at anytime, even when buffer is being used in the sprinf() function, therefore, should use a new buffer to store received data, e.g. command . When the receiver gets enough characters, it will fire an interrupt to run the HAL_UART_RxCpltCallback() function. That function can be overridden to handle received data in the main: char uart_rx_int = 0 ; void HAL_UART_RxCpltCallback ( UART_HandleTypeDef * huart ) { if ( huart == & huart1 ) { uart_rx_int = 1 ; } } In the main function, process received data only when the flag is on: char uart_rx_int = 0 ; char command [ 16 ] = { 0 }; const char MSG_PAUSE [] = \"PAUSED \\n\\r \" ; const char MSG_RESUME [] = \"RESUMED \\n\\r \" ; HAL_StatusTypeDef Read ( char * buffer , int n ) { return HAL_UART_Receive_IT ( & huart1 , ( uint8_t * ) buffer , n ); } void HAL_UART_RxCpltCallback ( UART_HandleTypeDef * huart ) { if ( huart == & huart1 ) { uart_rx_int = 1 ; } } int main () { char pause = 0 ; while ( 1 ) { if ( pause == 0 ) { counter ++ ; sprintf ( buffer , \"counter=%03d \\n\\r \" , counter ); Write ( buffer ); } if ( uart_rx_int == 1 ) { uart_rx_int = 0 ; if ( strncmp ( command , \"stop\" , 4 ) == 0 ) { pause = 1 ; Write ( MSG_PAUSE ); } else if ( strncmp ( command , \"resume\" , 6 ) == 0 ) { pause = 0 ; Write ( MSG_RESUME ); } } Read ( command , 6 ); HAL_Delay ( 1000 ); } } Communicate with UART in interrupt mode Bug: Input length is fixed The above implementation has an issue: The receiving interrupt only is fired when it receives enough number of characters. In the above example, enter stopxx for stop command will work, but stop will never do. To fix this, set the receive mode to get only one byte at a time, then check for the new line / line feed \\n or carriage return \\r character to to determine input sentences. However, this will lead to run the interrupt handler many times if the incoming data rate is high. Here is an example to handle every byte in the Interrupt mode: Received one byte at a time Check the received by with the new line \\n character to separate strings Call Receive function again to listen to a new character char rx_buffer [ 16 ] = { 0 }; int rx_idx = 0 ; char rx = 0 ; void HAL_UART_RxCpltCallback ( UART_HandleTypeDef * huart ) { if ( rx == '\\n' ) { rx_buffer [ rx_idx ] = '\\0' ; strncpy ( command , rx_buffer , 16 ); rx_idx = 0 ; uart_rx_int = 1 ; } else { rx_buffer [ rx_idx ++ ] = rx ; } Read ( & rx , 1 ); } int main ( void ) { Read ( & rx , 1 ); while ( 1 ) { if ( uart_rx_int == 1 ) { uart_rx_int = 0 ; if ( strncmp ( command , \"stop\" , 4 ) == 0 ) {...} } } } This approach can be optimized more by not using the HAL function (both HAL_UART_Receive_IT() and HAL_UART_IRQHandler() ), but by setting up UART_IT_RXNE (Received Data Not Empty) interrupt and then handle this interrupt manually in the USART1_IRQHandler() ISR. __HAL_UART_ENABLE_IT ( & huart1 , UART_IT_RXNE ); void USART1_IRQHandler ( void ) { handle_received_byte (); }","title":"4.5. Receive data with interrupt"},{"location":"blog/stm32/uart/#5-lab-3-dma-mode","text":"The DMA can be used to transfer data in or out through an UART interface. However, DMA still needs to know how many bytes of data should be exchanged. In case of transmitting, it is easy to calculate the length of data, but in case of receiving, it may be unknown length of data.","title":"5. Lab 3: DMA mode"},{"location":"blog/stm32/uart/#51-start-a-new-project","text":"Open STM32CubeIDE and create a new STM32 with the same steps in the previous lab, including configuration for clocks, debug, and UART1.","title":"5.1. Start a new project"},{"location":"blog/stm32/uart/#52-enable-dma","text":"Go to USART1 module, select DMA Settings tab and Add two DMA requests: USART1_TX : This DMA Request has direction of Memory to Peripheral, it means DMA processor will read data from Memory and write to the USART1 Transmit Data Register, therefore, only Memory Address will be increased USART1_RX : This DMA Request has direction of Peripheral to Memory, it means DMA processor will read data from USART1 Receive Data Register and write to Memory, therefore, only Memory Address will be increased DMA only works when the peripheral\u2019s interrupt is enabled, as it needs triggered from the peripheral. Make sure to enable USART1 global / wake-up interrupts through the external interrupt line. Note that STM32CubeMX automatically enable DMA interrupts. To disable it, go to NVIC module under the System Core category. After generating code, there is a new function MX_DMA_Init() added to the main.c file to initialize the DMA module: static void MX_DMA_Init ( void ) { /* DMA controller clock enable */ __HAL_RCC_DMA1_CLK_ENABLE (); /* DMA interrupt init */ /* DMA1_Channel2_3_IRQn interrupt configuration */ HAL_NVIC_SetPriority ( DMA1_Channel2_3_IRQn , 0 , 0 ); HAL_NVIC_EnableIRQ ( DMA1_Channel2_3_IRQn ); } Enable DMA requests on USART1 Inside the HAL_UART_MspInit() function, there are calls to initialize DMA instances for USART1_TX and USART1_RX, and finally links of DMA instances with the USART instance with the function __HAL_LINKDMA . void HAL_UART_MspInit ( UART_HandleTypeDef * huart ) { ... /* DMA USART1_RX Init */ hdma_usart1_rx . Instance = DMA1_Channel3 ; hdma_usart1_rx . Init . Direction = DMA_PERIPH_TO_MEMORY ; hdma_usart1_rx . Init . PeriphInc = DMA_PINC_DISABLE ; hdma_usart1_rx . Init . MemInc = DMA_MINC_ENABLE ; hdma_usart1_rx . Init . PeriphDataAlignment = DMA_PDATAALIGN_BYTE ; hdma_usart1_rx . Init . MemDataAlignment = DMA_MDATAALIGN_BYTE ; hdma_usart1_rx . Init . Mode = DMA_NORMAL ; hdma_usart1_rx . Init . Priority = DMA_PRIORITY_LOW ; if ( HAL_DMA_Init ( & hdma_usart1_rx ) != HAL_OK ) { Error_Handler (); } __HAL_LINKDMA ( huart , hdmarx , hdma_usart1_rx ); /* DMA USART1_TX Init */ hdma_usart1_tx . Instance = DMA1_Channel2 ; hdma_usart1_tx . Init . Direction = DMA_MEMORY_TO_PERIPH ; hdma_usart1_tx . Init . PeriphInc = DMA_PINC_DISABLE ; hdma_usart1_tx . Init . MemInc = DMA_MINC_ENABLE ; hdma_usart1_tx . Init . PeriphDataAlignment = DMA_PDATAALIGN_BYTE ; hdma_usart1_tx . Init . MemDataAlignment = DMA_MDATAALIGN_BYTE ; hdma_usart1_tx . Init . Mode = DMA_NORMAL ; hdma_usart1_tx . Init . Priority = DMA_PRIORITY_LOW ; if ( HAL_DMA_Init ( & hdma_usart1_tx ) != HAL_OK ) { Error_Handler (); } __HAL_LINKDMA ( huart , hdmatx , hdma_usart1_tx ); /* USART1 interrupt Init */ HAL_NVIC_SetPriority ( USART1_IRQn , 0 , 0 ); HAL_NVIC_EnableIRQ ( USART1_IRQn ); } There is also an implementation for DMA interrupt in the file stm32f0xx_it.c which calls to the HAL_DMA_IRQHandler() function. There is no default callback for DMA. User has to set the callbacks manually , as described in the DMA Interrupts section. However, HAL functions will assign a callback when they need to handle an interrupt.","title":"5.2. Enable DMA"},{"location":"blog/stm32/uart/#53-send-data-with-dma","text":"Sending data with DMA is quite easy, just provide the tx_buffer and the length of data to the function HAL_UART_Transmit_DMA() . #define DMA_BUFFER_MAX 16 char tx_buffer [ DMA_BUFFER_MAX ] = { 0 }; HAL_StatusTypeDef Write ( const char * buffer ) { return HAL_UART_Transmit_DMA ( & huart1 , ( uint8_t * ) buffer , strlen ( buffer )); } int main () { char pause = 0 ; while ( 1 ) { if ( pause == 0 ) { sprintf ( tx_buffer , \"counter=%03d \\n\\r \" , counter ++ ); Write ( tx_buffer ); } HAL_Delay ( 1000 ); } } There are two interrupts will be fired for transmission, which are helpful when sending a huge amount of data: DMA notifies application to start loading new data into the first half of the buffer after the TxHalfCpltCallback is fired, while the second half of the buffer is being transmitted by the DMA; then application can load the new data into the second half of the buffer after the TxCpltCallback is fired, while the first half is being transmitted. Using DMA mode can significantly resude the number of UART interrupts, comparing to using Interrupt mode. If there is a variable to keep track of the numbers of UART interrupts, for example in the below code, this number will be increased for every bytes in the transmitting buffer in Interrupt mode (each byte sent causes an interrupt to load the next byte). However, in DMA mode, there is only one interrupt added only when the buffer is completely transfered. size_t uart_irq_counter = 0 ; void USART1_IRQHandler ( void ) { uart_irq_counter ++ ; }","title":"5.3. Send data with DMA"},{"location":"blog/stm32/uart/#54-receive-data-with-dma","text":"Normally, when calling to HAL_UART_Receive_DMA() , the DMA module will stop transferring data when it counts enough bytes set in the parameters. There is the Circular mode that makes DMA continues get data and fills into memory like a ring buffer. Go back to the DMA Settings tab of the USART1 module to set the mode of USART1_RX request to Circular. Enable Circular mode for DMA on USART1_RX Then create a buffer for receiving data, and start DMA Request in the main function: #define DMA_BUFFER_MAX 16 char rx_buffer [ DMA_BUFFER_MAX ] = { 0 }; int main ( void ) { HAL_UART_Receive_DMA ( & huart1 , ( uint8_t * ) rx_buffer , DMA_BUFFER_MAX ); while ( 1 ) {...} } By calling the HAL_UART_Receive_DMA() function, USART1_RX DMA instance will get some callback functions assigned to its Half-transfer and Full-Transfer callbacks. Refer to the function UART_Start_Receive_DMA() for more details. It is possible to configure DMA to transfer one byte at a time and call to an interrupt function to handle the newly received character like in Interrupt mode, but it wastes of resource and performance. However, if application lets DMA to notify only then it receives enough the required number of characters, sometimes there is no notification sent. Assume that application expects to receive 20 chars, but UART only receives 14 chars: Application would be notified when 10 bytes received by Half-Transfer event Application would never be notified the rest of 4 bytes has arrived If UART get more chars, application would be nofified by Full-Transfer event but some chars may be left over","title":"5.4. Receive data with DMA"},{"location":"blog/stm32/uart/#55-uart-idle-detection","text":"Most of STM32 series have USARTs with IDLE Line detection. If IDLE Line detection is not available, some of them have Receiver Timeout feature with programmable delay. IDLE line detection (or Receiver Timeout) can trigger USART interrupt when receive line is steady without any communication for at least 1 character for reception. IDLE Detection Right after enable the UART, the IDLE bit in Interrupt Status Register ISR will be set. However, the interrupt for IDLE detection only gets fired when the bit IDLEIE is set on the Control Register CRx . Therefore, the IDLE interrupt always fire up once rigth after the bit IDLEIE is set. To clear the IDLE interrupt status, either set the IDLECF in the Clear Register or do a read sequence on SR and DR registers. Refer to the Reference Manual documents to get more detail. When IDLE dection is enable, make sure the RX line is not floating to prevent the IDLE flag from being set continuously. DMA RX and IDLE Line detection The good combination for using DMA to get unknown length of data is to use DMA in Circular mode, with big enough memory buffer, then use DMA Half-Transfer, Full-Transfer and the IDLE line detection to notify application to process received data. HAL DMA Receiving function automatically notifies the application by calling HAL_UART_RxHalfCpltCallback() and HAL_UART_RxCpltCallback() . Therefore, it is only needed to override the USART1_IRQHandler() function. To more simple and still left HAL Handler processes other cases, it is better to add a small code just to check the IDLE flag and process received data before handing over the interrupt to original HAL_UART_IRQHandler() function. stm32f0xx_it.c void USART1_IRQHandler ( void ) { if ((( & huart1 ) -> Instance -> ISR & UART_FLAG_IDLE ) != 0 && (( & huart1 ) -> Instance -> CR1 & USART_CR1_IDLEIE ) != 0 ) { __HAL_UART_CLEAR_IDLEFLAG ( & huart1 ); HAL_UART_RxCpltCallback ( & huart1 ); } // pass the work to HAL function HAL_UART_IRQHandler ( & huart1 ); } main.c void HAL_UART_RxCpltCallback ( UART_HandleTypeDef * huart ) { UART_RX_Check ( & hdma_usart1_rx ); } void HAL_UART_RxHalfCpltCallback ( UART_HandleTypeDef * huart ) { UART_RX_Check ( & hdma_usart1_rx ); }","title":"5.5. UART IDLE Detection"},{"location":"blog/stm32/uart/#56-process-continuous-received-data","text":"Due to DMA buffer is a Ring buffer with small number of bytes, it is necessary to copy received bytes from DMA buffer to a bigger UART buffer. There are 2 indexes to mark the bytes position in DMA buffer: new_pos at the last received byte, and old_pos at last processed byte. There is one index uart_index to mark the last byte in the UART buffer. Visualization of memory copy between DMA buffer and UART buffer In DMA buffer, if the new_pos is bigger than the old_pos , it means there is no roll-over, application can copy bytes [ old_pos : new_pos ] to the UART buffer. In DMA buffer, if the new_pos is less than the old_pos , it means there is a roll-over, application can copy bytes [ old_pos : max ] and [0: new_pos ] to the UART buffer. In UART buffer, when buffer is full, it does not get any more character, only character new line \\n will reset the index to 0 To get the new_pos index, aka. Number of received bytes, use the register CNDTR of the DMA instance. Read more about \u201cDMA channel x number of data register ( DMA_CNDTRx and DMA2_CNDTRx )\u201d section in the Reference Manual document. Here is the implementation example for the above solution of processing the received data: #define UART_BUFFER_MAX 64 char uart_buffer [ UART_BUFFER_MAX ] = { 0 }; size_t uart_buffer_idx = 0 ; char uart_new_string = 0 ; void UART_RX_Process ( const void * data , size_t len ) { for ( int i = 0 ; i < len ; i ++ ) { char c = (( char * ) data )[ i ]; if ( uart_buffer_idx < UART_BUFFER_MAX -2 ) { uart_buffer [ uart_buffer_idx ++ ] = c ; uart_buffer [ uart_buffer_idx ] = '\\0' ; } if ( c == '\\n' ) { uart_buffer_idx = 0 ; uart_new_string = 1 ; } } } void UART_RX_Check ( DMA_HandleTypeDef * hdma ) { static size_t old_pos = 0 ; size_t rx_pos = DMA_BUFFER_MAX - hdma -> Instance -> CNDTR ; if ( rx_pos != old_pos ) { // new data if ( rx_pos > old_pos ) { // no overflow UART_RX_Process ( & rx_buffer [ old_pos ], rx_pos - old_pos ); } else { // overflow UART_RX_Process ( & rx_buffer [ old_pos ], DMA_BUFFER_MAX - old_pos ); if ( rx_pos > 0 ) { // run up UART_RX_Process ( & rx_buffer [ old_pos ], rx_pos ); } } old_pos = rx_pos ; } } int main ( void ) { while ( 1 ) { if ( uart_new_string == 1 ) { uart_new_string = 0 ; if ( strncmp ( uart_buffer , \"stop\" , 4 ) == 0 ) {...} } } } This tutorial only show a method to process variable string length in a continuous byte stream. The function UART_RX_Process() should be modified to handle different streaming format. Compile and run with variable string length to find how it works. Below captured image was in a debug section to see how many IDLE interrupts are called, how received bytes are saved into the rx_buffer and to monitor the uart_buffer . Communicate with UART in DMA mode","title":"5.6. Process continuous received data"},{"location":"blog/stm32/uart-redirection/","text":"UART Redirection UART Redirection Simple uart-redirection-src.zip UART Redirection setup Disable the standard system calls implementation in syscalls.c Implement new system calls which communicate on the an UART port Enable and setup an UART port Register redirected system calls on the target UART port Use prinf and scanf for standard output and input UART Redirection system calls Some modified system calls may not properly work with standard IO functions as custom code may not cover all cases, such as for file operations. 1. UART Redirections \u2693\ufe0e 1.1. Enable UART port \u2693\ufe0e Start a new project and follow the guide in UART to enable an UART port in the Normal (polling) mode. 1.2. System calls \u2693\ufe0e When using SemiHosting , the user\u2019s system calls must be disabled, because the rdimon library already implements those functions to communicate with host machine. Using UART Redirection also needs to disable the user\u2019s system calls too. Go to the file syscalls.c and select Properties \u2192 C/C++ Build \u2192 Exclude these resources from build . Exclude systemcall.c from build 1.3. Override system calls \u2693\ufe0e Start replacing the system calls by implement necessary functions in new module uart_redirection . The header file is located in Core/Inc/uart_redirection.h which declares main functions to be replaced: uart_redirection.h #ifndef INC_UART_REDIRECTION_H_ #define INC_UART_REDIRECTION_H_ #include <sys/stat.h> #include \"main.h\" // which includes HAL headers /* function to set global an UART handler used to redirect */ void Set_UART_Redirection_Port ( UART_HandleTypeDef * huart ); /* function declaration, see syscalls.c to get function prototype */ int _read ( int file , char * ptr , int len ); int _write ( int file , char * ptr , int len ); int _close ( int file ); int _fstat ( int file , struct stat * st ); int _isatty ( int file ); int _lseek ( int file , int ptr , int dir ); #endif /* INC_UART_REDIRECTION_H_ */ Then implement those functions in Core/Src/uart_redirection.c . Here are some notes: Save the UART handler to a global variable to use in the internal functions _isatty() should return 1 to indicate the terminal _fstat() should return S_IFCHR to indicate character device, which returns char by char _write() can print out as many characters as possible, and standard IO always knows the length of data _read() should return one byte as the UART is set as a character device. However, there is a reason to read one byte at a time. Read to buffer from standard IO When debugging the _read function, standard IO request to read 1024 bytes, and the function should return the actual read byte. The easiest way to react to unknown input length is to read one by one character only. However, this method has overhead in processing due to recalling the read function multiple times. uart_redirection.c #include <stdio.h> #include \"uart_redirection.h\" /* a global UART handler used to redirect */ UART_HandleTypeDef * g_huart = NULL ; void Set_UART_Redirection_Port ( UART_HandleTypeDef * huart ) { g_huart = huart ; /* Disable I/O buffering for STDOUT stream, so that * chars are sent out as soon as they are printed. */ setvbuf ( stdout , NULL , _IONBF , 0 ); } int _read ( int file , char * ptr , int len ) { HAL_StatusTypeDef hstatus ; if ( g_huart == NULL ) { return 0 ; } /* read one byte only, according to _fstat returning character device type */ hstatus = HAL_UART_Receive ( g_huart , ( uint8_t * ) ptr , 1 , HAL_MAX_DELAY ); if ( hstatus == HAL_OK ) return 1 ; else return 0 ; } int _write ( int file , char * ptr , int len ) { HAL_StatusTypeDef hstatus ; if ( g_huart == NULL ) { return 0 ; } /* write full string */ hstatus = HAL_UART_Transmit ( g_huart , ( uint8_t * ) ptr , len , HAL_MAX_DELAY ); if ( hstatus == HAL_OK ) return len ; else return 0 ; } int _close ( int file ) { /* no file, just return */ return -1 ; } int _fstat ( int file , struct stat * st ) { /* return as a character device type, read one by one character */ st -> st_mode = S_IFCHR ; return 0 ; } int _isatty ( int file ) { /* use as a terminal */ return 1 ; } int _lseek ( int file , int ptr , int dir ) { /* not allow seek, just read char by char */ return 0 ; } A simple implementation A simpler implementation is to override only _read and _write function, as seen in the debugging with Serial Wire Viewer tutorial, as they are defined as weak functions and standard IO eventually call to them to at driver layer. main.c int _read ( int file , char * ptr , int len ) { HAL_StatusTypeDef hstatus ; hstatus = HAL_UART_Receive ( & huart1 , ( uint8_t * ) ptr , 1 , HAL_MAX_DELAY ); if ( hstatus == HAL_OK ) return 1 ; else return 0 ; } int _write ( int file , char * ptr , int len ) { HAL_StatusTypeDef hstatus ; hstatus = HAL_UART_Transmit ( & huart1 , ( uint8_t * ) ptr , len , HAL_MAX_DELAY ); if ( hstatus == HAL_OK ) return len ; else return 0 ; } \\ 1.4. Enable redirection \u2693\ufe0e In main.c , call to the register function Set_UART_Redirection_Port() at the beginning of the application main. Then include <stdio.h> and use printf() , scanf() or gets() . main.c #include <stdio.h> #include \"uart_redirection.h\" char counter = 0 ; int max = 255 ; int main ( void ) { int imax = 255 ; /*Init UART1 */ ... Set_Redirect_UART_Port ( & huart1 ); printf ( \"Set max counter: \" ); scanf ( \"%d\" , & imax ); max = ( unsigned char ) imax ; printf ( \"Count to %d \\n\\r \" , max ); while ( 1 ) { printf ( \"counter=%3d \\r\\n \" , counter ++ ); if ( counter > ( char ) max ) { counter = 0 ; } HAL_Delay ( 1000 ); } } Build and run on the target board, and connect the UART port to a COM port on the host machine. Interaction by UART Redirection Current implementation use UART Polling mode with reading / writing one byte at a time, therefore, it has some overhead and affect to the system performance.","title":"UART Redirection"},{"location":"blog/stm32/uart-redirection/#1-uart-redirections","text":"","title":"1. UART Redirections"},{"location":"blog/stm32/uart-redirection/#11-enable-uart-port","text":"Start a new project and follow the guide in UART to enable an UART port in the Normal (polling) mode.","title":"1.1. Enable UART port"},{"location":"blog/stm32/uart-redirection/#12-system-calls","text":"When using SemiHosting , the user\u2019s system calls must be disabled, because the rdimon library already implements those functions to communicate with host machine. Using UART Redirection also needs to disable the user\u2019s system calls too. Go to the file syscalls.c and select Properties \u2192 C/C++ Build \u2192 Exclude these resources from build . Exclude systemcall.c from build","title":"1.2. System calls"},{"location":"blog/stm32/uart-redirection/#13-override-system-calls","text":"Start replacing the system calls by implement necessary functions in new module uart_redirection . The header file is located in Core/Inc/uart_redirection.h which declares main functions to be replaced: uart_redirection.h #ifndef INC_UART_REDIRECTION_H_ #define INC_UART_REDIRECTION_H_ #include <sys/stat.h> #include \"main.h\" // which includes HAL headers /* function to set global an UART handler used to redirect */ void Set_UART_Redirection_Port ( UART_HandleTypeDef * huart ); /* function declaration, see syscalls.c to get function prototype */ int _read ( int file , char * ptr , int len ); int _write ( int file , char * ptr , int len ); int _close ( int file ); int _fstat ( int file , struct stat * st ); int _isatty ( int file ); int _lseek ( int file , int ptr , int dir ); #endif /* INC_UART_REDIRECTION_H_ */ Then implement those functions in Core/Src/uart_redirection.c . Here are some notes: Save the UART handler to a global variable to use in the internal functions _isatty() should return 1 to indicate the terminal _fstat() should return S_IFCHR to indicate character device, which returns char by char _write() can print out as many characters as possible, and standard IO always knows the length of data _read() should return one byte as the UART is set as a character device. However, there is a reason to read one byte at a time. Read to buffer from standard IO When debugging the _read function, standard IO request to read 1024 bytes, and the function should return the actual read byte. The easiest way to react to unknown input length is to read one by one character only. However, this method has overhead in processing due to recalling the read function multiple times. uart_redirection.c #include <stdio.h> #include \"uart_redirection.h\" /* a global UART handler used to redirect */ UART_HandleTypeDef * g_huart = NULL ; void Set_UART_Redirection_Port ( UART_HandleTypeDef * huart ) { g_huart = huart ; /* Disable I/O buffering for STDOUT stream, so that * chars are sent out as soon as they are printed. */ setvbuf ( stdout , NULL , _IONBF , 0 ); } int _read ( int file , char * ptr , int len ) { HAL_StatusTypeDef hstatus ; if ( g_huart == NULL ) { return 0 ; } /* read one byte only, according to _fstat returning character device type */ hstatus = HAL_UART_Receive ( g_huart , ( uint8_t * ) ptr , 1 , HAL_MAX_DELAY ); if ( hstatus == HAL_OK ) return 1 ; else return 0 ; } int _write ( int file , char * ptr , int len ) { HAL_StatusTypeDef hstatus ; if ( g_huart == NULL ) { return 0 ; } /* write full string */ hstatus = HAL_UART_Transmit ( g_huart , ( uint8_t * ) ptr , len , HAL_MAX_DELAY ); if ( hstatus == HAL_OK ) return len ; else return 0 ; } int _close ( int file ) { /* no file, just return */ return -1 ; } int _fstat ( int file , struct stat * st ) { /* return as a character device type, read one by one character */ st -> st_mode = S_IFCHR ; return 0 ; } int _isatty ( int file ) { /* use as a terminal */ return 1 ; } int _lseek ( int file , int ptr , int dir ) { /* not allow seek, just read char by char */ return 0 ; } A simple implementation A simpler implementation is to override only _read and _write function, as seen in the debugging with Serial Wire Viewer tutorial, as they are defined as weak functions and standard IO eventually call to them to at driver layer. main.c int _read ( int file , char * ptr , int len ) { HAL_StatusTypeDef hstatus ; hstatus = HAL_UART_Receive ( & huart1 , ( uint8_t * ) ptr , 1 , HAL_MAX_DELAY ); if ( hstatus == HAL_OK ) return 1 ; else return 0 ; } int _write ( int file , char * ptr , int len ) { HAL_StatusTypeDef hstatus ; hstatus = HAL_UART_Transmit ( & huart1 , ( uint8_t * ) ptr , len , HAL_MAX_DELAY ); if ( hstatus == HAL_OK ) return len ; else return 0 ; } \\","title":"1.3. Override system calls"},{"location":"blog/stm32/uart-redirection/#14-enable-redirection","text":"In main.c , call to the register function Set_UART_Redirection_Port() at the beginning of the application main. Then include <stdio.h> and use printf() , scanf() or gets() . main.c #include <stdio.h> #include \"uart_redirection.h\" char counter = 0 ; int max = 255 ; int main ( void ) { int imax = 255 ; /*Init UART1 */ ... Set_Redirect_UART_Port ( & huart1 ); printf ( \"Set max counter: \" ); scanf ( \"%d\" , & imax ); max = ( unsigned char ) imax ; printf ( \"Count to %d \\n\\r \" , max ); while ( 1 ) { printf ( \"counter=%3d \\r\\n \" , counter ++ ); if ( counter > ( char ) max ) { counter = 0 ; } HAL_Delay ( 1000 ); } } Build and run on the target board, and connect the UART port to a COM port on the host machine. Interaction by UART Redirection Current implementation use UART Polling mode with reading / writing one byte at a time, therefore, it has some overhead and affect to the system performance.","title":"1.4. Enable redirection"},{"location":"blog/virtual-machine/","text":"","title":"Virtual machine"},{"location":"blog/virtual-machine/docker/","text":"Docker gained so much popularity and adoption in the DevOps community in a short time because of the way it\u2019s developed for portability and designed for modern microservice architecture. 1. Linux container \u2693\ufe0e The concept of containers started way back in the 2000s. In fact, the roots go back to 1979 where chroot was introduced \u2014 it\u2019s a concept of changing the root directory of a process. In a typical virtualized environment, one or more virtual machines run on top of a physical server using a hypervisor like Hyper-V. Containers, on the other hand, run on top of operating systems\u2019 kernel \u2014 so called OS-level virtualization. A container is a Process When a process is started, it runs in a self-contained virtual space. However, it still interacts with external environment. If a process is isolated with all of its files, configurations to make it run and operate, it needs to be in a container, and a container actually to that. A container is basically a process with enough isolation of user-space components so that it gives a feeling of a separate operating system. A process and A container 2. Docker \u2693\ufe0e Docker evolved on Linux. A container is considered \u201cnative\u201d, if it can run directly on the host operating system. Therefore, Docker runs on Linux is a native docker container. To run a container on Windows, Docker has to create a Linux Virtual Machine using virtualization to emulate a Linux environment. This virtualization can be: VirtualBox (Docker Toolbox) Hyper-V backend or WSL2 backend (Docker Desktop) Install Docker on Windows On Windows, there are Windows (Server) Containers: Windows applications that run in isolated Windows environment. Windows Hyper-V can be used to run even native Windows containers, which is generally a source of confusion: Process Isolation: This is the \u201ctraditional\u201d isolation mode for containers. It is approximately the same as how Linux containers run on Linux Hyper-V isolation: This isolation mode offers enhanced security and broader compatibility between host and container versions. 3. How Docker works \u2693\ufe0e When Docker starts at the first time, Docker will create a Virtual Machine which runs a Linux OS. Open the Hyper-V Manager to see the configuration of that VM. Docker Desktop Virtual Machine This virtual machine is initialized from an ISO disk image located in C:\\Program Files\\Docker\\Docker\\resources\\docker-desktop.iso . Let\u2019s inspect the virtual machine by connecting it and access into its terminal: uname -a Linux 6a7ab2c7921c 5 .10.25-linuxkit #1 SMP Tue Mar 23 09:27:39 UTC 2021 x86_64 x86_64 x86_64 GNU/Linux It shows a Linux kernel version 5.10 in linuxkit repo! What is the linuxkit repo? It is a special kernel under development of Linux Kit team which provides a toolkit for building custom minimal, immutable Linux distributions. Read more in https://github.com/linuxkit/linuxkit . Docker Desktop Kernel Docker takes advantage of several features of the Linux kernel to deliver its functionality. Namespaces Docker makes use of kernel namespaces to provide the isolated workspace called the container . When container runs, Docker creates a set of namespaces for that container. These namespaces provide a layer of isolation. Each aspect of a container runs in a separate namespace and its access is limited to that namespace. Docker Engine uses the following namespaces on Linux: PID namespace for process isolation. NET namespace for managing network interfaces. IPC namespace for managing access to IPC resources. MNT namespace for managing file system mount points. UTS namespace for isolating kernel and version identifiers. Cgroups Docker also makes use of kernel control groups for resource allocation and isolation. A cgroup limits an application to a specific set of resources. Control groups allow Docker Engine to share available hardware resources to containers and optionally enforce limits and constraints. Docker Engine uses the following cgroups: Memory cgroup for managing accounting, limits and notifications. HugeTBL cgroup for accounting usage of huge pages by process group. CPU cgroup for managing user / system CPU time and usage. CPUSet cgroup for binding a group to specific CPU. Useful for real time applications and NUMA systems with localized memory per CPU. BlkIO cgroup for measuring & limiting amount of blckIO by group. net_cls and net_prio cgroup for tagging the traffic control. Devices cgroup for reading / writing access devices. Freezer cgroup for freezing a group. Useful for cluster batch scheduling, process migration and debugging without affecting prtrace . Union File Systems Union file systems operate by creating layers, making them very lightweight and fast. Docker Engine uses UnionFS to provide the building blocks for containers. Docker Engine can use multiple UnionFS variants, including AUFS, btrfs, vfs, and device mapper. Container Format Docker Engine combines the namespaces, control groups and UnionFS into a wrapper called a container format. The default container format is libcontainer . Here are main points about container: Containers share the host kernel Containers use the kernel ability to group processes for resource control Containers ensure isolation through namespaces Containers feel like lightweight VMs (lower footprint, faster), but are not Virtual Machines! When a container runs, it basically extracts the container image content then add its layers using UnionFS into the host kernel, in an isolated namespace, under a control group, and finally expose to user that isolated live running container. 3.1. Inspect an image \u2693\ufe0e To get an image, pull it from Docker Hub . Let get the latest Ubuntu image from https://hub.docker.com/_/ubuntu using image name ubuntu and the tag name latest : docker pull ubuntu:latest Pull the latest Ubuntu image To export the downloaded image to a file, use save command as below: docker image save ubuntu > ubuntu.tar Extract the ubuntu.tar file to get its content: \u2502 X.json \u2502 manifest.json \u2502 repositories \u2502 \u2514\u2500\u2500\u2500X json layer.tar VERSION The repositories has the SHA id X of the image: repositories { \"ubuntu\" : { \"latest\" : \"X\" } } Then the manifest.json has information about the image configuration and its layers. manifest.json [ { Config : \"Y.json\" , RepoTags : [ \"ubuntu:latest\" ], Layers : [ \"X/layer.tar\" ], }, ]; In the configure file, there are some more information that can be seen in clear text: Environment PATH Build Command Layers { \"architecture\" : \"amd64\" , \"config\" : { ... \"Env\" : [ \"PATH=/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin\" ], \"Cmd\" : [ \"bash\" ], \"Image\" : \"sha256:Z\" , ... }, \"container\" : \"A\" , \"container_config\" : { ... \"Env\" : [ \"PATH=/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin\" ], \"Cmd\" : [ \"/bin/sh\" , \"-c\" , \"#(nop) \" , \"CMD [\\\"bash\\\"]\" ], \"Image\" : \"sha256:Z\" , ... }, \"created\" : \"2021-06-17T23:31:29.779641053Z\" , \"docker_version\" : \"19.03.12\" , \"history\" : [ { \"created\" : \"2021-06-17T23:31:29.39657203Z\" , \"created_by\" : \"/bin/sh -c #(nop) ADD file:B in / \" }, { \"created\" : \"2021-06-17T23:31:29.779641053Z\" , \"created_by\" : \"/bin/sh -c #(nop) CMD [\\\"bash\\\"]\" , \"empty_layer\" : true } ], \"os\" : \"linux\" , \"rootfs\" : { \"type\" : \"layers\" , \"diff_ids\" : [ \"sha256:C\" ] } } And zipped files .tar contain file system of each layer, which will be populated into the host kernel in an isolated namespace. File system in a layer That\u2019s how container works. 4. Reference \u2693\ufe0e https://medium.com/@BeNitinAgarwal/understanding-the-docker-internals-7ccb052ce9fe http://docker-saigon.github.io/post/Docker-Internals/","title":"Docker"},{"location":"blog/virtual-machine/docker/#1-linux-container","text":"The concept of containers started way back in the 2000s. In fact, the roots go back to 1979 where chroot was introduced \u2014 it\u2019s a concept of changing the root directory of a process. In a typical virtualized environment, one or more virtual machines run on top of a physical server using a hypervisor like Hyper-V. Containers, on the other hand, run on top of operating systems\u2019 kernel \u2014 so called OS-level virtualization. A container is a Process When a process is started, it runs in a self-contained virtual space. However, it still interacts with external environment. If a process is isolated with all of its files, configurations to make it run and operate, it needs to be in a container, and a container actually to that. A container is basically a process with enough isolation of user-space components so that it gives a feeling of a separate operating system. A process and A container","title":"1. Linux container"},{"location":"blog/virtual-machine/docker/#2-docker","text":"Docker evolved on Linux. A container is considered \u201cnative\u201d, if it can run directly on the host operating system. Therefore, Docker runs on Linux is a native docker container. To run a container on Windows, Docker has to create a Linux Virtual Machine using virtualization to emulate a Linux environment. This virtualization can be: VirtualBox (Docker Toolbox) Hyper-V backend or WSL2 backend (Docker Desktop) Install Docker on Windows On Windows, there are Windows (Server) Containers: Windows applications that run in isolated Windows environment. Windows Hyper-V can be used to run even native Windows containers, which is generally a source of confusion: Process Isolation: This is the \u201ctraditional\u201d isolation mode for containers. It is approximately the same as how Linux containers run on Linux Hyper-V isolation: This isolation mode offers enhanced security and broader compatibility between host and container versions.","title":"2. Docker"},{"location":"blog/virtual-machine/docker/#3-how-docker-works","text":"When Docker starts at the first time, Docker will create a Virtual Machine which runs a Linux OS. Open the Hyper-V Manager to see the configuration of that VM. Docker Desktop Virtual Machine This virtual machine is initialized from an ISO disk image located in C:\\Program Files\\Docker\\Docker\\resources\\docker-desktop.iso . Let\u2019s inspect the virtual machine by connecting it and access into its terminal: uname -a Linux 6a7ab2c7921c 5 .10.25-linuxkit #1 SMP Tue Mar 23 09:27:39 UTC 2021 x86_64 x86_64 x86_64 GNU/Linux It shows a Linux kernel version 5.10 in linuxkit repo! What is the linuxkit repo? It is a special kernel under development of Linux Kit team which provides a toolkit for building custom minimal, immutable Linux distributions. Read more in https://github.com/linuxkit/linuxkit . Docker Desktop Kernel Docker takes advantage of several features of the Linux kernel to deliver its functionality. Namespaces Docker makes use of kernel namespaces to provide the isolated workspace called the container . When container runs, Docker creates a set of namespaces for that container. These namespaces provide a layer of isolation. Each aspect of a container runs in a separate namespace and its access is limited to that namespace. Docker Engine uses the following namespaces on Linux: PID namespace for process isolation. NET namespace for managing network interfaces. IPC namespace for managing access to IPC resources. MNT namespace for managing file system mount points. UTS namespace for isolating kernel and version identifiers. Cgroups Docker also makes use of kernel control groups for resource allocation and isolation. A cgroup limits an application to a specific set of resources. Control groups allow Docker Engine to share available hardware resources to containers and optionally enforce limits and constraints. Docker Engine uses the following cgroups: Memory cgroup for managing accounting, limits and notifications. HugeTBL cgroup for accounting usage of huge pages by process group. CPU cgroup for managing user / system CPU time and usage. CPUSet cgroup for binding a group to specific CPU. Useful for real time applications and NUMA systems with localized memory per CPU. BlkIO cgroup for measuring & limiting amount of blckIO by group. net_cls and net_prio cgroup for tagging the traffic control. Devices cgroup for reading / writing access devices. Freezer cgroup for freezing a group. Useful for cluster batch scheduling, process migration and debugging without affecting prtrace . Union File Systems Union file systems operate by creating layers, making them very lightweight and fast. Docker Engine uses UnionFS to provide the building blocks for containers. Docker Engine can use multiple UnionFS variants, including AUFS, btrfs, vfs, and device mapper. Container Format Docker Engine combines the namespaces, control groups and UnionFS into a wrapper called a container format. The default container format is libcontainer . Here are main points about container: Containers share the host kernel Containers use the kernel ability to group processes for resource control Containers ensure isolation through namespaces Containers feel like lightweight VMs (lower footprint, faster), but are not Virtual Machines! When a container runs, it basically extracts the container image content then add its layers using UnionFS into the host kernel, in an isolated namespace, under a control group, and finally expose to user that isolated live running container.","title":"3. How Docker works"},{"location":"blog/virtual-machine/docker/#31-inspect-an-image","text":"To get an image, pull it from Docker Hub . Let get the latest Ubuntu image from https://hub.docker.com/_/ubuntu using image name ubuntu and the tag name latest : docker pull ubuntu:latest Pull the latest Ubuntu image To export the downloaded image to a file, use save command as below: docker image save ubuntu > ubuntu.tar Extract the ubuntu.tar file to get its content: \u2502 X.json \u2502 manifest.json \u2502 repositories \u2502 \u2514\u2500\u2500\u2500X json layer.tar VERSION The repositories has the SHA id X of the image: repositories { \"ubuntu\" : { \"latest\" : \"X\" } } Then the manifest.json has information about the image configuration and its layers. manifest.json [ { Config : \"Y.json\" , RepoTags : [ \"ubuntu:latest\" ], Layers : [ \"X/layer.tar\" ], }, ]; In the configure file, there are some more information that can be seen in clear text: Environment PATH Build Command Layers { \"architecture\" : \"amd64\" , \"config\" : { ... \"Env\" : [ \"PATH=/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin\" ], \"Cmd\" : [ \"bash\" ], \"Image\" : \"sha256:Z\" , ... }, \"container\" : \"A\" , \"container_config\" : { ... \"Env\" : [ \"PATH=/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin\" ], \"Cmd\" : [ \"/bin/sh\" , \"-c\" , \"#(nop) \" , \"CMD [\\\"bash\\\"]\" ], \"Image\" : \"sha256:Z\" , ... }, \"created\" : \"2021-06-17T23:31:29.779641053Z\" , \"docker_version\" : \"19.03.12\" , \"history\" : [ { \"created\" : \"2021-06-17T23:31:29.39657203Z\" , \"created_by\" : \"/bin/sh -c #(nop) ADD file:B in / \" }, { \"created\" : \"2021-06-17T23:31:29.779641053Z\" , \"created_by\" : \"/bin/sh -c #(nop) CMD [\\\"bash\\\"]\" , \"empty_layer\" : true } ], \"os\" : \"linux\" , \"rootfs\" : { \"type\" : \"layers\" , \"diff_ids\" : [ \"sha256:C\" ] } } And zipped files .tar contain file system of each layer, which will be populated into the host kernel in an isolated namespace. File system in a layer That\u2019s how container works.","title":"3.1. Inspect an image"},{"location":"blog/virtual-machine/docker/#4-reference","text":"https://medium.com/@BeNitinAgarwal/understanding-the-docker-internals-7ccb052ce9fe http://docker-saigon.github.io/post/Docker-Internals/","title":"4. Reference"},{"location":"blog/virtual-machine/hyper-v/","text":"1. Reasons to use virtualization \u2693\ufe0e Virtualization allows to: Run software that requires an older version of Windows or non-Windows operating systems. Experiment with other operating systems. Hyper-V makes it very easy to create and remove different operating systems. Test software on multiple operating systems using multiple virtual machines. Info When enabling the Hyper-v role on windows, it actually makes modifications to the kernel allowing VNs to run alongside the rest of windows (type 1) similar to how KVM is a kernel module on Linux. VirtualBox runs atop the guest kernel not alongside it (type 2) which is what separates the two types of hypervisors. 2. Limitations \u2693\ufe0e Programs that depend on specific hardware will not work well in a virtual machine, such as applications that require processing with GPUs, a music mixing applications that require sub-10ms timers. In addition, if Hyper-V enabled, those latency-sensitive, high-precision applications may also have issues running in the host. This is because with virtualization enabled, the host OS also runs on top of the Hyper-V virtualization layer, just as guest operating systems do . However, unlike guests, the host OS is special in that it has direct access to all the hardware, which means that applications with special hardware requirements can still run without issues in the host OS. Hypervisor types 3. Switch between Hyper-V on / off \u2693\ufe0e Using the Hyper-V is mandatory to run Docker , but it reduces the Windows performance a bit. Older version of VMWare and VirtualBox can not run when Hyper-V is enabled. Newer versions can run along with Hyper-V, but performance is impacted. . Some sites say to use Add/Remove Features to turn the Hyper-V support off, but that seems like a big deal to do what should be a small thing. Windows has config in Boot up settings to load/ unload Hyper-V. If the current boot-up session of Windows has Hyper-V enabled, then make new boot ID by duplicating the current ID: bcdedit /copy { current } /d \"Hyper-V\" Then disable the Hyper-V in current boot ID: bcdedit /set { current } hypervisorlaunchtype off By that way, default boot-up will not load Hyper-V, but booting through \u201cHyper-V\u201d ID will get it enabled. Info To switch between boot ID, hold down the Shift key while clicking on the Restart menu. If Intel HAXM check tool is available, it can be used to check if Hyper-V is totally disabled: C:\\Program Files\\Intel\\HAXM>checktool.exe -v CPU vendor * GenuineIntel Intel64 supported * Yes VMX supported * Yes VMX enabled * Yes EPT supported * Yes NX supported * Yes NX enabled * Yes Hyper-V disabled * Yes OS version * Windows 10 .0.17763 OS architecture * x86_64 Guest unoccupied * Yes. 0 guest ( s ) When Hyper-V disabled = No , some functions also are reported to not supported, such as VMX supported because VMX (Virtual machine) can not be enabled on the Hypervisor layer. 4. Reference \u2693\ufe0e https://www.nakivo.com/blog/hyper-v-virtualbox-one-choose-infrastructure/","title":"Hyper-V"},{"location":"blog/virtual-machine/hyper-v/#1-reasons-to-use-virtualization","text":"Virtualization allows to: Run software that requires an older version of Windows or non-Windows operating systems. Experiment with other operating systems. Hyper-V makes it very easy to create and remove different operating systems. Test software on multiple operating systems using multiple virtual machines. Info When enabling the Hyper-v role on windows, it actually makes modifications to the kernel allowing VNs to run alongside the rest of windows (type 1) similar to how KVM is a kernel module on Linux. VirtualBox runs atop the guest kernel not alongside it (type 2) which is what separates the two types of hypervisors.","title":"1. Reasons to use virtualization"},{"location":"blog/virtual-machine/hyper-v/#2-limitations","text":"Programs that depend on specific hardware will not work well in a virtual machine, such as applications that require processing with GPUs, a music mixing applications that require sub-10ms timers. In addition, if Hyper-V enabled, those latency-sensitive, high-precision applications may also have issues running in the host. This is because with virtualization enabled, the host OS also runs on top of the Hyper-V virtualization layer, just as guest operating systems do . However, unlike guests, the host OS is special in that it has direct access to all the hardware, which means that applications with special hardware requirements can still run without issues in the host OS. Hypervisor types","title":"2. Limitations"},{"location":"blog/virtual-machine/hyper-v/#3-switch-between-hyper-v-on--off","text":"Using the Hyper-V is mandatory to run Docker , but it reduces the Windows performance a bit. Older version of VMWare and VirtualBox can not run when Hyper-V is enabled. Newer versions can run along with Hyper-V, but performance is impacted. . Some sites say to use Add/Remove Features to turn the Hyper-V support off, but that seems like a big deal to do what should be a small thing. Windows has config in Boot up settings to load/ unload Hyper-V. If the current boot-up session of Windows has Hyper-V enabled, then make new boot ID by duplicating the current ID: bcdedit /copy { current } /d \"Hyper-V\" Then disable the Hyper-V in current boot ID: bcdedit /set { current } hypervisorlaunchtype off By that way, default boot-up will not load Hyper-V, but booting through \u201cHyper-V\u201d ID will get it enabled. Info To switch between boot ID, hold down the Shift key while clicking on the Restart menu. If Intel HAXM check tool is available, it can be used to check if Hyper-V is totally disabled: C:\\Program Files\\Intel\\HAXM>checktool.exe -v CPU vendor * GenuineIntel Intel64 supported * Yes VMX supported * Yes VMX enabled * Yes EPT supported * Yes NX supported * Yes NX enabled * Yes Hyper-V disabled * Yes OS version * Windows 10 .0.17763 OS architecture * x86_64 Guest unoccupied * Yes. 0 guest ( s ) When Hyper-V disabled = No , some functions also are reported to not supported, such as VMX supported because VMX (Virtual machine) can not be enabled on the Hypervisor layer.","title":"3. Switch between Hyper-V on / off"},{"location":"blog/virtual-machine/hyper-v/#4-reference","text":"https://www.nakivo.com/blog/hyper-v-virtualbox-one-choose-infrastructure/","title":"4. Reference"},{"location":"projects/","text":"I have published some of my personal projects on my GitHub at vuquangtrong . If you are interested, feel free to ask me for more details. Any feedback or comment is welcome. STM32 Tutorials I made this series of tutorials for one of my training courses in my company, then I\u2019d like to share it here to help others who also start learning about ARM Cortex-M MCUs. Read the series in STM32 posts . MkDocs Material Blog theme Based on the Material for MkDocs theme, I added some modifications to restyle my site to make it look like a blog. As shown here, I added the homepage, tags and a tag cloud, featured posts. It also enables markdown extensions to help writing a blog post faster. Details in Set up my blog . Simplify Pelican Theme I used Pelican static site generator before I moved to MkDocs. At that time, I made a theme for this blog using Bootstrap and Jinja template. Pelican, same as MkDocs, is based on Python. VA-Camera This is a small project that uses Accord framework and FFmpeg engine to record video streams from 2 cameras and write combined videos with some overlay text to mp4 files. Because the application runs in a very low performance machine, I\u2019ve had to add some optimizations to operate on the image buffer. Tiva C TM4C123G Launchpad I practiced on ARM Cortex-M4F which was the first ARM core I learned. That repo contains my self-learning projects, including Bring Up, Sensors, LCD, BootLoader and Firmware Update labs. SMS Web Hub This project uses a mobile phone to process commands from a website on the internet (e.g. hosted on a VPS) via websocket, include sending SMS, checking Balance, calling a number, forwarding messages. Other Proof of Concept (PoC) projects This repo has prototypes for freelance projects I have done. As their source code are not allowed to be published by contracts, I just show some demonstrations with some features somehow related to the projects. Show ToC sidebar \u2693\ufe0e .md-nav.md-nav--secondary { display: none; }","title":"Projects"},{"location":"projects/#show-toc-sidebar","text":".md-nav.md-nav--secondary { display: none; }","title":"Show ToC sidebar"},{"location":"tags/","text":"Tags \u2693\ufe0e","title":"Tags"},{"location":"tags/#tags","text":"","title":"Tags"}]}